%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Elementare Dateneingabe und -verarbeitung}
\label{sec:basics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Die folgenden Abschnitte sollen gleichzeitig die grundlegenden Datenstrukturen in R sowie Möglichkeiten zur deskriptiven Datenauswertung erläutern. Die Reihenfolge der Themen ist dabei so gewählt, dass die abwechselnd vorgestellten Datenstrukturen und darauf aufbauenden deskriptiven Methoden nach und nach an Komplexität gewinnen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Vektoren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

R ist auf die Verarbeitung von in Vektoren angeordneten Daten ausgerichtet. Ein\index{Vektor} Vektor ist dabei lediglich eine Datenstruktur für eine sequentiell geordnete Menge einzelner Werte und nicht mit dem mathematischen Konzept eines Vektors zu verwechseln. Da sich empirische Daten einer Variable meist als eine sequentiell anzuordnende Wertemenge betrachten lassen, sind Vektoren als Organisationsform gut für die Datenanalyse geeignet. Vektoren sind in R die einfachste Datenstruktur für Werte, d.\,h.\ auch jeder Einzelwert ist ein Vektor der Länge $1$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vektoren erzeugen}
\label{sec:vector}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!erstellen}
Vektoren werden durch Funktionen erzeugt, die den Namen eines Datentyps tragen und als Argument die Anzahl der zu speichernden Elemente erwarten, also etwa\index[func]{numeric()@\lstinline{numeric()}} \lstinline!numeric(<<Anzahl>>)!.\footnote{\label{ftn:vecDetails}Ein leerer Vektor entsteht analog, z.\,B.\ durch \lstinline!numeric(0)!. Auf 32bit-Systemen kann ein Vektor höchstens\index[func]{.Machine@\lstinline{.Machine}} \lstinline!.Machine$integer.max! viele ($2^{31}-1$) Elemente enthalten, auf heutigen 64bit-Systemen jedoch gut $2^{50}$. Mit\index[func]{vector()@\lstinline{vector()}} \lstinline!vector(mode="<<Klasse>>", length=<<Länge>>)! lassen sich beliebige Objekte der für \lstinline!mode! genannten Klasse der Länge \lstinline!length! erzeugen.} Die Elemente des Vektors werden hierbei auf eine Voreinstellung gesetzt, die vom Datentyp abhängt -- \lstinline!0! für \lstinline!numeric()!, \lstinline!""! für \lstinline!character! und \lstinline!FALSE! für \lstinline!logical!.
\begin{lstlisting}
> numeric(4)
[1] 0 0 0 0

> character(2)
[1] "" ""
\end{lstlisting}

Als häufiger genutzte Alternative lassen sich Vektoren auch mit der Funktion \lstinline!c(<<Wert1>>, <<Wert2>>, ...)!\index[func]{c()@\lstinline{c()}|textbf} erstellen (\emph{concatenate}), die die Angabe der zu speichernden Werte benötigt. Ein das Alter von sechs Personen speichernder Vektor könnte damit so erstellt werden:
\begin{lstlisting}
> (age <- c(18, 20, 30, 24, 23, 21))
[1] 18 20 30 24 23 21
\end{lstlisting}

\index{Vektor!zusammenfügen}
Dabei werden die Werte in der angegebenen Reihenfolge gespeichert und intern mit fortlaufenden Indizes für ihre Position im Vektor versehen. Sollen bereits bestehende Vektoren zusammengefügt werden, ist ebenfalls \lstinline!c()! zu nutzen, wobei statt eines einzelnen Wertes auch der Name eines schon existierenden Vektors angegeben werden kann.
\begin{lstlisting}
> addAge  <- c(27, 21, 19)                # zusätzlicher Vektor
> (ageNew <- c(age, addAge))              # kombinierter Vektor
[1] 18 30 30 25 23 21 27 21 19
\end{lstlisting}

Mit \lstinline!length(<<Vektor>>)!\index[func]{length()@\lstinline{length()}|textbf}\index{Vektor!Anzahl Elemente}\index{Vektor!Länge} wird die Länge eines Vektors, d.\,h.\ die Anzahl der in ihm gespeicherten Elemente, erfragt.
\begin{lstlisting}
> length(age)
[1] 6
\end{lstlisting}

Auch Zeichenketten können die Elemente eines Vektors ausmachen. Dabei zählt die leere Zeichenkette \lstinline!""! ebenfalls als ein Element.
\begin{lstlisting}
> (chars <- c("lorem", "ipsum", "dolor", ""))
[1] "lorem" "ipsum" "dolor" ""

> length(chars)
[1] 4
\end{lstlisting}

Mit \lstinline!LETTERS!\index[func]{LETTERS@\lstinline{LETTERS, letters}} und \lstinline!letters! sind zwei aus Zeichen bestehende Vektoren bereits vordefiniert, die jeweils alle Buchstaben A--Z bzw.\ a--z in alphabetischer Reihenfolge als Elemente besitzen.
\begin{lstlisting}
> LETTERS[c(1, 2, 3)]               # Alphabet in Großbuchstaben
[1] "A" "B" "C"

> letters[c(4, 5, 6)]               # Alphabet in Kleinbuchstaben
[1] "d" "e" "f"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elemente auswählen und verändern}
\label{sec:vecSel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Elemente auswählen}
\index{Vektor!indizieren}
Um ein einzelnes Element eines Vektors abzurufen, wird seine Position im Vektor (sein Index) in eckigen Klammern hinter dem Objektnamen angegeben. Dies ist der \lstinline![<<Index>>]!\index[func]{[]@\lstinline{[]}} Operator\footnote{Für Hilfe zu diesem Thema s.\ \lstinline!?Extract!. Auch der Index-Operator ist eine Funktion, kann also gleichermaßen in der Form \lstinline!\"[\"(<<Vektor>>, <<Index>>)! verwendet werden (Abschn.\ \ref{sec:funcParam}, Fußnote \ref{ftn:functional}).} Indizes beginnen bei $1$ für die erste Position\footnote{Dies mag selbstverständlich erscheinen, in anderen Sprachen wird jedoch oft der Index $0$ für die erste Position und allgemein der Index $i-1$ für die $i$\/-te Position verwendet. Für einen Vektor \lstinline!x! ist das Ergebnis von \lstinline!x[0]! immer ein leerer Vektor mit demselben Datentyp wie jener von \lstinline!x!.} und enden bei der Länge des Vektors. Werden größere Indizes verwendet, erfolgt als Ausgabe die für einen fehlenden Wert stehende Konstante \lstinline!NA! (Abschn.\ \ref{sec:na}).
\begin{lstlisting}
> age[4]                                    # 4. Element von age
[1] 24

> (ageLast <- age[length(age)])             # letztes Element von age
[1] 21

> age[length(age) + 1]                      # Index > Länge des Vektors
[1] NA
\end{lstlisting}

\index{Vektor!unbenannt}
Ein Vektor muss nicht unbedingt einem Objekt zugewiesen werden, um indiziert werden zu können, dies ist auch für unbenannte Vektoren möglich.
\begin{lstlisting}
> c(11, 12, 13, 14)[2]
[1] 12
\end{lstlisting}

\index{Vektor!Indexvektor!numerisch}
\index{Indexvektor|see{Vektor}}
\index{indizieren|see{Datensatz, Matrix, Vektor}}
Mehrere Elemente eines Vektors lassen sich gleichzeitig abrufen, indem ihre Indizes in Form eines Indexvektors in die eckigen Klammern eingeschlossen werden. Dazu kann man zunächst einen eigenen Vektor erstellen, dessen Name dann in die eckigen Klammern geschrieben wird. Ebenfalls kann der Befehl zum Erzeugen eines Vektors direkt in die eckigen Klammern verschachtelt werden. Der Indexvektor kann auch länger als der indizierte Vektor sein, wenn einzelne Elemente mehrfach ausgegeben werden sollen. Das Weglassen eines Index mit \lstinline!<<Vektor>>[]! führt dazu, dass alle Elemente des Vektors ausgegeben werden.
\begin{lstlisting}
> idx <- c(1, 2, 4)                         # Indexvektor separat
> age[idx]
[1] 18 20 24

> age[c(3, 5, 6)]                           # Indexvektor im Operator
[1] 30 23 21

# Elemente mehrfach auswählen
> age[c(1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6)]
[1] 18 18 20 20 30 30 24 24 23 23 21 21
\end{lstlisting}

Beinhaltet der Indexvektor fehlende Werte (\lstinline!NA!), erzeugt dies in der Ausgabe ebenfalls einen fehlenden Wert an der entsprechenden Stelle.
\begin{lstlisting}
> age[c(4, NA, 1)]
[1] 25 NA 17
\end{lstlisting}

\index{Vektor!Elemente auslassen}
Wenn alle Elemente bis auf ein einzelnes abgerufen werden sollen, ist dies am einfachsten zu erreichen, indem der Index des nicht erwünschten Elements mit negativem Vorzeichen in die eckigen Klammern geschrieben wird.\footnote{Als Indizes dürfen in diesem Fall keine fehlenden Werte (\lstinline!NA!) oder Indizes mit positivem Vorzeichen vorkommen, ebenso darf der Indexvektor nicht leer sein.} Sollen mehrere Elemente nicht ausgegeben werden, verläuft der Aufruf analog zum Aufruf gewünschter Elemente, wobei mehrere Variationen mit dem negativen Vorzeichen möglich sind.
\begin{lstlisting}
> age[-3]             # alle Elemente bis auf das 3.
[1] 18 20 24 23 21

> age[c(-1, -2, -4)]  # alle Elemente bis auf das 1., 2. und 4.
[1] 30 23 21

> age[-c(1, 2, 4)]    # alle Elemente bis auf das 1., 2. und 4.
[1] 30 23 21

> age[-idx]           # alle Elemente bis auf die Indizes im Vektor idx
[1] 30 23 21
\end{lstlisting}

\index{Vektor!Elemente ändern}
Die in einem Vektor gespeicherten Werte können nachträglich verändert werden. Dazu muss der Position des zu ändernden Wertes der neue Wert zugewiesen werden.
\begin{lstlisting}
> age[4] <- 25        # speichere 25 an Position 4
> age
[1] 18 20 30 25 23 21
\end{lstlisting}

Das Verändern von mehreren Elementen gleichzeitig geschieht analog. Dazu lassen sich die Möglichkeiten zur Auswahl mehrerer Elementen nutzen und diesen in einem Arbeitsschritt neue Werte zuweisen. Dabei müssen die zugewiesenen Werte ebenfalls durch einen Vektor repräsentiert sein. Fehlt bei Zuweisungen der Index \lstinline!<<Vektor>>[]!, werden alle Elemente des Vektors ersetzt. Wenn der zugewiesene Vektor dabei weniger Elemente als der veränderte Vektor besitzt, wird er automatisch passend verlängert (Abschn.\ \ref{sec:recycling}).
\begin{lstlisting}
> age[idx] <- c(17, 30, 25)
> age
[1] 17 30 30 25 23 21

# alle Elemente gleichzeitig ersetzen mit zyklischer Verlängerung
> age[] <- c(1, 2)    # nicht verwechseln mit: age <- c(1, 2)
> age
[1] 1 2 1 2 1 2
\end{lstlisting}

\index{Vektor!verlängern}
Um Vektoren zu verlängern, also mit neuen Elementen zu ergänzen, kann zum einen der \lstinline![<<Index>>]! Operator benutzt werden, wobei als Index nicht belegte Positionen angegeben werden.\footnote{\label{ftn:vecAdd}Bei der Verarbeitung sehr großer Datenmengen ist zu bedenken, dass die schrittweise Vergrößerung von Objekten aufgrund der dafür notwendigen internen Kopiervorgänge ineffizient ist. Objekte sollten deshalb bevorzugt bereits mit der Größe und dem Datentyp angelegt werden, die sie später benötigen.} Zum anderen kann auch hier \lstinline!c(<<Wert1>>, <<Wert2>>, ...)! Verwendung finden. Als Alternative steht die \lstinline!append(<<Vektor>>, values=<<Vektor>>)!\index[func]{append()@\lstinline{append()}} Funktion zur Verfügung, die an einen Vektor die Werte eines unter \lstinline!values! genannten Vektors anhängt und den erweiterten Vektor zurückgibt.
\begin{lstlisting}
> charVec1 <- c("Z", "Y", "X")
> charVec1[c(4, 5, 6)] <- c("W", "V", "U")
> charVec1
[1] "Z" "Y" "X" "W" "V" "U"

> (charVec2 <- c(charVec1, "T", "S", "R"))
[1] "Z" "Y" "X" "W" "V" "U" "T" "S" "R"

> (charVec3 <- append(charVec2, c("Q", "P", "O")))
[1] "Z" "Y" "X" "W" "V" "U" "T" "S" "R" "Q" "P" "O"
\end{lstlisting}

Über die Option \lstinline!append(..., after=<<Index>>)! können neue Werte auch an beliebiger Stelle eingefügt werden, mit \lstinline!after=0! am Beginn des Vektors.
\begin{lstlisting}
> append(charVec1, c("A", "B", "C"), after=0)
[1] "A" "B" "C" "Z" "Y" "X" "W" "V" "U"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datentypen in Vektoren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Datentypen}
\index{Datentyp!mischen}
Vektoren können Werte unterschiedlicher Datentypen speichern, etwa \lstinline!numeric!, wenn sie Zahlen beinhalten, oder \lstinline!character! im Fall von Zeichenketten. Letztere müssen dabei immer in Anführungszeichen stehen. Jeder Vektor kann aber nur einen Datentyp besitzen, alle seine Elemente haben also denselben Datentyp. Fügt man einem numerischen Vektor eine Zeichenkette hinzu, so werden seine numerischen Elemente automatisch in Zeichenketten umgewandelt,\footnote{Allgemein gesprochen werden alle Elemente in den umfassendsten Datentyp umgewandelt, der notwendig ist, um alle Werte ohne Informationsverlust zu speichern (Abschn.\ \ref{sec:dataTypes}).} was man an den hinzugekommenen Anführungszeichen erkennt und mit \lstinline!mode(<<Vektor>>)! überprüfen kann.
\begin{lstlisting}
> charVec4 <- "word"
> numVec   <- c(10, 20, 30)
> (combVec <- c(charVec4, numVec))
[1] "word" "10" "20" "30"

> mode(combVec)
[1] "character"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elemente benennen}
\label{sec:valNames}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Elemente benennen}
Es ist möglich, die Elemente eines Vektors beim Erstellen zu benennen. Die Elemente können dann nicht nur über ihren Index, sondern auch über ihren in Anführungszeichen gesetzten Namen angesprochen werden.\footnote{Namen werden als Attribut gespeichert und sind mit \lstinline!attributes(<<Vektor>>)! sichtbar (Abschn.\ \ref{sec:objects}). Elemente lassen sich über den Namen nur auswählen, nicht aber mittels \lstinline!<<Vektor>>[-"<<Name>>"]! ausschließen, hierfür bedarf es des numerischen Index.} In der Ausgabe wird der Name eines Elements in der über ihm stehenden Zeile mit aufgeführt. \index[func]{names()@\lstinline{names()}|textbf} \lstinline!names(<<Vektor>>)! gibt die Namen der Elemente eines Vektors aus.
\begin{lstlisting}
> (namedVec1 <- c(elem1="first", elem2="second"))
elem1    elem2
"first"  "second"

> namedVec1["elem1"]
elem1
"first"

> names(namedVec1)
[1] "elem1"  "elem2"
\end{lstlisting}

Auch im nachhinein lassen sich Elemente benennen, bzw.\ vorhandene Benennungen ändern, etwa mit der Funktion\index[func]{setNames()@\lstinline{setNames()}} \lstinline!setNames(<<Vektor>>, c("<<Name1>>", ...))!. Sie setzt die Namen der Elemente des übergebenen Vektors auf die Zeichenketten, die als zweites Argument in Form eines Vektors genannt sind. Die Funktion verändert den als erstes Argument übergebenen Vektor selbst nicht, sondern liefert einen modifizierten Vektor zurück.
\begin{lstlisting}
> (namedVec2 <- c(val1=10, val2=-12, val3=33))
val1  val2  val3
  10   -12    33

> (names2 <- names(namedVec2))                           # alte Namen
[1] "val1" "val2" "val3"

> (namedVec3 <- setNames(namedVec2, toupper(names2)))    # neue Namen
VAL1  VAL2  VAL3
  10   -12    33
\end{lstlisting}

Ganz entfernt werden die Namen der Elemente mit \index[func]{unname()@\lstinline{unname()}} \lstinline!unname(<<Vektor>>)!.
\begin{lstlisting}
> unname(namedVec3)
[1]  10  -12  33
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elemente löschen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Elemente löschen}
Elemente eines Vektors lassen sich nicht im eigentlichen Sinne löschen. Denselben Effekt kann man stattdessen über zwei mögliche Umwege erzielen. Zum einen kann ein bestehender Vektor mit einer Auswahl seiner eigenen Elemente überschrieben werden.
\begin{lstlisting}
> vec <- c(10, 20, 30, 40, 50)
> vec <- vec[-c(4, 5)]
> vec
[1] 10 20 30
\end{lstlisting}

\index{Vektor!verkürzen}
Zum anderen kann ein bestehender Vektor über \lstinline!length()! verkürzt werden, indem ihm eine Länge zugewiesen wird, die kleiner als seine bestehende ist. Gelöscht werden dabei die überzähligen Elemente am Ende des Vektors.
\begin{lstlisting}
> vec         <- c(1, 2, 3, 4, 5)
> length(vec) <- 3
> vec
[1] 1 2 3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Logische Operatoren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Verarbeitungsschritte mit logischen Vergleichen und Werten treten häufig bei der Auswahl von Teilmengen von Daten sowie bei der Recodierung von Datenwerten auf. Dies liegt vor allem an der Möglichkeit, in Vektoren und anderen Datenstrukturen gespeicherte Werte auch mit logischen Indexvektoren auszuwählen (Abschn.\ \ref{sec:which}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vektoren mit logischen Operatoren vergleichen}
\label{sec:compare_vec_logical}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Vergleiche}
\index{Vektor!Bedingungen prüfen}
Vektoren werden oft mit Hilfe logischer Operatoren mit einem bestimmten Wert, oder auch mit anderen Vektoren verglichen um zu prüfen, ob die Elemente gewisse Bedingungen erfüllen. Als Ergebnis der Prüfung wird ein logischer Vektor mit Wahrheitswerten ausgegeben, der die Resultate der elementweisen Anwendung des Operators beinhaltet.

Als Beispiel seien im Vektor \lstinline!age! wieder die Daten von sechs Personen gespeichert. Zunächst sollen jene Personen identifiziert werden, die jünger als $24$ Jahre sind. Dazu wird der \lstinline!<! Operator verwendet, der als Ergebnis einen Vektor mit Wahrheitswerten liefert, der für jedes Element separat angibt, ob die Bedingung $< 24$ zutrifft. Andere Vergleichsoperatoren, wie gleich (\lstinline!==!) oder ungleich (\lstinline|!=|) funktionieren analog.
\begin{lstlisting}
> age <- c(17, 30, 30, 24, 23, 21)
> age < 24
[1] TRUE FALSE FALSE FALSE TRUE TRUE
\end{lstlisting}

Wenn zwei Vektoren miteinander logisch verglichen werden, wird der Operator immer auf ein zueinander gehörendes Wertepaar angewendet, also auf Werte, die sich an derselben Position in ihrem jeweiligen Vektor befinden.
\begin{lstlisting}
> x <- c(2, 4, 8)
> y <- c(3, 4, 5)
> x == y
[1] FALSE TRUE FALSE

> x < y
[1] TRUE FALSE FALSE
\end{lstlisting}

Auch die Prüfung jedes Elements auf mehrere Kriterien ist möglich. Wenn zwei Kriterien gleichzeitig erfüllt sein sollen, wird \lstinline!&!\index[func]{&@\lstinline{&, &&}} als Symbol für das logische UND\index{UND} verwendet. Wenn nur eines von zwei Kriterien erfüllt sein muss, ist das\index[func]{\textbar@\texttt{\textbar, \textbar\textbar}} Symbol \lstinline!|! für das\index{ODER} logische, d.\,h.\ einschließende, ODER zu verwenden. Um sicherzustellen, dass R die zusammengehörenden Ausdrücke auch als Einheit erkennt, ist die Verwendung runder Klammern zu empfehlen.
\begin{lstlisting}
> (age <= 20) | (age >= 30)     # Werte im Bereich bis 20 ODER ab 30?
[1] TRUE TRUE TRUE FALSE FALSE FALSE

> (age > 20) & (age < 30)       # Werte im Bereich zwischen 20 und 30?
[1] FALSE FALSE FALSE TRUE TRUE TRUE
\end{lstlisting}

UND und ODER dürfen bei zusammengesetzten Prüfungen nicht weggelassen werden: Während man mathematisch also eine Bedingung etwa als $0 \leq x \leq 10$ formulieren würde, müsste sie in R in Form von mit UND verbundenen Einzelprüfungen geschrieben werden, also wie oben als \lstinline!(0 <= x) & (x <= 10)!.

Die elementweise Prüfung von Vektoren macht den häufigsten Fall der Anwendung logischer Kriterien aus. Vor allem zur Fallunterscheidung (Abschn.\ \ref{sec:ifElseSwitch}) sind aber auch Prüfungen notwendig, die in Form eines einzelnen Wahrheitswertes eine summarische Auskunft darüber liefern, ob Kriterien erfüllt sind. Diese Prüfungen lassen sich mit \lstinline!&&!\index[func]{&@\lstinline{&, &&}} für das logische\index{UND} UND bzw.\ mit\index[func]{\textbar@\texttt{\textbar, \textbar\textbar}} \lstinline!||! für das logische\index{ODER} ODER formulieren. Zu beiden Seiten des Operators darf dabei jedoch nur ein einzelner Wert stehen.
\begin{lstlisting}
> TRUE && TRUE
[1] TRUE

> FALSE || FALSE
[1] FALSE
\end{lstlisting}

\lstinline!identical()! prüft zwei übergebene Vektoren summarisch auf Gleichheit und gibt nur dann das Ergebnis \lstinline!TRUE! aus, wenn diese auch bzgl.\ ihrer internen Repräsentation exakt identisch sind (Abschn.\ \ref{sec:isTRUE}).
\begin{lstlisting}
> c(1, 2) == c(1L, 2L)
[1] TRUE TRUE

> identical(c(1, 2), c(1L, 2L))
[1] FALSE
\end{lstlisting}

Sollen Werte nur auf ungefähre Übereinstimmung geprüft werden, kann dies mit \lstinline!all.equal()!\index[func]{all.equal()@\lstinline{all.equal()}} geschehen (Abschn.\ \ref{sec:isTRUE}). Dabei ist im Fall von zu vergleichenden Vektoren zu beachten, dass die Funktion keinen Vektor der Ergebnisse der elementweisen Einzelvergleiche ausgibt. Stattdessen liefert sie nur einen einzelnen Wert zurück, entweder \lstinline!TRUE! im Fall der paarweisen Übereinstimmung aller Elemente oder das mittlere Abweichungsmaß im Fall der Ungleichheit. Um auch in letzterem Fall einen Wahrheitswert als Ausgabe zu erhalten, sollte \lstinline!isTRUE()!\index[func]{isTRUE()@\lstinline{isTRUE()}} verwendet werden.
\begin{lstlisting}
> x <- c(4, 5, 6)
> y <- c(4, 5, 6)
> z <- c(1, 2, 3)
> all.equal(x, y)
[1] TRUE

> all.equal(y, z)
[1] "Mean relative difference: 0.6"

> isTRUE(all.equal(y, z))
[1] FALSE
\end{lstlisting}

Bei der Prüfung von Elementen auf Kriterien kann mit Hilfe spezialisierter Funktionen summarisch analysiert werden, ob diese Kriterien zutreffen. Ob mindestens ein Element eines logischen Vektors den Wert \lstinline!TRUE! besitzt, zeigt\index[func]{any()@\lstinline{any()}} \lstinline!any(<<Vektor>>)!, ob alle Elemente den Wert \lstinline!TRUE! haben, gibt\index[func]{all()@\lstinline{all()}} \lstinline!all(<<Vektor>>)! an.\footnote{Dabei erzeugt \lstinline!all(numeric(0))! das Ergebnis \lstinline!TRUE!, da die Aussage {\quotedblbase}alle Elemente des leeren Vektors sind WAHR{\textquotedblleft} logisch WAHR ist -- schließlich lässt sich kein Gegenbeispiel in Form eines Elements finden, das FALSCH wäre. Dagegen erzeugt \lstinline!any(numeric(0))! das Ergebnis \lstinline!FALSE!, da in einem leeren Vektor nicht mindestens ein Element existiert, das WAHR ist.}
\begin{lstlisting}
> res <- age > 30
> any(res)
[1] FALSE

> any(age < 18)
[1] TRUE

> all(x == y)
[1] TRUE
\end{lstlisting}

\index{Vektor!Fälle zählen}
Um zu zählen, auf wie viele Elemente eines Vektors ein Kriterium zutrifft, wird auf einen logischen Vektor die Funktion \lstinline!sum(<<Vektor>>)! angewendet, die alle Werte des Vektors aufaddiert (Abschn.\ \ref{sec:sum}).
\begin{lstlisting}
> res <- age < 24
> sum(res)                    # TRUE zählt als 1, FALSE als 0
[1] 3
\end{lstlisting}

Alternativ kann verschachtelt in \lstinline!length()! die Funktion \lstinline!which(<<Vektor>>)! genutzt werden, die die Indizes der Elemente mit dem Wert \lstinline!TRUE! ausgibt (Abschn.\ \ref{sec:which}).
\begin{lstlisting}
> which(age < 24)
[1] 1 5 6

> length(which(age < 24))
[1] 3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Logische Indexvektoren}
\label{sec:which}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Indexvektor!logisch}
Vektoren von Wahrheitswerten können wie numerische Indexvektoren zur Indizierung anderer Vektoren benutzt werden. Diese Art zu indizieren kann z.\,B.\ zur Auswahl von Teilstichproben genutzt werden, die durch bestimmte Merkmale definiert sind. Hat ein Element des logischen Indexvektors den Wert \lstinline!TRUE!, so wird das sich an dieser Position befindliche Element des indizierten Vektors ausgegeben. Hat der logische Indexvektor an einer Stelle den Wert \lstinline!FALSE!, so wird das zugehörige Element des indizierten Vektors ausgelassen.
\begin{lstlisting}
> age[c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE)]
[1] 17 30 24 21
\end{lstlisting}

Wie numerische können auch logische Indizes zunächst in einem Vektor gespeichert werden, mit dem die Indizierung dann später geschieht. Statt der Erstellung eines separaten logischen Indexvektors, z.\,B.\ als Ergebnis einer Überprüfung von Bedingungen, kann der Schritt aber auch übersprungen und der logische Ausdruck direkt innerhalb des \lstinline![<<Index>>]! Operators benutzt werden. Dabei ist jedoch abzuwägen, ob der Übersichtlichkeit und Nachvollziehbarkeit der Befehle mit einer separaten Erstellung von Indexvektoren besser gedient ist.
\begin{lstlisting}
> (idx <- (age <= 20) | (age >= 30))  # Wertebereich bis 20 ODER ab 30?
[1] TRUE TRUE TRUE FALSE FALSE FALSE

> age[idx]
[1] 17 30 30

> age[(age <= 20) | (age >= 30)]
[1] 17 30 30
\end{lstlisting}

Bei logischen Indexvektoren kann anders als bei numerischen Indexvektoren die von R automatisch vorgenommene zyklische Verlängerung greifen (Abschn.\ \ref{sec:recycling}): Logische Indexvektoren mit weniger Elementen als jene des indizierten Vektors werden durch zyklische Wiederholung soweit verlängert, dass sie mindestens die Länge des indizierten Vektors erreichen.
\begin{lstlisting}
> age[c(TRUE, FALSE)]         # logischer Indexvektor kürzer als age
[1] 18 30 23

# durch zyklische Verlängerung von c(TRUE, FALSE) äquivalent zu
> age[c(TRUE,FALSE, TRUE,FALSE, TRUE,FALSE)]
[1] 18 30 23
\end{lstlisting}

\index{Daten!fehlende Werte!Indexvektor}
Logische Indexvektoren bergen den Nachteil, dass sie zu Problemen führen können, wenn der zu prüfende Vektor fehlende Werte enthält. Überall dort, wo dieser \lstinline!NA! ist, wird i.\,d.\,R.\ auch das Ergebnis eines logischen Vergleichs \lstinline!NA! sein, d.\,h.\ der resultierende logische Indexvektor enthält seinerseits fehlende Werte (Abschn.\ \ref{sec:treatNA}, Fußnote \ref{ftn:whenNA}).
\begin{lstlisting}
> vecNA <- c(-3, 2, 0, NA, -7, 5)       # Vektor mit fehlendem Wert
> (ok   <- vecNA > 0)                   # prüfe auf Werte größer 0
[1] FALSE TRUE FALSE NA FALSE TRUE
\end{lstlisting}

Enthält ein Indexvektor einen fehlenden Wert, erzeugt er beim Indizieren eines anderen Vektors an dieser Stelle ebenfalls ein \lstinline!NA! in der Ausgabe (Abschn.\ \ref{sec:vecSel}). Dies führt dazu, dass sich der Indexvektor nicht mehr dazu eignet, ausschließlich die Werte auszugeben, die eine bestimmte Bedingung erfüllen. Fehlende Werte im logischen Indexvektor können mit \lstinline!is.na()! (Abschn.\ \ref{sec:isna}) identifiziert und dann logisch ausgeschlossen werden.
\begin{lstlisting}
> vecNA[ok]                             # Auswahl mit ok erzeugt NA
[1] 2 NA 5

> vecNA[ok & !is.na(ok)])               # entferne NA im Indexvektor
[1] 2 5
\end{lstlisting}

\index{Vektor!Indexvektor!numerisch}
Logische Indizes in numerische Indizes wandelt die Funktion \lstinline!which(<<Vektor>>)!\index[func]{which()@\lstinline{which()}|textbf} um. Sie gibt also die Positionen der \lstinline!TRUE! Werte zurück.\footnote{Umgekehrt lassen sich auch die in \lstinline!<<Indexvektor>>! gespeicherten numerischen Indizes für \lstinline!<<Vektor>>! in logische verwandeln: \lstinline!seq_along(<<Vektor>>) \%in\% <<Indexvektor>>! (Abschn.\ \ref{sec:setOps}, \ref{sec:seq}).}
\begin{lstlisting}
> (numIdx <- which(ok))          # numerische Indizes der TRUE Werte
[1] 2 6
\end{lstlisting}

Numerische Indexvektoren sind dann zu vermeiden, wenn Werte explizit ausgeschlossen werden sollen. Mit dem Vektor \lstinline!x! und einem logischen Indexvektor \lstinline!idx! kann anders als \lstinline|x[!idx]| die Variante \lstinline!x[-which(idx)]! unerwünschte Ergebnisse haben: Sind in \lstinline!idx! keine \lstinline!TRUE! Werte vorhanden, werden nicht alle Werte von \lstinline!x! ausgegeben, sondern gar keiner, weil dies dann gleichbedeutend zu \lstinline!x[integer(0)]! ist.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mengen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Mengen}
Werden Vektoren als Wertemengen im mathematischen Sinn betrachtet, ist zu beachten, dass die Elemente einer Menge nicht geordnet sind und mehrfach vorkommende Elemente wie ein einzelnes behandelt werden, so ist z.\,B.\ die Menge $\left\{1, 1, 2, 2\right\}$ gleich der Menge $\left\{2, 1\right\}$.\footnote{Das Paket \lstinline!sets!\index[pack]{sets@\lstinline{sets}} \cite{Meyer2009a} stellt eine eigene Klasse zur Repräsentation von Mengen zur Verfügung und implementiert auch einige hier nicht behandelte Mengenoperationen -- etwa das Bilden der Potenzmenge.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Doppelt auftretende Werte finden}
\label{sec:unique}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!doppelte Werte}
\lstinline!duplicated(<<Vektor>>)!\index[func]{duplicated()@\lstinline{duplicated()}} gibt für jedes Element eines Vektors an, ob der Wert bereits an einer früheren Stelle des Vektors aufgetaucht ist. Mit dem Argument \lstinline!fromLast=TRUE! beginnt die Suche nach wiederholt auftretenden Werten am Ende des Vektors.
\begin{lstlisting}
> x <- c(1, 2, 3, 1, 4, 5)
> duplicated(x)
[1] FALSE FALSE FALSE TRUE FALSE FALSE

> duplicated(x, fromLast=TRUE)            # umgekehrte Suchrichtung
[1] TRUE FALSE FALSE FALSE FALSE FALSE
\end{lstlisting}

Durch die Kombination beider Suchrichtungen lassen sich alle Duplikate identifizieren, insbesondere also auch das erste Auftreten eines mehrfach vorhandenen Wertes -- so umgesetzt in \index[func]{AllDuplicated()@\lstinline{AllDuplicated()}} \lstinline!AllDuplicated()! aus dem Paket\index[pack]{DescTools@\lstinline{DescTools}|textbf} \lstinline!DescTools! \cite{Signorell2014}.
\begin{lstlisting}
# markiere alle Stellen, an denen die 1 auftritt
> duplicated(x) | duplicated(x, fromLast=TRUE)
[1] TRUE FALSE FALSE TRUE FALSE FALSE
\end{lstlisting}

\lstinline!unique(<<Vektor>>)!\index[func]{unique()@\lstinline{unique()}} nennt alle voneinander verschiedenen Werte eines Vektors, mehrfach vorkommende Werte werden also nur einmal aufgeführt. Die Funktion eignet sich in Kombination mit \lstinline!length()! zum Zählen der tatsächlich vorkommenden unterschiedlichen Werte einer Variable.
\begin{lstlisting}
> unique(c(1, 1, 1, 3, 3, 4, 4))
[1] 1  3  4

> length(unique(c("A", "B", "C", "C", "B", "B", "A", "C", "C", "A")))
[1] 3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mengenoperationen}
\label{sec:setOps}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Mengen}
\lstinline!union(x=<<Vektor1>>, y=<<Vektor2>>)!\index[func]{union()@\lstinline{union()}} bildet die Vereinigungsmenge $x \cup y$. Das Ergebnis sind die Werte, die Element mindestens einer der beiden Mengen sind, wobei duplizierte Werte gelöscht werden. Wird das Ergebnis als Menge betrachtet, spielt es keine Rolle, in welcher Reihenfolge \lstinline!x! und \lstinline!y! genannt werden.
\begin{lstlisting}
> x <- c(2, 1, 3, 2, 1)
> y <- c(5, 3, 1, 3, 4, 4)
> union(x, y)
[1] 2 1 3 5 4

> union(y, x)
[1] 5 3 1 4 2
\end{lstlisting}

Die Schnittmenge $x \cap y$ zweier Mengen erzeugt\index[func]{intersect()@\lstinline{intersect()}} \lstinline!intersect(x=<<Vektor1>>, y=<<Vektor2>>)!. Das Ergebnis sind die Werte, die sowohl Element von \lstinline!x! als auch Element von \lstinline!y! sind, wobei duplizierte Werte gelöscht werden. Auch hier ist die Reihenfolge von \lstinline!x! und \lstinline!y! unerheblich, wenn das Ergebnis als Menge betrachtet wird.
\begin{lstlisting}
> intersect(x, y)
[1] 1 3

> intersect(y, x)
[1] 3 1
\end{lstlisting}

Mit\index[func]{setequal()@\lstinline{setequal()}} \lstinline!setequal(x=<<Vektor1>>, y=<<Vektor2>>)! lässt sich prüfen, ob als Mengen betrachtete Vektoren identisch sind.
\begin{lstlisting}
> setequal(c(1, 1, 2, 2), c(2, 1))
[1] TRUE
\end{lstlisting}

\lstinline!setdiff(x=<<Vektor1>>, y=<<Vektor2>>)!\index[func]{setdiff()@\lstinline{setdiff()}} liefert als Ergebnis all jene Elemente von \lstinline!x!, die nicht Element von \lstinline!y! sind. Im Unterschied zu den oben behandelten Mengenoperationen ist die Reihenfolge von \lstinline!x! und \lstinline!y! hier bedeutsam, auch wenn das Ergebnis als Menge betrachtet wird. Die symmetrische Differenz von \lstinline!x! und \lstinline!y! erhält man durch \lstinline!union(setdiff(x, y), setdiff(y, x))!.
\begin{lstlisting}
> setdiff(x, y)
[1] 2

> setdiff(y, x)
[1] 5 4
\end{lstlisting}

Soll jedes Element eines Vektors daraufhin geprüft werden, ob es Element einer Menge ist, kann\index[func]{is.element()@\lstinline{is.element()}} \lstinline!is.element(el=<<Vektor>>, set=<<Menge>>)! genutzt werden. Unter \lstinline!el! ist der Vektor mit den zu prüfenden Elementen einzutragen und unter \lstinline!set! die durch einen Vektor definierte Menge. Als Ergebnis wird ein logischer Vektor ausgegeben, der für jedes Element von \lstinline!el! angibt, ob es in \lstinline!set! enthalten ist. Die Kurzform in Operator-Schreibweise lautet\index[func]{\%in\%@\texttt{\%in\%}|textbf} \lstinline!<<Vektor>> %in% <<Menge>>!.
\begin{lstlisting}
> is.element(c(29, 23, 30, 17, 30, 10), c(30, 23))
[1] FALSE TRUE TRUE FALSE TRUE FALSE

> c("A", "Z", "B") %in% c("A", "B", "C", "D", "E")
[1] TRUE FALSE TRUE
\end{lstlisting}

Durch \lstinline!all(x %in% y)! lässt sich prüfen, ob \lstinline!x! eine Teilmenge von \lstinline!y! darstellt, ob also jedes Element von \lstinline!x! auch Element von \lstinline!y! ist. Dabei ist \lstinline!x! eine echte Teilmenge von \lstinline!y!, wenn sowohl \lstinline!all(x %in% y)! gleich \lstinline!TRUE! als auch \lstinline!all(y %in% x)! gleich \lstinline!FALSE! ist.
\begin{lstlisting}
> A <- c(4, 5, 6)
> B <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
> (AinB <- all(A %in% B))           # A Teilmenge von B?
[1] TRUE

> (BinA <- all(B %in% A))           # B Teilmenge von A?
[1] FALSE

> AinB && !BinA                     # A echte Teilmenge von B?
[1] TRUE
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kombinatorik}
\label{sec:combinatorics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Kombinatorik}
Aus dem Bereich der Kombinatorik sind bei der Datenauswertung drei Themen von Bedeutung: Zunächst ist dies die Bildung von Teilmengen aus Elementen einer Grundmenge. Dabei ist die Reihenfolge der Elemente innerhalb einer Teilmenge meist nicht bedeutsam, d.\,h.\ es handelt sich um eine \emph{Kombination}. Werden alle Elemente einer Grundmenge ohne Zurücklegen unter Beachtung der Reihenfolge gezogen, handelt es sich um eine vollständige\index{Permutation|see{Kombinatorik}} \emph{Permutation}. Schließlich kann die Zusammenstellung von Elementen aus verschiedenen Grundmengen notwendig sein, wobei jeweils ein Element aus jeder Grundmenge beteiligt sein soll.

Die Kombination entspricht dem Ziehen aus einer Grundmenge ohne Zurücklegen sowie ohne Berücksichtigung der Reihenfolge. Oft wird die Anzahl der Elemente der Grundmenge mit $n$, die Anzahl der gezogenen Elemente mit $k$ und die Kombination deshalb mit $k$-Kombination bezeichnet. Es gibt ${n \choose k} = \frac{n!}{k! (n-k)!}$ viele $k$-Kombinationen. Da eine $k$-Kombinationen die Anzahl der Möglichkeiten darstellt, aus einer Menge mit $n$ Elementen $k$ auszuwählen, spricht man im Englischen beim Binomialkoeffizienten ${n \choose k}$ von {\quotedblbase}$n$ choose $k${\textquotedblleft}. Daraus leitet sich der Name der \lstinline!choose(n=<<Zahl>>, k=<<Zahl>>)!\index[func]{choose()@\lstinline{choose()}} Funktion ab, die ${n \choose k}$ ermittelt. Die Fakultät einer Zahl wird mit \lstinline!factorial(<<Zahl>>)! berechnet (Abschn.\ \ref{sec:sum}).
\begin{lstlisting}
> myN <- 5
> myK <- 4
> choose(myN, myK)
[1] 5

> factorial(myN) / (factorial(myK)*factorial(myN-myK))    # Kontrolle
[1] 5
\end{lstlisting}

Möchte man alle $k$-Kombinationen einer gegebenen Grundmenge \lstinline!x! auch explizit anzeigen lassen, kann dies mit\index[func]{combn()@\lstinline{combn()}} \lstinline!combn()! geschehen.
\begin{lstlisting}
combn(x=<<Vektor>>, m=<<Zahl>>, simplify=TRUE, FUN=<<Funktion>>, ...)
\end{lstlisting}

Die Zahl \lstinline!m! entspricht dabei dem $k$ der bisherigen Terminologie. Mit \lstinline!simplify=TRUE! erfolgt die Ausgabe auf möglichst einfache Weise, d.\,h.\ nicht als Liste (Abschn.\ \ref{sec:list}). Stattdessen wird hier eine Matrix ausgegeben, die in jeder Spalte eine der $k$-Kombinationen enthält (Abschn.\ \ref{sec:matrix}).
\begin{lstlisting}
> combn(c("a", "b", "c", "d", "e"), myK)
     [,1]  [,2]  [,3]  [,4]  [,5]
[1,]  "a"   "a"   "a"   "a"   "b"
[2,]  "b"   "b"   "b"   "c"   "c"
[3,]  "c"   "c"   "d"   "d"   "d"
[4,]  "d"   "e"   "e"   "e"   "e"
\end{lstlisting}

\lstinline!combn()! lässt sich darüber hinaus anwenden, um in einem Arbeitsschritt eine frei wählbare Funktion auf jede gebildete $k$-Kombination anzuwenden. Das Argument \lstinline!FUN! erwartet hierfür eine Funktion, die einen Kennwert jedes sich als Kombination ergebenden Vektors bestimmt. Benötigt \lstinline!FUN! ihrerseits weitere Argumente, so können diese unter \lstinline!...! durch Komma getrennt an \lstinline!combn()! übergeben werden.
\begin{lstlisting}
> combn(c(1, 2, 3, 4), 3)           # alle 3-Kombinationen
     [,1]  [,2]  [,3]  [,4]
[1,]    1     1     1     2
[2,]    2     2     3     3
[3,]    3     4     4     4

# jeweilige Summe jeder 3-Kombination
> combn(c(1, 2, 3, 4), 3, FUN=sum)
[1] 6 7 8 9

# gewichtetes Mittel jeder 3-Kombination mit Argument w für Gewichte
> combn(c(1, 2, 3, 4), 3, weighted.mean, w=c(0.5, 0.2, 0.3))
[1] 1.8 2.1 2.3 2.8
\end{lstlisting}

\lstinline!Permn(<<Vektor>>)!\index[func]{Permn()@\lstinline{Permn()}} aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} stellt alle $n!$ Permutationen des übergebenen Vektors der Länge $n$ als Zeilen einer Matrix zusammen (Abschn.\ \ref{sec:matrix}). Für eine einzelne zufällige Permutation s.\ Abschn.\ \ref{sec:sample}.
\begin{lstlisting}
> library(DescTools)                # für Permn()
> Permn(1:3)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    3    2
[3,]    3    1    2
[4,]    3    2    1
[5,]    2    3    1
[6,]    2    1    3
\end{lstlisting}

\lstinline!expand.grid(<<Vektor1>>, <<Vektor2>>, ...)!\index[func]{expand.grid()@\lstinline{expand.grid()}} bildet das kartesische Produkt der jeweils in Form eines Vektors übergebenen Grundmengen. Dies sind alle Kombinationen der Elemente der Grundmengen, wobei jeweils ein Element aus jeder Grundmenge stammt und die Reihenfolge nicht berücksichtigt wird. Dies entspricht der Situation, dass aus den Stufen mehrerer Faktoren alle Kombinationen von Faktorstufen gebildet werden. Das Ergebnis von \lstinline!expand.grid()! ist ein Datensatz (Abschn.\ \ref{sec:dataframe}), bei dem jede Kombination in einer Zeile steht. Die zuerst genannte Variable variiert dabei am schnellsten über die Zeilen, die anderen entsprechend ihrer Position im Funktionsaufruf langsamer.
\begin{lstlisting}
> var1 <- c("control", "treatment")
> var2 <- c("f", "m")
> var3 <- c(1, 2)
> expand.grid(IV1=var1, IV2=var2, IV3=var3, stringsAsFactors=FALSE)
          IV1  IV2  IV3
1     control    f    1
2   treatment    f    1
3     control    m    1
4   treatment    m    1
5     control    f    2
6   treatment    f    2
7     control    m    2
8   treatment    m    2
\end{lstlisting}

\index[func]{stringsAsFactors@\lstinline{stringsAsFactors}}
Damit übergebene Vektoren von Zeichenketten automatisch zu Gruppierungsfaktoren (Klasse \lstinline!factor!, Abschn.\ \ref{sec:factor}) werden, ist das Argument \lstinline!stringsAsFactors=TRUE! zu setzen. Sollen auch numerische Werte zu Faktorstufen im versuchsplanerischen Sinn werden, muss die zugehörige Variable vorher in ein Objekt der Klasse \lstinline!factor! umgewandelt werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Systematische und zufällige Wertefolgen erzeugen}
\label{sec:gen_sequence}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ein häufig auftretender Arbeitsschritt in R ist die Erstellung von Zahlenfolgen nach vorgegebenen Regeln, wie etwa sequentielle Abfolgen von Zahlen oder Wiederholungen bestimmter Wertemuster.

\index{Zufallszahlen}
Aber auch Zufallszahlen und zufällige Reihenfolgen sind ein unverzichtbares Hilfsmittel der Datenauswertung, wobei ihnen insbesondere in der Planung von Analysen anhand simulierter Daten eine große Bedeutung zukommt.\footnote{\label{ftn:random_num}Wenn hier und im Folgenden von Zufallszahlen die Rede ist, sind immer \emph{Pseudozufallszahlen} gemeint. Diese kommen nicht im eigentlichen Sinn zufällig zustande, sind aber von tatsächlich zufälligen Zahlenfolgen fast nicht zu unterscheiden. Pseudozufallszahlen hängen deterministisch vom Zustand des die Zahlen produzierenden\index{Zufallszahlen} Generators ab. Wird sein Zustand über\index[func]{set.seed()@\lstinline{set.seed()}} \lstinline!set.seed(<<Zahl>>)! festgelegt, kommt bei gleicher \lstinline!<<Zahl>>! bei späteren Aufrufen von Zufallsfunktionen immer dieselbe Folge von Werten zustande. Dies gewährleistet die Reproduzierbarkeit von Auswertungsschritten bei Simulationen (Abschn.\ \ref{sec:reproducibility}). Nach welcher Methode Zufallszahlen generiert werden, ist konfigurierbar und kann auch von der R Version abhängen, s.\ \lstinline!?Random!.} Zufällige Datensätze können unter Einhaltung vorgegebener Wertebereiche und anderer Randbedingungen erstellt werden. So können sie empirische Gegebenheiten realistisch widerspiegeln und statistische Voraussetzungen der eingesetzten Verfahren berücksichtigen. Aber auch bei der zufälligen Auswahl von Teilstichproben eines Datensatzes oder beim Erstellen zufälliger Reihenfolgen zur Zuordnung von Beobachtungsobjekten auf experimentelle Bedingungen kommen Zufallszahlen zum Einsatz.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Numerische Sequenzen erstellen}
\label{sec:seq}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zahlen!Zahlenfolgen erstellen}
Zahlenfolgen mit Einerschritten, etwa für eine fortlaufende Numerierung, können mit Hilfe des Operators \lstinline!<<Startwert>>:<<Endwert>>!\index[func]{:@\lstinline{:}} erzeugt werden -- in aufsteigender wie auch in absteigender Reihenfolge. Bei Dezimalzahlen wird der Endwert nicht überschritten und die Zahlenfolge ggf.\ vorher beendet.
\begin{lstlisting}
> 20:26
[1] 20 21 22 23 24 25 26

> 5.4:2.1              # Endwert 2.1 wird  nicht erreicht
[1] 5.4 4.4 3.4 2.4
\end{lstlisting}

Bei Zahlenfolgen im negativen Bereich sollten Klammern Verwendung finden, um nicht versehentlich eine nicht gemeinte Sequenz zu produzieren.
\begin{lstlisting}
> -4:2          # negatives Vorzeichen bezieht sich nur auf die 4
[1] -4 -3 -2 -1 0 1 2

> -(4:2)        # negatives Vorzeichen bezieht sich auf Sequenz 4:2
[1] -4 -3 -2
\end{lstlisting}

\lstinline!seq_len(<<Anzahl>>)!\index[func]{seq_len()@\lstinline{seq_len()}} erzeugt die häufig nützliche, bei 1 beginnende Zahlenfolge in Einerschritten mit einer definierten Anzahl von Werten. Die Funktion ist in Situationen hilfreich, in denen sich die Länge der Sequenz erst aus einer Variable ergibt und auch 0 sein kann. In diesem Fall würde die Alternative \lstinline!1:<<Anzahl>>!, also \lstinline!1:0! nicht das gewünschte Ergebnis liefern.
\begin{lstlisting}
> seq_len(4)
[1] 1 2 3 4

> target_length <- 0        # erwünschte Länge der Sequenz
> seq_len(target_length)    # gemeintes Ergebnis: leerer Vektor
integer(0)

> 1:target_length           # hier unerwünschtes Ergebnis: Sequenz 1:0
[1] 1 0 
\end{lstlisting}

\index[func]{seq()@\lstinline{seq()}}
Zahlenfolgen mit beliebiger Schrittweite lassen sich mit \lstinline!seq()! erzeugen.
\begin{lstlisting}
seq(from=<<Zahl>>, to=<<Zahl>>, by=<<Schrittweite>>, length.out=<<Länge>>)
\end{lstlisting}

Dabei können Start- (\lstinline!from!) und Endwert (\lstinline!to!) des durch die Sequenz abzudeckenden Intervalls ebenso gewählt werden wie die gewünschte Schrittweite (\lstinline!by!) bzw.\ stattdessen die gewünschte Anzahl der Elemente der Zahlenfolge (\lstinline!length.out!). Die Sequenz endet vor \lstinline!to!, wenn die Schrittweite kein ganzzahliges Vielfaches der Differenz von Start- und Endwert ist.
\begin{lstlisting}
> seq(from=2, to=12, by=2)
[1] 2 4 6 8 10 12

> seq(from=2, to=11, by=2)          # Endpunkt 11 wird nicht erreicht
[1] 2 4 6 8 10

> seq(from=0, to=-1, length.out=5)
[1] 0.00 -0.25 -0.50 -0.75 -1.00
\end{lstlisting}

Eine Möglichkeit zum Erstellen einer bei $1$ beginnenden Sequenz in Einerschritten, die genauso lang ist wie ein bereits vorhandener Vektor, besteht mit\index[func]{seq_along()@\lstinline{seq_along()}} \lstinline!seq_along(<<Vektor>>)!. Dies ist die bevorzugte Art, um für einen vorhandenen Vektor den passenden Vektor seiner Indizes zu erstellen. Vermieden werden sollte dagegen die \lstinline!1:length(<<Vektor>>)! Sequenz, deren Behandlung von Vektoren der Länge $0$ nicht sinnvoll ist.
\begin{lstlisting}
> age <- c(18, 20, 30, 24, 23, 21)
> seq_along(age)
[1] 1 2 3 4 5 6

> vec <- numeric(0)         # leeren Vektor (Länge 0) erzeugen
> 1:length(vec)             # hier unerwünschtes Ergebnis: Sequenz 1:0
[1] 1 0

> seq_along(vec)            # sinnvolleres Ergebnis: leerer Vektor
[1] integer(0)
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Wertefolgen wiederholen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!wiederholen}
\index[func]{rep()@\lstinline{rep()}}
Eine andere Art von Wertefolgen kann mit der \lstinline!rep()! Funktion (\emph{repeat}) erzeugt werden, die Elemente wiederholt ausgibt.
\begin{lstlisting}
rep(x=<<Vektor>>, times=<<Anzahl>>, each=<<Anzahl>>)
\end{lstlisting}

Für \lstinline!x! ist ein Vektor einzutragen, der auf zwei verschiedene Arten wiederholt werden kann.\footnote{Auch komplexe Objekte lassen sich mit \lstinline!rep()! duplizieren, wenn sie mit \lstinline!list(<<Objekt>>)! als Komponente einer Liste übergeben werden (Abschn.\ \ref{sec:list}). Ein Datensatz (Abschn.\ \ref{sec:dataframe}) könnte etwa mit \lstinline!rep(list(data.frame(A=1:2, B=c("Z", "Q"))), 3)! dupliziert werden. Die drei Duplikate sind im Ergebnis Kompenten einer Liste.} Eine für das Argument \lstinline!times! genannte natürliche Zahl bestimmt, wie oft \lstinline!x! als Ganzes aneinander gehängt wird.
\begin{lstlisting}
> rep(1:3, times=5)
[1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
\end{lstlisting}

Wird für das Argument \lstinline!times! ein Vektor angegeben, so muss dieser dieselbe Länge wie \lstinline!x! besitzen -- hier wird ein kürzerer Vektor durch R nicht selbsttätig zyklisch wiederholt (Abschn.\ \ref{sec:recycling}). Jedes Element des Vektors \lstinline!times! gibt an, wie häufig das an gleicher Position stehende Element von \lstinline!x! wiederholt werden soll, ehe das nächste Element von \lstinline!x! wiederholt und angehängt wird.
\begin{lstlisting}
> rep(c("A", "B", "C"), times=c(2, 3, 4))
[1] "A" "A" "B" "B" "B" "C" "C" "C" "C"
\end{lstlisting}

Wird das Argument \lstinline!each! verwendet, wird jedes Element von \lstinline!x! einzeln mit der gewünschten Häufigkeit wiederholt, bevor das nächste Element von \lstinline!x! einzeln wiederholt und angehängt wird.
\begin{lstlisting}
> rep(age, each=2)
[1] 18 18 20 20 30 30 24 24 23 23 21 21
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zufällig aus einer Urne ziehen}
\label{sec:sample}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zufallszahlen}
\index[func]{sample()@\lstinline{sample()}}
Die Funktion \lstinline!sample()! erstellt einen aus zufälligen Werten bestehenden Vektor, indem sie das Ziehen aus einer Urne simuliert.
\begin{lstlisting}
sample(x=<<Vektor>>, size=<<Anzahl>>, replace=FALSE, prob=NULL)
\end{lstlisting}

Für \lstinline!x! ist ein Vektor zu nennen, der die Elemente der Urne festlegt, aus der gezogen wird. Dies sind die Werte, aus denen sich die Zufallsfolge zusammensetzt. Es können Vektoren vom Datentyp \lstinline!numeric! (etwa \lstinline!1:50!), \lstinline!character! (\lstinline!c("Kopf", "Zahl")!) oder auch \lstinline!logical! (\lstinline!c(TRUE, FALSE)!) verwendet werden. Unter \lstinline!size! ist die gewünschte Anzahl der zu ziehenden Elemente einzutragen. Mit dem Argument \lstinline!replace! wird die Art des Ziehens festgelegt: Auf \lstinline!FALSE! gesetzt (Voreinstellung) wird ohne, andernfalls (\lstinline!TRUE!) mit Zurücklegen gezogen. Ohne Zurücklegen kann aus einem Vektor der Länge $n$ nicht häufiger als $n$ mal gezogen werden. Wenn \lstinline!replace=FALSE! und dennoch \lstinline!size! größer als \lstinline!length(x)! ist, erzeugt R deswegen eine Fehlermeldung. Für den Fall, dass nicht alle Elemente der Urne dieselbe Auftretenswahrscheinlichkeit besitzen sollen, existiert das Argument \lstinline!prob!. Es benötigt einen Vektor derselben Länge wie \lstinline!x!, dessen Elemente die Auftretenswahrscheinlichkeit für jedes Element von \lstinline!x! bestimmen.
\begin{lstlisting}
> sample(1:6, size=20, replace=TRUE)
[1] 4 1 2 5 6 5 3 6 6 5 1 6 1 5 1 4 5 4 4 2

> sample(c("rot", "grün", "blau"), size=8, replace=TRUE)
[1] "grün" "blau" "grün" "rot" "rot" "blau" "grün" "blau"
\end{lstlisting}

Für \lstinline!sample()! existieren zwei Kurzformen, auf die jedoch aufgrund der Gefahr von Verwechslungen besser verzichtet werden sollte: \lstinline!sample(<<Vektor>>)! ist gleichbedeutend mit \lstinline!sample(<<Vektor>>, size=length(<<Vektor>>), replace=FALSE)!, erstellt also eine zufällige Permutation der Elemente von \lstinline!<<Vektor>>! (Abschn.\ \ref{sec:combinatorics}). Darauf aufbauend steht bei einer natürlichen Zahl als einzigem Argument \lstinline!sample(<<Zahl>>)! kurz für \lstinline!sample(1:<<Zahl>>, size=<<Zahl>>, replace=FALSE)!.

Wenn für \lstinline!sample(<<Vektor>>)! ein Objektname übergeben wird, steht oft vor der Ausführung nicht fest, wie viele Elemente er beinhalten wird. Enthält \lstinline!<<Vektor>>! z.\,B.\ durch die Auswahl einer Teilmenge unvorhergesehen als einziges Element eine Zahl, wird die Urne durch Elemente definiert, die womöglich nicht im ursprünglichen Vektor vorhanden waren.
\begin{lstlisting}
> x <- c(2, 4, 6, 8)
> sample(x[(x %% 4) == 0])  # äquivalent zu sample(c(4, 8))
[1] 8 4

# Urne mit Elementen, die nicht aus x stammen
> sample(x[(x %% 8) == 0])  # äquivalent zu sample(8), d.h. sample(1:8)
[1] 2 1 7 5 4 8 6 3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zufallszahlen aus bestimmten Verteilungen erzeugen}
\label{sec:randNum}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zufallszahlen}
Abgesehen vom zufälligen Ziehen aus einer vorgegebenen Menge endlich vieler Werte lassen sich auch Zufallszahlen mit bestimmten Eigenschaften generieren. Dazu können mit Funktionen, deren Name nach dem Muster \lstinline!r<<Funktionsfamilie>>! aufgebaut ist, Realisierungen von Zufallsvariablen mit verschiedenen Verteilungen erstellt werden (Abschn.\ \ref{sec:randVarFuncs}). Diese Möglichkeit ist insbesondere für die Simulation empirischer Daten nützlich.
\index[func]{runif()@\lstinline{runif()}}
\index[func]{rbinom()@\lstinline{rbinom()}}
\index[func]{rnorm()@\lstinline{rnorm()}}
\index[func]{rchisq()@\lstinline{rchisq()}}
\index[func]{rt()@\lstinline{rt()}}
\index[func]{rf()@\lstinline{rf()}}
\index{Gleichverteilung|see{Verteilung}}
\index{Binomialverteilung|see{Verteilung}}
\index{Normalverteilung|see{Verteilung}}
\index{t-Verteilung@$t$-Verteilung|see{Verteilung}}
\index{Chi2-Verteilung@$\chi^{2}$-Verteilung|see{Verteilung}}
\index{F-Verteilung@$F$-Verteilung|see{Verteilung}}
\index{Verteilung!Gleichverteilung}
\index{Verteilung!Binomialverteilung}
\index{Verteilung!Normalverteilung}
\index{Verteilung!$t$-Verteilung}
\index{Verteilung!$\chi^{2}$-Verteilung}
\index{Verteilung!$F$-Verteilung}
\begin{lstlisting}
 runif(n=<<Anzahl>>, min=0, max=1)                # Gleichverteilung
rbinom(n=<<Anzahl>>, size, prob)                  # Binomialverteilung
 rnorm(n=<<Anzahl>>, mean=0, sd=1)                # Normalverteilung
rchisq(n=<<Anzahl>>, df,       ncp=0)             # chi^2-Verteilung
    rt(n=<<Anzahl>>, df,       ncp=0)             # t-Verteilung
    rf(n=<<Anzahl>>, df1, df2, ncp=0)             # F-Verteilung
\end{lstlisting}

Als erstes Argument \lstinline!n! ist immer die gewünschte Anzahl an Zufallszahlen anzugeben. Bei \lstinline!runif()! definiert \lstinline!min! die untere und \lstinline!max! die obere Grenze des Zahlenbereichs, aus dem gezogen wird. Beide Argumente akzeptieren auch Vektoren der Länge $n$, die für jede einzelne Zufallszahl den jeweils zulässigen Wertebereich angeben.

Bei \lstinline!rbinom()! entsteht jede der $n$ Zufallszahlen als Anzahl der Treffer in einer simulierten Serie von gleichen Bernoulli-Experimenten, die ihrerseits durch die Argumente \lstinline!size! und \lstinline!prob! charakterisiert ist. \lstinline!size! gibt an, wie häufig ein einzelnes Bernoulli-Experiment wiederholt werden soll, \lstinline!prob! legt die Trefferwahrscheinlichkeit in jedem dieser Experimente fest. Sowohl \lstinline!size! als auch \lstinline!prob! können Vektoren der Länge $n$ sein, die dann die Bernoulli-Experimente charakterisieren, deren Simulation zu jeweils einer Zufallszahl führt.

Bei \lstinline!rnorm()! sind der Erwartungswert \lstinline!mean! und die theoretische Streuung \lstinline!sd! der normalverteilten Variable anzugeben, die simuliert werden soll.\footnote{Der die Breite (Dispersion) einer Normalverteilung charakterisierende Parameter ist hier die Streuung $\sigma$, in der Literatur dagegen häufig die Varianz $\sigma^{2}$.} Auch diese Argumente können Vektoren der Länge $n$ sein und für jede Zufallszahl andere Parameter vorgeben.

Sind Verteilungen über Freiheitsgrade und Nonzentralitätsparameter charakterisiert, werden diese mit den Argumenten \lstinline!df! (\emph{degrees of freedom}) respektive \lstinline!ncp! (\emph{non-centrality parameter}) ggf.\ in Form von Vektoren übergeben.
\begin{lstlisting}
> runif(5, min=1, max=6)
[1] 4.411716 3.893652 2.412720 5.676668 2.446302

> rbinom(20, size=5, prob=0.3)
[1] 2 0 3 0 2 2 1 0 1 0 2 1 1 4 2 2 1 1 3 3

# ziehe aus N(0, sd=1), N(50, sd=5), N(100, sd=10)
> rnorm(3, mean=c(0, 50, 100), sd=c(1, 5, 10))
[1] -2.980886  45.288597 106.080166
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Daten transformieren}
\label{sec:varTransform}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Häufig sind für spätere Auswertungen neue Variablen auf Basis der erhobenen Daten zu bilden. Im Rahmen solcher Datentransformationen können etwa Werte sortiert, umskaliert, ersetzt oder ausgewählt werden. Genauso ist es möglich, verschiedene Variablen zu einer neuen zu verrechnen und kontinuierliche Variablen in Kategorien einzuteilen oder in Rangwerte umzuwandeln.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Werte sortieren}
\label{sec:revSortOrder}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Reihenfolge}
Um die Reihenfolge eines Vektors umzukehren, kann \lstinline!rev(<<Vektor>>)!\index[func]{rev()@\lstinline{rev()}} (\emph{reverse}) benutzt werden.
\begin{lstlisting}
> vec <- c(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
> rev(vec)
[1] 20 19 18 17 16 15 14 13 12 11 10
\end{lstlisting}

\index{Vektor!sortieren}
\index{sortieren|see{Datensatz, Matrix, Vektor}}
Die Elemente eines Vektors lassen sich auch entsprechend ihrer Reihenfolge sortieren, die wiederum vom Datentyp des Vektors abhängt: Bei numerischen Vektoren bestimmt die Größe der gespeicherten Zahlen, bei Vektoren aus Zeichenketten die alphabetische Reihenfolge der Elemente die Ausgabe (Abschn.\ \ref{sec:isTRUE}, Fußnote \ref{ftn:locale}). Zum Sortieren stehen die Funktionen \lstinline!sort()!\index[func]{sort()@\lstinline{sort()}} und \lstinline!order()!\index[func]{order()@\lstinline{order()}|textbf} zur Verfügung.
\begin{lstlisting}
sort(<<Vektor>>,  decreasing=FALSE)
order(<<Vektor>>, decreasing=FALSE)
\end{lstlisting}

\lstinline!sort()! gibt eine sortierte Version des Vektors aus, ohne den übergebenen Vektor selbst zu verändern. Dagegen ist das Ergebnis von \lstinline!order()! ein Indexvektor, der die Indizes des zu ordnenden Vektors in der Reihenfolge seiner Elemente enthält. Im Gegensatz zu \lstinline!sort()! gibt \lstinline!order()! also nicht schon die sortierten Datenwerte, sondern nur die zugehörigen Indizes aus, die anschließend zum Indizieren des Vektors verwendet werden können. Für einen Vektor \lstinline!x! ist daher \lstinline!sort(x)! äquivalent zu \lstinline!x[order(x)]!.\footnote{Sofern keine fehlenden Werte \lstinline!NA! im Vektor vorhanden sind (Abschn.\ \ref{sec:sortNA}). Mit \lstinline!x_ord! als dem mit Hilfe der Indizes \lstinline!idx! sortierten Vektor \lstinline!x! gilt dann auch, dass \lstinline!x_ord[order(idx)]! die ursprüngliche Reihenfolge wiederherstellt.} Der Vorteil von \lstinline!order()! erweist sich beim Umgang mit Matrizen und Datensätzen (Abschn.\ \ref{sec:sortMat}, \ref{sec:sortDf}). Die Sortierreihenfolge wird über das Argument \lstinline!decreasing! kontrolliert. In der Voreinstellung \lstinline!FALSE! wird aufsteigend sortiert. Mit \lstinline!decreasing=TRUE! ist die Reihenfolge absteigend.
\begin{lstlisting}
> vec <- c(10, 12, 1, 12, 7, 16, 6, 19, 10, 19)
> sort(vec)
[1] 1 6 7 10 10 12 12 16 19 19

> (idxDec <- order(vec, decreasing=TRUE))
[1] 8 10 6 2 4 1 9 5 7 3

> vec[idxDec]
[1] 19 19 16 12 12 10 10 7 6 1
\end{lstlisting}

Wenn Vektoren vom Datentyp \lstinline!character! sortiert werden, so geschieht dies in alphabetischer Reihenfolge. Auch als Zeichenkette gespeicherte Zahlen werden hierbei alphabetisch sortiert, d.\,h.\ die Zeichenkette \lstinline!"10"! käme vor \lstinline!"4"!.
\begin{lstlisting}
> sort(c("D", "E", "10", "A", "F", "E", "D", "4", "E", "A"))
[1] "10" "4" "A" "A" "D" "D" "E" "E" "E" "F"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Werte in zufällige Reihenfolge bringen}
\label{sec:randOrder}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Reihenfolge}
\index{zufällige Reihenfolge}
Zufällige Reihenfolgen können mit Kombinationen von \lstinline!rep()! und \lstinline!sample()! erstellt werden und entsprechen der zufälligen Permutation einer Menge (Abschn.\ \ref{sec:combinatorics}). Sie sind z.\,B.\ bei der randomisierten Zuteilung von Beobachtungsobjekten zu Gruppen, beim Randomisieren der Reihenfolge von Bedingungen oder beim Ziehen einer Zufallsstichprobe aus einer Datenmenge nützlich.
\begin{lstlisting}
# randomisiere Reihenfolge von 5 Farben
> myColors  <- c("red", "green", "blue", "yellow", "black")
> (randCols <- sample(myColors, size=length(myColors), replace=FALSE))
[1] "yellow" "green" "red" "blue" "black"

# teile 12 Personen auf 3 unterschiedlich große Gruppen auf
> P   <- 3                                    # Anzahl Gruppen
> Nj  <- c(4, 3, 5)                           # Gruppengrößen
> (IV <- rep(seq_len(P), times=Nj))           # Gruppenzugehörigkeiten
[1] 1 1 1 1 2 2 2 3 3 3 3 3

# zufällige Permutation
> (IVrand <- sample(IV, size=length(IV), replace=FALSE))
[1] 2 1 1 3 3 1 3 1 2 2 3 3
\end{lstlisting}

Um allgemein $n$ Beobachtungsobjekte auf $p$ möglichst ähnlich große Gruppen aufzuteilen, können zunächst mit \lstinline!sample()! die Indizes $1, \ldots, n$ permutiert werden, um dann mit \lstinline!%%! den Rest der ganzzahligen Division jedes Index mit $p$ zu bilden, der die $p$ Werte $0, \ldots, p-1$ annehmen kann.
\begin{lstlisting}
> P <- 3
> N <- 20
> (sample(seq_len(N), size=N, replace=FALSE) %% P) + 1
[1] 2 2 2 3 3 3 1 3 1 2 3 2 1 1 2 3 2 1 3 1
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Teilmengen von Daten auswählen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!auswählen}
\index{Daten!Zufallsauswahl}
\index{Zufallsauswahl|see{Daten}}
\index{Auswahl|see{Daten}}
Soll aus einer vorhandenen Datenmenge eine Teilstichprobe gezogen werden, hängt das Vorgehen von der beabsichtigten Art der Ziehung ab. Grundsätzlich können zur Auswahl von Werten logische wie numerische Indexvektoren zum Einsatz kommen, die sich systematisch oder zufällig erzeugen lassen.

Eine rein zufällige Unterauswahl eines bestimmten Umfangs ohne weitere Nebenbedingungen kann mit \lstinline!sample()! erstellt werden.\footnote{Das Paket \lstinline!car!\index[pack]{car@\lstinline{car}|textbf} \cite{Fox2009} bietet hierfür die Funktion \lstinline!some()!\index[func]{some()@\lstinline{some()}}, die sich auch für Matrizen (Abschn.\ \ref{sec:matrix}) oder Datensätze (Abschn.\ \ref{sec:dataframe}) eignet.} Dazu betrachtet man den Datenvektor als Urne, aus der ohne Zurücklegen die gewünschte Anzahl von Beobachtungen gezogen wird.
\begin{lstlisting}
> vec <- rep(c("rot", "grün", "blau"), each=10)
> sample(vec, size=5, replace=FALSE)
[1] "blau" "grün" "blau" "grün" "rot"
\end{lstlisting}

Ein anderes Ziel könnte darin bestehen, z.\,B.\ jedes zehnte Element einer Datenreihe auszugeben. Hier bietet sich \lstinline!seq()! an, um die passenden Indizes zu erzeugen.
\begin{lstlisting}
> selIdx1 <- seq(1, length(vec), by=10)      # Elemente 1, 11, 21
> vec[selIdx1]
[1] "rot"  "grün" "blau"
\end{lstlisting}

Soll nicht genau, sondern nur im Mittel jedes zehnte Element ausgegeben werden, eignet sich \lstinline!rbinom()! zum Erstellen eines geeigneten Indexvektors. Dazu kann der Vektor der Trefferanzahlen aus einer Serie von jeweils nur einmal durchgeführten Bernoulli-Experimenten mit Trefferwahrscheinlichkeit $\frac{1}{10}$ in einen logischen Indexvektor umgewandelt werden:
\begin{lstlisting}
> selIdx2 <- rbinom(length(vec), size=1, prob=0.1) == 1
> vec[selIdx2]
[1] "blau" "grün" "blau" "grün" "grün"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Daten umrechnen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!elementweise Berechnung}
Auf Vektoren lassen sich alle elementaren Rechenoperationen anwenden, die in Abschn.\ \ref{sec:arithmetic} für Skalare aufgeführt wurden. Vektoren können also in den meisten Rechnungen wie Einzelwerte verwendet werden, wodurch sich Variablen leicht umskalieren lassen. Die Berechnungen einer Funktion werden dafür elementweise durchgeführt: Die Funktion wird zunächst auf das erste Element des Vektors angewendet, dann auf das zweite, usw., bis zum letzten Element. Das Ergebnis ist ein Vektor, der als Elemente die Einzelergebnisse besitzt. In der Konsequenz ähnelt die Schreibweise zur Transformation von in Vektoren gespeicherten Werten in R sehr der aus mathematischen Formeln gewohnten.
\begin{lstlisting}
> age <- c(18, 20, 30, 24, 23, 21)
> age/10
[1] 1.8 2.0 3.0 2.4 2.3 2.1

> (age/2) + 5
[1] 14.0 15.0 20.0 17.0 16.5 15.5
\end{lstlisting}

Auch in Situationen, in denen mehrere Vektoren in einer Rechnung auftauchen, können diese wie Einzelwerte verwendet werden. Die Vektoren werden dann elementweise entsprechend der gewählten Rechenoperation miteinander verrechnet. Dabei wird das erste Element des ersten Vektors mit dem ersten Element des zweiten Vektors z.\,B.\ multipliziert, ebenso das zweite Element des ersten Vektors mit dem zweiten Element des zweiten Vektors, usw.
\begin{lstlisting}
> vec1 <- c( 3, 4,  5, 6)
> vec2 <- c(-2, 2, -1, 3)
> vec1*vec2
[1] -6 8 -5 18

> vec3 <- c(10, 100, 1000, 10000)
> (vec1 + vec2) / vec3
[1] 1e-01 6e-02 4e-03 9e-04
\end{lstlisting}

Die Zahlen der letzten Ausgabe sind in verkürzter Exponentialschreibweise dargestellt (Abschn.\ \ref{sec:arithmetic}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Zyklische Verlängerung von Vektoren (recycling)}
\label{sec:recycling}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!zyklische Verlängerung}
\index{Vektor!recycling}
\index{recycling|see{Vektor}}
\index{zyklische Verlangerung@zyklische Verlängerung|see{Vektor}}
Die Verrechnung mehrerer Vektoren scheint aufgrund der elementweisen Zuordnung zunächst vorauszusetzen, dass die Vektoren dieselbe Länge besitzen. Tatsächlich ist dies nicht unbedingt notwendig, weil R in den meisten Fällen diesen Zustand ggf.\ selbsttätig herstellt. Dabei wird der kürzere Vektor intern von R zyklisch wiederholt (also sich selbst angefügt, \emph{recycling}), bis er mindestens die Länge des längeren Vektors besitzt. Eine Warnmeldung wird in einem solchen Fall nur dann ausgegeben, wenn die Länge des längeren Vektors kein ganzzahliges Vielfaches der Länge des kürzeren Vektors ist. Dies ist gefährlich, weil meist Vektoren gleicher Länge miteinander verrechnet werden sollen und die Verwendung von Vektoren ungleicher Länge ein Hinweis auf fehlerhafte Berechnungen sein kann.
\begin{lstlisting}
> age  <- c(18, 20, 30, 24, 23, 21)
> vec1 <- c(2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24)
> vec2 <- c(2, 4, 6, 8, 10)
> c(length(age), length(vec1), length(vec2))  # Länge der 3 Vektoren
[1] 6  12  5

> vec1*age                                    # age 2 mal dupliziert
[1] 36 80 180 192 230 252 252 320 540 480 506 504

> vec2*age                                    # vec2 2 mal dupliziert
[1] 36 80 180 192 230 42

Warning message:
Länge des längeren Objektes ist kein Vielfaches der Länge des kürzeren
Objektes in: vec2 * age
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection[\texorpdfstring{$z$}{z}-Transformation]{$\bm{z}$-Transformation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!z-transformieren@$z$-transformieren}
Durch eine $z$-Transformation wird eine quantitative Variable $X$ so normiert, dass sie den Mittelwert $\bar{x}=0$ und die Standardabweichung $s=1$ besitzt. Dies geschieht für jeden Einzelwert $x_{i}$ durch $\frac{x_{i}-\bar{x}}{s}$. \lstinline!mean(<<Vektor>>)! berechnet den Mittelwert (Abschn.\ \ref{sec:mean}), \lstinline!sd(<<Vektor>>)! ermittelt die korrigierte Streuung (Abschn.\ \ref{sec:varSd}).
\begin{lstlisting}
> (zAge <- (age - mean(age)) / sd(age))
[1] -1.1166106 -0.6380632 1.7546739 0.3190316 0.0797579 -0.3987895
\end{lstlisting}

\index{Daten!zentrieren}
Eine andere Möglichkeit bietet die Funktion \lstinline!scale(x=<<Vektor>>, center=TRUE, scale=TRUE)!\index[func]{scale()@\lstinline{scale()}}. Sie berechnet die $z$-Werte mit Hilfe der korrigierten Streuung, gibt sie jedoch nicht in Form eines Vektors, sondern als Matrix mit einer Spalte aus.\footnote{Für \lstinline!x! kann auch eine Matrix übergeben werden, deren $z$-transformierte Spalten dann die Spalten der ausgegebenen Matrix ausmachen (Abschn.\ \ref{sec:matrix}).} Weiterhin werden Mittelwert und korrigierte Streuung von \lstinline!x! in Form von Attributen mit angegeben. Standardisierung und Zentrierung können unabhängig voneinander ausgewählt werden: Für die zentrierten, nicht aber standardisierten Werte von \lstinline!x! ist etwa \lstinline!scale=FALSE! zu setzen und \lstinline!center=TRUE! zu belassen.
\begin{lstlisting}
> (zAge <- scale(age))
           [,1]
[1,] -1.1166106
[2,] -0.6380632
[3,]  1.7546739
[4,]  0.3190316
[5,]  0.0797579
[6,] -0.3987895

attr(,"scaled:center")
[1] 22.66667

attr(,"scaled:scale")
[1] 4.179314
\end{lstlisting}

Um die ausgegebene Matrix wieder in einen Vektor zu verwandeln, muss sie wie in Abschn.\ \ref{sec:asVecMat} dargestellt mit \lstinline!as.vector(<<Matrix>>)! konvertiert werden.
\begin{lstlisting}
> as.vector(zAge)
[1] -1.1166106 -0.6380632 1.7546739 0.3190316 0.0797579 -0.3987895
\end{lstlisting}

\index{Daten!skalieren}
Durch Umkehrung des Prinzips der $z$-Transformation lassen sich empirische Datenreihen so skalieren, dass sie einen beliebigen Mittelwert $\bar{x}_{\text{neu}}$ und eine beliebige Streuung $s_{\text{neu}}$ besitzen. Dies geschieht für eine $z$-transformierte Variable $Z$ mit $Z \cdot s_{\text{neu}} + \bar{x}_{\text{neu}}$.
\begin{lstlisting}
> newSd   <- 15
> newMean <- 100
> (newAge <- as.vector(zAge)*newSd + newMean)
[1] 83.25084 90.42905 126.32011 104.78547 101.19637 94.01816

> mean(newAge)                              # Kontrolle: Mittelwert
[1] 100

> sd(newAge)                                # Kontrolle: Streuung
[1] 15
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Rangtransformation}
\label{sec:transformRank}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!Rangtransformation}
\index{Rangplatz|see{Daten}}
\lstinline!rank(<<Vektor>>)!\index[func]{rank()@\lstinline{rank()}} gibt für jedes Element eines Vektors seinen Rangplatz an, der sich an der Position des Wertes im sortierten Vektor orientiert und damit der Ausgabe von \lstinline!order()! ähnelt. Anders als bei \lstinline!order()! erhalten identische Werte in der Voreinstellung jedoch denselben Rang. Das Verhalten, mit dem bei solchen \emph{Bindungen} Ränge ermittelt werden, kontrolliert das Argument \lstinline!ties.method! -- Voreinstellung sind mittlere Ränge.
\begin{lstlisting}
> rank(c(3, 1, 2, 3))
[1] 3.5 1.0 2.0 3.5
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Neue aus bestehenden Variablen bilden}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Variable!neue aus bestehenden bilden}
Das elementweise Verrechnen mehrerer Vektoren kann, analog zur $z$-Transformation, allgemein zur flexiblen Neubildung von Variablen aus bereits bestehenden Daten genutzt werden.

Ein Beispiel sei die Berechnung des Body-Mass-Index (BMI) einer Person, für den ihr Körpergewicht in kg durch das Quadrat ihrer Körpergröße in m geteilt wird.
\begin{lstlisting}
> height <- c(1.78, 1.91, 1.89, 1.83, 1.64)
> weight <- c(65, 89, 91, 75, 73)
> (bmi   <- weight / (height^2))
[1] 20.51509 24.39626 25.47521 22.39541 27.14158
\end{lstlisting}

In einem zweiten Beispiel soll die Summenvariable aus drei dichotomen Items ({\quotedblbase}trifft zu{\textquotedblleft}: \lstinline!TRUE!, {\quotedblbase}trifft nicht zu{\textquotedblleft}: \lstinline!FALSE!) eines an $8$ Personen erhobenen Fragebogens gebildet werden. Dies ist die Variable, die jeder Person den\index{Summenscore} Summenscore aus ihren Antworten zuordnet, also angibt, wie viele Items von der Person als zutreffend angekreuzt wurden. Logische Werte verhalten sich bei numerischen Rechnungen wie $1$ (\lstinline!TRUE!) bzw.\ $0$ (\lstinline!FALSE!).
\begin{lstlisting}
> quest1  <- c(FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE, FALSE, TRUE)
> quest2  <- c(TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE, TRUE,  FALSE)
> quest3  <- c(TRUE,  TRUE,  TRUE,  TRUE,  FALSE, TRUE, FALSE, FALSE)
> (sumVar <- quest1 + quest2 + quest3)            # Summenscore
[1] 2 1 1 2 1 3 1 1

> (avgVar <- (quest1 + quest2 + quest3) / 3)      # mittlerer Score
[1] 0.66667 0.33333 0.33333 0.66667 0.33333 1.00000 0.333333 0.33333
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Werte ersetzen oder recodieren}
\label{sec:recode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Elemente ersetzen}
\index{Daten!ersetzen}
\index{Daten!recodieren}
\index{recodieren|see{Daten}}
Mitunter werden Variablen zunächst auf eine bestimmte Art codiert, die sich später für manche Auswertungen als nicht zweckmäßig erweist und deswegen geändert werden soll. Dann müssen bestimmte Werte gesucht und ersetzt werden, was sich auf verschiedenen Wegen erreichen lässt. Dabei sollte die Variable mit recodierten Werten stets als neues Objekt erstellt werden, statt die Werte des alten Objekts zu überschreiben.

Mit \lstinline!replace()!\index[func]{replace()@\lstinline{replace()}} können Werte eines Vektors systematisch durch andere Werte ersetzt werden, wobei ein Indexvektor zum Einsatz kommt, der sich aus der Prüfung von Bedingungen ergeben kann.
\begin{lstlisting}
replace(x=<<Vektor>>, list=<<Indexvektor>>, values=<<neue Werte>>)
\end{lstlisting}

Der Vektor mit den auszutauschenden Elementen ist unter \lstinline!x! zu nennen. Welche Werte geändert werden sollen, gibt der Indexvektor \lstinline!list! über numerische oder logische Indizes an. Der Vektor \lstinline!values! definiert für jeden durch den Index in \lstinline!list! ausgewählten alten Wert, welcher neue Wert an dieser Stelle einzufügen ist. Nicht ausgewählte Elemente von \lstinline!x! bleiben erhalten. Da \lstinline!replace()! den unter \lstinline!x! angegebenen Vektor nicht verändert, muss das Ergebnis ggf.\ einem neuen Objekt zugewiesen werden.

In einem Vektor seien dazu die Lieblingsfarben von sieben englischsprachigen Personen erhoben worden. Später soll die Variable auf deutsche Farbnamen recodiert werden.
\begin{lstlisting}
> myColors <- c("red", "purple", "blue", "blue",
+               "green", "red", "green")

# tausche schrittweise alle englischen Farben aus
> farben <- replace(myColors, myColors == "red",    "rot")
> farben <- replace(farben,   farben   == "purple", "lila")
> farben <- replace(farben,   farben   == "blue",   "blau")
> farben <- replace(farben,   farben   == "green",  "gruen")
> farben
[1] "rot"  "lila"  "blau"  "blau"  "gruen"  "rot"  "gruen"
\end{lstlisting}

Für Vektoren aus Zeichenketten folgt eine knappere Lösung aus der Möglichkeit, benannte Vektoren über Elementnamen zu indizieren. Dazu ist es notwendig, zunächst einen benannten Vektor mit Elementen nach dem Muster \lstinline!<<Wert alt>>=<<Wert neu>>! zu erstellen, der die Ersetzungsregeln definiert. Dieser Vektor ist dann mit dem zu transformierenden Vektor zu indizieren. Die Reocdierung mit dieser Methode funktioniert nur, wenn alle ursprünglichen Werte auch als Name vergeben werden, andernfalls resultieren fehlende Werte \lstinline!NA!.
\begin{lstlisting}
> repl <- c(red="rot", purple="lila", blue="blau", green="gruen")
> repl[myColors]
  red  purple    blue   blue     orange    red    green
"rot"  "lila"  "blau"  "blau"  "orange"  "rot"  "gruen"

# "violet" ist nicht im benannten Vektor enthalten -> erzeugt NA
> repl[c(myColors, "violet")]
  red  purple    blue    blue    orange    red    orange  <NA>
"rot"  "lila"  "blau"  "blau"  "orange"  "rot"  "orange"    NA
\end{lstlisting}

\lstinline!case_match()!\index[func]{case_match()@\lstinline{case_match()}} aus dem Paket \lstinline!dplyr!\index[pack]{dplyr@\lstinline{dplyr}|textbf} \cite{Wickham2014c} ermöglicht es auf bequeme Weise, gleichzeitig bestimmte Werte nach einem Muster zu ändern, ohne dabei selbst logische Indexvektoren bilden zu müssen.
\begin{lstlisting}
case_match(<<Vektor>>,
           <<Wert1 alt>> ~ <<Wert1 neu>>, <<Wert2 alt>> ~ <<Wert2 neu>>, ...)
\end{lstlisting}

Der Vektor mit zu ändernden Werten ist als erstes Argument anzugeben. Die Recodierung erfolgt anhand von beliebig vielen durch Komma getrennten Wertepaaren \lstinline!<<alt>> ~ <<neu>>!. Zeichenketten sind dabei in Anführungszeichen zu setzen. Mehreren alten Werten kann derselbe neue Wert zugewiesen werden, indem statt eines einfachen Werts \lstinline!<<alt>>! auf der linken Seite der \lstinline!~! ein Vektor zu ersetzender Werte \lstinline!c(<<alt1>>, <<alt2>>, ...)! steht. Nicht aufgeführte alte Werte werden durch \lstinline!NA! ersetzt. Alle nicht explizit genannten alten Werte lassen sich mit dem Argument \lstinline!.default! auf denselben neuen Standardwert setzen.
\begin{lstlisting}
> library(dplyr)                                    # für case_match()
> case_match(myColors,
+            "red"    ~ "rot",
+            "blue"   ~ "blau",
+            "purple" ~ "lila",
+            "green"  ~ "gruen")
[1] "rot" "lila" "blau" "blau" "gruen" "rot" "gruen" 

# Einteilung der Farben in Basisfarben und andere
> case_match(myColors,
+            c("red", "blue") ~ "basic",
+            .default="complex")
[1] "basic" "complex" "basic" "basic" "complex" "basic" "complex"
\end{lstlisting}

Auch numerische Vektoren lassen sich mit \lstinline!case_match()! umcodieren. Flexibler ist dies aber mit den in Abschn.\ \ref{sec:discretize} und \ref{sec:cut} vorgestellten Methoden möglich.
\begin{lstlisting}
> orgVec <- c(5, 9, 11, 8, 9, 3, 1, 13, 9, 12, 5, 12)
> case_match(orgVec,
+             0:4  ~ "V00-04",
+             5:10 ~ "V05-10",
+            11:20 ~ "V11-20")
[1] "V05-10" "V05-10" "V11-20" "V05-10" "V05-10" "V00-04"
[7] "V00-04" "V11-20" "V05-10" "V11-20" "V05-10" "V11-20"
\end{lstlisting}

Gilt es, Werte entsprechend einer dichotomen Entscheidung durch andere zu ersetzen, kann dies mit \index[func]{ifelse()@\lstinline{ifelse()}}\lstinline!ifelse()! geschehen.
\begin{lstlisting}
ifelse(test=<<logischer Ausdruck>>, yes=<<Wert>>, no=<<Wert>>)
\end{lstlisting}

Für das Argument \lstinline!test! muss ein Ausdruck angegeben werden, der sich zu einem logischen Wert auswerten lässt, der also WAHR (\lstinline!TRUE!) oder FALSCH (\lstinline!FALSE!) ist. Ist \lstinline!test! WAHR, wird der unter \lstinline!yes! eingetragene Wert zurückgegeben, andernfalls der unter \lstinline!no! genannte. Ist \lstinline!test! ein Vektor, wird jedes seiner Elemente daraufhin geprüft, ob es \lstinline!TRUE! oder \lstinline!FALSE! ist und ein Vektor mit den passenden, unter \lstinline!yes! und \lstinline!no! genannten Werten als Elementen zurückgegeben. Die Ausgabe hat also immer dieselbe Länge wie die von \lstinline!test!.

Die Argumente \lstinline!yes! und \lstinline!no! können selbst Vektoren derselben Länge wie \lstinline!test! sein -- ist dann etwa das dritte Element von \lstinline!test! gleich \lstinline!TRUE!, wird als drittes Element des Ergebnisses das dritte Element von \lstinline!yes! zurückgegeben, andernfalls das dritte Element von \lstinline!no!. Gegenüber \lstinline!replace()! eignet sich \lstinline!ifelse()! dann eher, wenn alle Werte verändert werden sollen.
\begin{lstlisting}
> cutoff <- 10    # ersetze Werte unter cutoff durch 0, sonst durch 1
> (reVec <- ifelse(orgVec < cutoff, 0, 1))
 [1] 0 0 1 0 0 0 0 1 0 1 0 1

# codiere Werte aus Zielmenge als "yes", sonst "no"
> targetSet <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K")
> response  <- c("Z", "E", "O", "W", "H", "C", "I", "G")
> (respRec  <- ifelse(response %in% targetSet, "yes", "no"))
[1] "no"  "yes"  "no"  "no"  "yes"  "yes"  "yes"  "yes"
\end{lstlisting}

Das Argument \lstinline!x! sollte ein einfacher Vektor sein, da \lstinline!ifelse()! die Klasse des übergebenen Objekts nicht respektiert -- insbesondere Faktoren (Abschn.\ \ref{sec:factor}) sind deshalb für \lstinline!ifelse()! ungeeignet.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kontinuierliche Variablen in Kategorien einteilen}
\label{sec:discretize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!diskretisieren}
Als Spezialfall des Recodierens können neue Variablen dadurch entstehen, dass der Wertebereich von ursprünglich kontinuierlichen Variablen in Klassen eingeteilt wird. Auf diese Weise lässt sich eine quantitative in eine kategoriale Variable umwandeln. Hier soll der IQ-Wert mehrerer Personen zu einer Klasseneinteilung genutzt werden. Da sich \lstinline!replace()! dafür weniger eignet, beruht der manuelle Lösungsansatz direkt auf einer zunächst leeren, schrittweise über logische Indexvektoren mit Werten zu füllenden Variable.
\begin{lstlisting}
> IQ    <- c(112, 103, 87, 86, 90, 101, 90, 89, 122, 103)
> IQcls <- numeric(length(IQ))              # neuen Vektor erstellen
> IQcls[IQ <= 100]                <- 1      # Intervall bis inkl. 100
> IQcls[(IQ > 100) & (IQ <= 115)] <- 2      # Intervall (100, 115]
> IQcls[IQ > 115]                 <- 3      # Intervall größer 115
> IQcls
[1] 2 2 1 1 1 2 1 1 3 2
\end{lstlisting}

Als bequeme Alternative kann aus dem Paket \lstinline!dplyr!\index[pack]{dplyr@\lstinline{dplyr}} die Funktion \lstinline!case_when()! zum Einsatz kommen, die Abschn.\ \ref{sec:dplyr_transform} näher vorstellt.
\begin{lstlisting}
> case_when((IQ <= 100)              ~ 1,
+           (IQ > 100) & (IQ <= 115) ~ 2,
+           (IQ > 115)               ~ 3)
[1] 2 2 1 1 1 2 1 1 3 2
\end{lstlisting}

\lstinline!ifelse()! eignet sich für den Spezialfall, den Wertebereich in zwei Gruppen einzuteilen.
\begin{lstlisting}
> ifelse(IQ >= 100, "hi", "lo")             # Dichotomisierung
[1] "hi" "hi" "lo" "lo" "lo" "hi" "lo" "lo" "hi" "hi"
\end{lstlisting}

Allgemein besonders leicht lassen sich quantitative Variablen zudem mit \lstinline!cut()! diskretisieren (Abschn.\ \ref{sec:cut}). Hierdurch werden sie zu Faktoren, dem Gegenstand des folgenden Abschnitts.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Gruppierungsfaktoren}
\label{sec:factor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Faktor}
\index{Variable!kategoriale|see{Faktor}}
Die Klasse \lstinline!factor! existiert, um die Eigenschaften kategorialer Variablen mit einer begrenzten Menge möglicher Werte abzubilden. Ein Objekt dieser Klasse nimmt die jeweilige Gruppenzugehörigkeit von Beobachtungsobjekten auf und speichert zusätzlich, welche Stufen die Variable prinzipiell umfasst. Für den Gebrauch in inferenzstatistischen Analysefunktionen ist es wichtig, dass Gruppierungsvariablen auch tatsächlich die Klasse \lstinline!factor! besitzen. Bei numerisch codierter Gruppenzugehörigkeit besteht sonst die Gefahr der Verwechslung mit echten quantitativen Variablen, was etwa bei Regressionsmodellen für falsche Ergebnisse sorgen kann.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ungeordnete Faktoren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Als Beispiel für eine Gruppenzugehörigkeit soll das qualitative Merkmal Geschlecht dienen, dessen Ausprägungen in einer Stichprobe zunächst als \lstinline!character! Werte eingegeben und in einem Vektor gespeichert werden.
\begin{lstlisting}
> sex <- c("m", "f", "f", "m", "m", "m", "f", "f")
\end{lstlisting}

\index[func]{factor()@\lstinline{factor()}}
Um den aus Zeichen bestehenden Vektor zu einem Gruppierungsfaktor mit zwei Ausprägungen zu machen, dient der Befehl \lstinline!factor()!.
\begin{lstlisting}
factor(x=<<Vektor>>, levels=<<Stufen>>, labels=levels)
\end{lstlisting}

Unter \lstinline!x! ist der umzuwandelnde Vektor einzutragen. Welche Stufen der Faktor prinzipiell annehmen kann, bestimmt das Argument \lstinline!levels!. In der Voreinstellung werden die Faktorstufen automatisch anhand der in \lstinline!x! tatsächlich vorkommenden Werte mit \lstinline!sort(unique(x))! bestimmt.
\begin{lstlisting}
> (sexFac <- factor(sex))
[1] m f f m m m f f
Levels: f m
\end{lstlisting}

Da die in \lstinline!x! gespeicherten empirischen Ausprägungen nicht notwendigerweise auch alle theoretisch möglichen Kategorien umfassen müssen, kann an \lstinline!levels! auch ein Vektor mit allen möglichen Stufen übergeben werden.
\begin{lstlisting}
# 2 und 5 kommen nicht vor, sollen aber mögliche Ausprägungen sein
> factor(c(1, 1, 3, 3, 4, 4), levels=1:5)
[1] 1 1 3 3 4 4
Levels: 1 2 3 4 5
\end{lstlisting}

Die Stufenbezeichnungen stimmen in der Voreinstellung mit den \lstinline!levels! überein, sie können aber auch durch einen für das Argument \lstinline!labels! übergebenen Vektor umbenannt werden. Dies könnte etwa sinnvoll sein, wenn die Faktorstufen in einem Vektor numerisch codiert sind, im Faktor aber inhaltlich aussagekräftigere Namen erhalten sollen. \lstinline!labels! muss ein Vektor derselben Länge wie \lstinline!levels! sein. Indem verschiedenen Werten in \lstinline!levels! dieselbe Bezeichnung in \lstinline!labels! zugewiesen wird, können Faktorstufen zu Gruppen zusammengefasst werden.
\begin{lstlisting}
> (sexNum <- rbinom(10, size=1, prob=0.5))      # 0=Mann, 1=Frau
[1] 0 1 1 0 1 0 0 0 1 1

> factor(sexNum, levels=0:1, labels=c("man", "woman"))
[1] man woman woman man woman man man man woman woman
Levels: man woman

# fasse Ausprägungen 1, 2 zu Gruppe A und 3, 4 zu Gruppe B zusammen
> factor(c(1, 2, 3, 4), levels=1:4, labels=c("A", "A", "B", "B"))
[1] A A B B
Levels: A B
\end{lstlisting}

Die Anzahl der Stufen eines Faktors wird mit\index[func]{nlevels()@\lstinline{nlevels()}} \lstinline!nlevels(<<Faktor>>)! ausgegeben. Wie häufig jede Stufe vorkommt, erfährt man durch\index[func]{summary()@\lstinline{summary()}} \lstinline!summary(<<Faktor>>)!.
\begin{lstlisting}
> nlevels(sexFac)
[1] 2

> summary(sexFac)
f  m
4  4
\end{lstlisting}

Die im Faktor gespeicherten Werte werden intern auf zwei Arten repräsentiert -- zum einen mit den Namen der Faktorstufen in einem \lstinline!character! Vektor im Attribut \lstinline!levels!, zum anderen mit einer internen Codierung der Stufen über fortlaufende natürliche Zahlen, die der (ggf.\ alphabetischen) Reihenfolge der Ausprägungen entspricht. Dies wird in der Ausgabe der internen Struktur eines Faktors mit \lstinline!str(<<Faktor>>)! deutlich. Die Namen der Faktorstufen werden mit \lstinline!levels(<<Faktor>>)! ausgegeben, die interne numerische Repräsentation mit\index[func]{unclass()@\lstinline{unclass()}} \lstinline!unclass(<<Faktor>>)!.\footnote{Trotz dieser Codierung können Faktoren keinen mathematischen Transformationen unterzogen werden. Wenn die Namen der Faktorstufen aus Zahlen gebildet werden, kann es zu Diskrepanzen zwischen den Stufen und der internen Codierung kommen: \lstinline!unclass(factor(10:15))! ergibt \lstinline!1 2 3 4 5 6!. Dies ist bei der üblichen Verwendung von Faktoren aber irrelevant.}
\begin{lstlisting}
> levels(sexFac)
[1] "f" "m"

> str(sexFac)
Factor w/ 2 levels "f","m": 2 1 1 2 2 2 1 1

> unclass(sexFac)
[1] 2 1 1 2 2 2 1 1

attr(,"levels")
[1] "f" "m"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Faktoren kombinieren}
\label{sec:combFac}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Faktoren lassen sich wie gewöhnliche Vektoren mit \lstinline!c()! aneinanderhängen. Der neue Faktor besitzt als Stufen die Vereinigungsmenge der Stufen der übergebenen Faktoren.
\begin{lstlisting}
# Faktoren 1 und 2
> (fac1 <- factor(sample(LETTERS[1:5], 4), levels=LETTERS[1:5]))
[1] D E A C
Levels: A B C D E

> (fac2 <- factor(sample(letters[1:5], 3), levels=letters[1:5]))
[1] d c e
Levels: a b c d e

> c(fac1, fac2)
[1] D E A C d c e
Levels: A B C D E a b c d e
\end{lstlisting}

Gilt es, lediglich einen bereits bestehenden Faktor zu vervielfachen, eignet sich wie bei Vektoren \lstinline!rep()!.
\begin{lstlisting}
> rep(fac1, times=2)                    # Faktor 1 wiederholen
[1] Q A P U J Q A P U J
Levels: A J P Q U
\end{lstlisting}

In Situationen, in denen sich experimentelle Bedingungen aus der Kombination von zwei oder mehr Faktoren ergeben, ist es bisweilen nützlich, die mehrfaktorielle in eine geeignete einfaktorielle Struktur zu überführen. Dabei werden alle Kombinationen von Faktorstufen als Stufen eines neuen einzelnen Faktors betrachtet -- etwa im Kontext einer assoziierten einfaktoriellen Varianzanalyse bei einem eigentlich zweifaktoriellen Design (Abschn.\ \ref{sec:CRFpq}). Dies ist mit\index[func]{interaction()@\lstinline{interaction()}|textbf} \lstinline!interaction()! möglich.
\begin{lstlisting}
interaction(<<Faktor1>>, <<Faktor2>>, ..., drop=FALSE)
\end{lstlisting}

Als Argument sind zunächst mehrere Faktoren gleicher Länge zu übergeben, die die Gruppenzugehörigkeit derselben Beobachtungsobjekte bzgl.\ verschiedener Gruppierungsfaktoren codieren. Auf ihren Stufenkombinationen basieren die Ausprägungen des neuen Faktors. Dabei kann es vorkommen, dass nicht für jede Stufenkombination Beobachtungen vorhanden sind, da einige Zellen im Versuchsdesign leer sind, oder kein vollständig gekreuztes Design vorliegt. In der Voreinstellung \lstinline!drop=FALSE! erhält der neue Faktor auch für leere Zellen eine passende Faktorstufe. Mit \lstinline!drop=TRUE! werden zu leeren Zellen gehörende Stufen dagegen weggelassen.
\begin{lstlisting}
> (IV1 <- factor(rep(c("lo", "hi"), each=6)))   # Faktor 1
[1] lo lo lo lo lo lo hi hi hi hi hi hi
Levels: hi lo

> (IV2 <- factor(rep(1:3, times=4)))            # Faktor 2
[1] 1 2 3 1 2 3 1 2 3 1 2 3
Levels: 1 2 3

> interaction(IV1, IV2)         # assoziiertes einfaktorielles Design
[1] lo.1 lo.2 lo.3 lo.1 lo.2 lo.3 hi.1 hi.2 hi.3 hi.1 hi.2 hi.3
Levels: hi.1 lo.1 hi.2 lo.2 hi.3 lo.3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Faktorstufen nachträglich ändern}
\label{sec:facChangeLevels}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nachträgliche Änderungen an bestehenden Faktoren lassen sich mit dem Basisumfang von R oder mit Funktionen des Pakets\index[pack]{forcats@\lstinline{forcats}} \lstinline!forcats! \cite{Wickham2019} vornehmen, deren Namen dem Muster \lstinline!fct_<<Verb>>(<<Faktor>>, ...)! folgen. Das Ergebnis dieser Funktionen ist immer ein Faktor mit den geänderten Eigenschaften. Der übergebene Faktor bleibt durch \lstinline!fct_<<Verb>>()! unverändert, ggf.\ muss das Ergebnis also einem neuen Objekt zugewiesen werden.

Wenn die Stufenbezeichnungen eines Faktors im nachhinein ersetzt werden sollen, so kann dem von\index[func]{levels()@\lstinline{levels()}} \lstinline!levels(<<Faktor>>)! ausgegebenen Vektor ein Vektor mit passend vielen neuen Namen zugewiesen werden. Alternativ ist dies mit \lstinline!fct_recode()!\index[func]{fct_recode()@\lstinline{fct_recode()}} möglich.
\begin{lstlisting}
> levels(sexFac) <- c("female", "male")       # vorherige Stufen: f, m
> sexFac
[1] male female female male male male female female
Levels: female male

> library(forcats)                            # für fct_recode()
> fct_recode(sexFac, "F"="female", "M"="male")
[1] M F F M M M F F
Levels: F M
\end{lstlisting}

Einem bestehenden Faktor können nicht beliebige Werte als Element hinzugefügt werden, sondern lediglich bereits vorhandene Faktorstufen. Bei Versuchen, einem Faktorelement einen anderen Wert zuzuweisen, wird das Element auf \lstinline!NA! gesetzt und eine Warnung ausgegeben. Die Menge möglicher Faktorstufen kann jedoch über\index[func]{levels()@\lstinline{levels()}} \lstinline!levels()! erweitert werden, ohne dass es bereits zugehörige Beobachtungen gäbe. Alternativ ist dies mit \lstinline!fct_expand()!\index[func]{fct_expand()@\lstinline{fct_expand()}} möglich.
\begin{lstlisting}
> (status <- factor(c("hi", "lo", "hi")))
[1] hi  lo  hi
Levels: hi lo

# bisher nicht existierende Faktorstufe "mid"
> status[4] <- "mid"
> status
Warning message:
In `[<-.factor`(`*tmp*`, 4, value = "mid") :
invalid factor level, NAs generated

[1] hi  lo  hi  <NA>
Levels: hi lo

> levels(status) <- c(levels(status), "mid")  # Stufe "mid" hinzufügen
> status[4] <- "mid"                          # neue Beobachtung "mid"
> status
[1] hi  lo  hi  mid
Levels: hi lo mid

> fct_expand(status, "new_level")             # Faktor mit neuer Stufe
[1] hi  lo  hi  mid
Levels: hi lo mid new_level
\end{lstlisting}

\index{Daten!recodieren}
Stufen eines bestehenden Faktors lassen sich nicht ohne weiteres löschen. Die erste Möglichkeit, um einen gegebenen Faktor in einen Faktor mit weniger möglichen Stufen umzuwandeln, besteht im Zusammenfassen mehrerer ursprünglicher Stufen zu einer gemeinsamen neuen Stufe. Hierzu muss dem von\index[func]{levels()@\lstinline{levels()}} \lstinline!levels()! ausgegebenen Objekt eine Liste zugewiesen werden, die nach dem Muster \lstinline!list(<<neueStufe>>=c("<<alteStufe1>>", "<<alteStufe2>>", ...))! aufgebaut ist (Abschn.\ \ref{sec:list}). Alternativ ist dies mit \lstinline!fct_collapse()!\index[func]{fct_collapse()@\lstinline{fct_collapse()}} möglich.
\begin{lstlisting}
# kombiniere Stufen "mid" und "lo" zu "notHi", "hi" bleibt unverändert
> hiNotHi <- status                           # Kopie des Faktors
> levels(hiNotHi) <- list(hi="hi", notHi=c("mid", "lo"))
> hiNotHi
[1] hi  notHi  hi  notHi
Levels: hi notHi

> fct_collapse(status, notHi=c("mid", "lo"))
[1] hi  notHi  hi  notHi
Levels: hi notHi
\end{lstlisting}

Sollen dagegen Beobachtungen samt ihrer Stufen gelöscht werden, muss eine Teilmenge der Elemente des Faktors ausgegeben werden, die nicht alle Faktorstufen enthält. Zunächst umfasst diese Teilmenge jedoch nach wie vor alle ursprünglichen Stufen, wie in der Ausgabe unter \lstinline!Levels:! deutlich wird. Sollen nur die in der gewählten Teilmenge tatsächlich auftretenden Ausprägungen auch mögliche Stufen sein, kann dies mit\index[func]{droplevels()@\lstinline{droplevels()}} \lstinline!droplevels()! erreicht werden. Alternativ ist dies mit \lstinline!fct_drop()!\index[func]{fct_drop()@\lstinline{fct_drop()}} -- selektiv auch für einzelne level -- möglich.
\begin{lstlisting}
> status[1:2]
[1] hi lo
Levels: hi lo mid

> (newStatus <- droplevels(status[1:2]))
[1] hi lo
Levels: hi lo

> fct_drop(status[1:2], "mid")
[1] hi lo
Levels: hi lo
\end{lstlisting}

Fehlende Werte (Abschn.\ \ref{sec:na}) im ursprünglichen Vektor bleiben in der Voreinstellung fehlende Werte im aus dem Vektor erstellten Faktor. Beim Erstellen eines Faktors lassen sich jedoch fehlende Werte mit dem Argument \lstinline!exclude=NULL! als eigene Kategorie werten. Im Nachhinein lässt sich derselbe Effekt mit\index[func]{addNA()@\lstinline{addNA()}} \lstinline!addNA()! erzielen. Dies ist etwa in Häufigkeitstabellen nützlich, um fehlende Werte mitzuzählen.
\begin{lstlisting}
# fehlende Werte bilden keine eigene Stufe
> (fac <- factor(c("A", "B", NA, "A", NA)))
[1] A  B  <NA>  A  <NA>
Levels: A B

# fehlende Werte bilden eigene Stufe
> (facNA <- factor(c("A", "B", NA, "A", NA), exclude=NULL))
[1] A  B  <NA>  A  <NA>
Levels: A B <NA>

> table(fac)           # fehlende Werte werden nicht gezählt
fac
A B 
2 1 

> table(addNA(fac))    # fehlende Werte werden gezählt
A  B  <NA> 
2  1     2 
\end{lstlisting}

Alternativ ist es mit \lstinline!fct_na_value_to_level()!\index[func]{fct_na_value_to_level()@\lstinline{fct_na_value_to_level()}} möglich, fehlende Werte zu einer eigenen Faktorstufe zu machen. Um umgekehrt alle Beobachtungen einer bestimmten Faktorstufe zu fehlenden Werten zu machen, eignet sich die Funktion \lstinline!fct_na_level_to_value()!\index[func]{fct_na_level_to_value()@\lstinline{fct_na_level_to_value()}}, die auch die benannte Faktorstufe entfernt.
\begin{lstlisting}
# fehlende Werte als Stufe hinzufügen
> (facNA_lvl <- fct_na_value_to_level(fac, "(N/A)"))
[1] A  B  (N/A)  A  (N/A)
Levels: A B (N/A)

# Werte einer Faktorstufe -> fehlende Werte, Faktorstufe löschen
> fct_na_level_to_value(facNA_lvl, "(N/A)")
[1] A  B  <NA>  A  <NA>
Levels: A B
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Geordnete Faktoren}
\label{sec:facOrder}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Besteht eine Reihenfolge in den Stufen eines Gruppierungsfaktors i.\,S.\ einer ordinalen Variable, so lässt sich dieser Umstand mit der Funktion\index[func]{ordered()@\lstinline{ordered()}} \lstinline!ordered(<<Vektor>>, levels)! abbilden, die einen geordneten Gruppierungsfaktor erstellt. Dabei muss die inhaltliche Reihenfolge im Argument \lstinline!levels! explizit angegeben werden, weil R sonst die Reihenfolge selbst bestimmt und ggf.\ die alphabetische heranzieht. Für die Elemente geordneter Faktoren sind die üblichen Ordnungsrelationen $<, \leq, >, \geq$ definiert.
\begin{lstlisting}
> (ordStat <- ordered(status, levels=c("lo", "mid", "hi")))
[1] hi lo hi mid
Levels: lo < mid < hi

> ordStat[1] > ordStat[2]                       # hi > lo?
[1] TRUE
\end{lstlisting}

Sollen die Elemente des Faktors in eine zufällige Reihenfolge gebracht werden, um die Zuordnung von Beobachtungsobjekten zu Gruppen zu randomisieren, kann dies wie in Abschn.\ \ref{sec:randOrder} geschehen.
\begin{lstlisting}
> sample(ordStat, size=length(ordStat), replace=FALSE)
[1] hi  lo  mid hi 
Levels: lo < mid < hi
\end{lstlisting}

Manche Funktionen zur inferenzstatistischen Analyse nehmen bei geordneten Faktoren Gleichabständigkeit in dem Sinne an, dass die inhaltliche Unterschiedlichkeit zwischen zwei benachbarten Stufen immer dieselbe ist. Trifft dies nicht zu, sollte im Zweifel auf ungeordnete Faktoren zurückgegriffen werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reihenfolge von Faktorstufen kontrollieren}
\label{sec:facLabelOrder}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Beim Sortieren von Faktoren wie auch in manchen statistischen Analysefunktionen ist die Reihenfolge der Faktorstufen bedeutsam. Werden die Faktorstufen beim Erstellen eines Faktors explizit mit \lstinline!levels! angegeben, bestimmt die Reihenfolge dieser Elemente die Reihenfolge der Stufen. Ohne Verwendung von \lstinline!levels! ergibt sich die Reihenfolge aus den sortierten Elementen des Vektors, der zum Erstellen des Faktors verwendet wird.\footnote{Sind dessen Elemente Zeichenketten mit numerischer Bedeutung, so ist zu beachten, dass die Reihenfolge dennoch alphabetisch bestimmt wird -- die Stufe \lstinline!\"10\"! käme demnach vor der Stufe \lstinline!\"4\"!.}
\begin{lstlisting}
> vec <- c(3, 4, 3, 2, 1, 4, 1, 1)

# ohne levels: Reihenfolge aus sortierten Elementen des Vektors
> factor(vec)
[1] 3 4 3 2 1 4 1 1
Levels: 1 2 3 4

# levels angegeben -> levels bestimmt Reihenfolge der Stufen
> factor(vec, levels=c(4, 3, 2, 1))
[1] 3 4 3 2 1 4 1 1
Levels: 4 3 2 1
\end{lstlisting}

Um die Reihenfolge der Stufen nachträglich zu ändern, kann ein Faktor in einen geordneten Faktor unter Verwendung des \lstinline!levels! Arguments umgewandelt werden (s.\,o.). Als weitere Möglichkeit wird mit\index[func]{relevel()@\lstinline{relevel()}} \lstinline!relevel(<<Faktor>>, ref="<<Referenzstufe>>")! die für \lstinline!ref! übergebene Faktorstufe zur ersten Stufe des Faktors, die in manchen statistischen Modellen als Vergleichsgruppe dient.
\begin{lstlisting}
> (abcde <- factor(sample(LETTERS[1:5], 4), levels=LETTERS[1:5]))
[1] B E A C
Levels: A B C D E

> relevel(abcde, ref="E")      # mache E zur ersten Faktorstufe
[1] B E A C
Levels: E A B C D
\end{lstlisting}
     
\lstinline!reorder()!\index[func]{reorder()@\lstinline{reorder()}} ändert die Reihenfolge der Faktorstufen ebenfalls nachträglich. Die Stufen werden so geordnet, dass ihre Reihenfolge durch die gruppenweise gebildeten empirischen Kennwerte einer Variable bestimmt ist. 
\begin{lstlisting}
reorder(x=<<Faktor>>, X=<<Vektor>>, FUN=<<Funktion>>)
\end{lstlisting}

Als erstes Argument \lstinline!x! wird der Faktor mit den zu ordnenden Stufen erwartet. Für das Argument \lstinline!X! ist ein numerischer Vektor derselben Länge wie \lstinline!x! zu übergeben, der auf Basis von \lstinline!x! in Gruppen eingeteilt wird. Pro Gruppe wird die mit \lstinline!FUN! bezeichnete Funktion angewendet, die einen Vektor zu einem skalaren Kennwert verarbeiten muss. Als Ergebnis werden die Stufen von \lstinline!x! entsprechend der Kennwerte geordnet, die sich aus der gruppenweisen Anwendung von \lstinline!FUN! ergeben (s.\ Abschn.\ \ref{sec:tapply} für \lstinline!tapply()!).
\begin{lstlisting}
> fac1 <- factor(rep(LETTERS[1:3], each=5))
> vec  <- rnorm(30, rep(c(10, 5, 15), each=5), 3)
> reorder(fac1, vec, FUN=mean)
[1] A A A A A B B B B B C C C C C
Levels: B < A < C

# Kontrolle: Mittelwerte pro Gruppe
> tapply(vec, fac1, FUN=mean)
       A        B         C
10.18135  6.47932  13.50108
\end{lstlisting}

Alternativ ist es mit \lstinline!fct_relevel(<<Faktor>>, "<<Stufe>>", after=<<Position>>)!\index[func]{fct_revel()@\lstinline{fct_relevel()}} möglich, die Position von Faktorstufen beliebig zu kontrollieren.
\begin{lstlisting}
> fct_relevel(fac1, "A", after=1)   # verschiebe Stufe A an 2. Position
 [1] A A A A A A A A A A B B B B B B B B B B C C C C C C C C C C
Levels: B A C

> fct_relevel(fac1, "A", after=Inf)  # verschiebe Stufe A ans Ende
 [1] A A A A A A A A A A B B B B B B B B B B C C C C C C C C C C
Levels: B C A
\end{lstlisting}

Beim Sortieren von Faktoren wird die Reihenfolge der Elemente durch die Reihenfolge der Faktorstufen bestimmt, die nicht mit der numerischen oder alphabetischen Reihenfolge der Stufenbezeichnungen übereinstimmen muss. Damit kann das Sortieren eines Faktors zu einem anderen Ergebnis führen als das Sortieren eines Vektors, auch wenn dieser oberflächlich dieselben Elemente enthält.
\begin{lstlisting}
> (fac2 <- factor(sample(1:2, 10, replace=TRUE), labels=c("B", "A")))
[1] A A A B B A B B B B
Levels: B A

> sort(fac2)
[1] B B B B B B A A A A

> sort(as.character(fac2))
[1] "A" "A" "A" "A" "B" "B" "B" "B" "B" "B"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Faktoren nach Muster erstellen}
\label{sec:glExpandGrid}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Wenn Faktoren bei der Einteilung von Beobachtungsobjekten in Gruppen nach festem Muster erstellt werden müssen, lassen sie sich als Alternative zur manuellen Anwendung von \lstinline!rep()! und \lstinline!factor()! mit\index[func]{gl()@\lstinline{gl()}} \lstinline!gl()! erzeugen.
\begin{lstlisting}
gl(n=<<Stufen>>, k=<<Zellbesetzung>>, labels=1:n, ordered=FALSE)
\end{lstlisting}

Das Argument \lstinline!n! gibt die Anzahl der Stufen an, die der Faktor besitzen soll. Mit \lstinline!k! wird festgelegt, wie häufig jede Faktorstufe realisiert werden soll, wie viele Beobachtungen also jede Bedingung umfasst. Für \lstinline!labels! kann ein Vektor mit so vielen Gruppenbezeichnungen angegeben werden, wie Stufen vorhanden sind. In der Voreinstellung werden die Gruppen numeriert. Um einen geordneten Faktor zu erstellen, ist \lstinline!ordered=TRUE! zu setzen.
\begin{lstlisting}
> (fac1 <- factor(rep(c("A", "B"), times=c(5, 5))))         # manuell
[1] A A A A A B B B B B
Levels: A B

> (fac2 <- gl(2, 5, labels=c("less", "more"), ordered=TRUE))
[1] less less less less less more more more more more
Levels: less < more
\end{lstlisting}

Bei mehreren Faktoren mit vollständig gekreuzten Faktorstufen kann \lstinline!expand.grid()!\index[func]{expand.grid()@\lstinline{expand.grid()}} verwendet werden, um alle Stufenkombinationen zu erstellen (Abschn.\ \ref{sec:combinatorics}). Dabei ist die angestrebte Gruppenbesetzung pro Zelle nur bei einem der hier im Aufruf durch \lstinline!gl()! erstellten Faktoren anzugeben, beim anderen ist sie auf $1$ zu setzen. Das Ergebnis ist ein Datensatz (Abschn.\ \ref{sec:dataframe}).
\begin{lstlisting}
> expand.grid(IV1=gl(2, 2, labels=c("a", "b")), IV2=gl(3, 1))
   IV1  IV2
1    a    1
2    a    1
3    b    1
4    b    1
5    a    2
6    a    2
7    b    2
8    b    2
9    a    3
10   a    3
11   b    3
12   b    3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantitative in kategoriale Variablen umwandeln}
\label{sec:cut}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!diskretisieren}
\index[func]{cut()@\lstinline{cut()}}
Aus den in einem Vektor gespeicherten Werten einer quantitativen Variable lässt sich mit \lstinline!cut()! ein Gruppierungsfaktor erstellen -- die quantitative Variable wird so in eine kategoriale umgewandelt (s.\ auch Abschn.\ \ref{sec:discretize}). Dazu muss zunächst der Wertebereich des Vektors in disjunkte Intervalle eingeteilt werden. Die einzelnen Werte werden dann entsprechend ihrer Zugehörigkeit zu diesen Intervallen Kategorien zugeordnet und erhalten als Wert die zugehörige Faktorstufe.
\begin{lstlisting}
cut(x=<<Vektor>>, breaks=<<Intervalle>>, labels=<<Bezeichnungen>>,
    right=TRUE, ordered=FALSE)
\end{lstlisting}

Die Intervalle werden über das Argument \lstinline!breaks! festgelegt. Hier ist entweder die Anzahl der (dann gleich breiten) Intervalle anzugeben, oder die Intervallgrenzen selbst als Vektor. Die Intervalle werden in der Voreinstellung \lstinline!right=TRUE! in der Form $(a, b\,]$ gebildet, sind also nach unten offen und nach oben geschlossen. Anders gesagt ist die untere Grenze nicht Teil des Intervalls, die obere schon. Dagegen erzeugt \lstinline!right=FALSE! Intervalle der Form $[a, b)$. Die Unter- und Obergrenze des insgesamt möglichen Wertebereichs müssen bei der Angabe von \lstinline!breaks! berücksichtigt werden, ggf.\ sind dies \lstinline!-Inf! und \lstinline!Inf! für negativ und positiv unendliche Werte.

Wenn die Faktorstufen andere Namen als die zugehörigen Intervallgrenzen tragen sollen, können sie über das Argument \lstinline!labels! explizit angegeben werden. Dabei ist darauf zu achten, dass die Reihenfolge der neuen Benennungen der Reihenfolge der gebildeten Intervalle entspricht. Soll es sich im Ergebnis um einen geordneten Faktor handeln, ist \lstinline!ordered=TRUE! zu setzen.
\begin{lstlisting}
> IQ    <- rnorm(100, mean=100, sd=15)
> IQfac <- cut(IQ, breaks=c(0, 85, 115, Inf),
+              labels=c("lo", "mid", "hi"))

> IQfac[1:5]
[1] hi lo mid mid mid lo
Levels: lo mid hi
\end{lstlisting}

\index{Daten!Median-Split}
Um annähernd gleich große Gruppen zu erhalten, können für die Intervallgrenzen bestimmte Quantile der Daten gewählt werden, etwa der Median für den Median-Split (Abschn.\ \ref{sec:mean}).
\begin{lstlisting}
> medSplit <- cut(IQ, breaks=c(-Inf, median(IQ), Inf))
> summary(medSplit)           # Kontrolle: Häufigkeiten der Kategorien
medSplit
(-Inf,97.6]  (97.6,Inf]
         50          50
\end{lstlisting}

Für mehr als zwei etwa gleich große Gruppen lässt sich die Ausgabe von \lstinline!quantile()! (Abschn.\ \ref{sec:quantile}) direkt an das Argument \lstinline!breaks! übergeben. Dies ist möglich, da \lstinline!quantile()! neben den Quantilen auch das Minimum und Maximum der Werte ausgibt. Damit das unterste Intervall auch das Minimum einschließt -- und nicht wie alle übrigen Intervalle nach unten offen ist, muss das Argument \lstinline!include.lowest=TRUE! gesetzt werden.
\begin{lstlisting}
# 4 ähnliche große Gruppen, unterstes Intervall unten geschlossen
> IQdiscr <- cut(IQ, quantile(IQ), include.lowest=TRUE)
> summary(IQdiscr)            # Kontrolle: Häufigkeiten der Kategorien
IQdiscr
[62.1,87.1]  (87.1,97.6]  (97.6,107]  (107,154]
         25           25          25         25
\end{lstlisting}

Anstelle von \lstinline!cut()! können auch Funktionen aus dem Paket \lstinline!santoku!\index[pack]{santoku@\lstinline{santoku}} \cite{HughJones2024} verwendet werden, das für viele Aufgaben spezialisierte Lösungen anbietet.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Deskriptive Kennwerte numerischer Daten}
\label{sec:descriptive}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{deskriptive Kennwerte|see{Daten}}
\index{Daten!Kennwerte}
Die deskriptive Beschreibung von Variablen ist ein wichtiger Teil der Analyse empirischer Daten, die gemeinsam mit der grafischen Darstellung (Abschn.\ \ref{sec:distDiag}) hilft, ihre Struktur besser zu verstehen. Die hier umgesetzten statistischen Konzepte und Techniken werden als bekannt vorausgesetzt und finden sich in vielen Lehrbüchern der Statistik \cite{Eid2010}.

R stellt für die Berechnung aller gängigen Kennwerte separate Funktionen bereit, die meist erwarten, dass die Daten in Vektoren gespeichert sind.\footnote{Viele von ihnen werden in \index[func]{Desc()@\lstinline{Desc()}} \lstinline!Desc()! aus dem Paket\index[pack]{DescTools@\lstinline{DescTools}} \lstinline!DescTools! integriert.} Es sei an dieser Stelle daran erinnert, dass sich logische Wahrheitswerte ebenfalls in einem numerischen Kontext verwenden lassen, wobei der Wert \lstinline!TRUE! wie eine $1$, der Wert \lstinline!FALSE! wie eine $0$ behandelt wird.

Mit \lstinline!summary(<<Vektor>>)!\index[func]{summary()@\lstinline{summary()}} können die wichtigsten deskriptiven Kennwerte einer Datenreihe abgerufen werden -- dies sind Minimum, erstes Quartil, Median, Mittelwert, drittes Quartil und Maximum. Die Ausgabe ist ein Vektor mit benannten Elementen.
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> summary(age)
 Min.  1st Qu.  Median   Mean  3rd Qu.   Max.
17.00    21.50   24.00  24.33    28.75  30.00
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Summen, Differenzen und Produkte}
\label{sec:sum}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Summe}
\index{kumulierte Summe|see{Summe}}
\index[func]{sum()@\lstinline{sum()}}
\index[func]{cumsum()@\lstinline{cumsum()}}
Mit \lstinline!sum(<<Vektor>>)! wird die Summe aller Elemente eines Vektors berechnet. Die kumulierte Summe erhält man mit \lstinline!cumsum(<<Vektor>>)!.
\begin{lstlisting}
> sum(age)
[1] 146

> cumsum(age)
[1] 17 47 77 102 125 146
\end{lstlisting}

\index{Differenzen}
\index[func]{diff()@\lstinline{diff()}}
Um die Differenzen aufeinander folgender Elemente eines Vektors (also eines Wertes zu einem Vorgänger) zu berechnen, kann die Funktion \lstinline!diff(<<Vektor>>, lag=1)! verwendet werden. Mit ihrem Argument \lstinline!lag! wird kontrolliert, über welchen Abstand die Differenz gebildet wird. Die Voreinstellung \lstinline!1! bewirkt, dass die Differenz eines Wertes zum unmittelbar vorhergehenden berechnet wird. Die Ausgabe umfasst \lstinline!lag! Werte weniger, als der Vektor Elemente besitzt.
\begin{lstlisting}
> diff(age)
[1] 13 0 -5 -2 -2

> diff(age, lag=2)
[1] 13 -5 -7 -4
\end{lstlisting}

\index{Produkt}
\index{kumuliertes Produkt|see{Produkt}}
\index{Fakultat@Fakultät}
\index[func]{prod()@\lstinline{prod()}}
\index[func]{cumprod()@\lstinline{cumprod()}}
Das Produkt aller Elemente eines Vektors wird mit \lstinline!prod(<<Vektor>>)! berechnet, das kumulierte Produkt mit \lstinline!cumprod(<<Vektor>>)!.\footnote{\label{ftn:cumProd}Bei Gleitkommazahlen kumulieren sich bei wiederholter Multiplikation Rundungsfehler, die durch die interne Darstellungsart solcher Zahlen unvermeidlich sind (Abschn.\ \ref{sec:isTRUE}). Numerisch stabiler als \lstinline!prod(<<Vektor>>)! ist deswegen u.\,U.\ die Rücktransformation der Summe der logarithmierten Werte mit \lstinline!exp(sum(log(<<Vektor>>)))! als Umsetzung von $\exp\left(\sum_{i}{\ln x_{i}}\right)$ -- vorausgesetzt $x$ ist echt positiv. \lstinline!prod(numeric(0))! ist gleich \lstinline!1!.} \lstinline!factorial(<<Zahl>>)!\index[func]{factorial()@\lstinline{factorial()}} ermittelt die Fakultät $n!$ einer Zahl $n$.\footnote{Für natürliche Zahlen gilt\index{Gamma-Funktion@$\Gamma$-Funktion} $n! = \Gamma(n+1)$, in R als \lstinline!gamma(<<Zahl>> + 1)!\index[func]{gamma()@\lstinline{gamma()}} berechenbar.}
\begin{lstlisting}
> prod(age)
[1] 184747500

> cumprod(age)
[1] 17 510 15300 382500 8797500 184747500

> factorial(5)
[1] 120
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Extremwerte}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Extremwerte}
\index{Minimum}
\index{Maximum}
\index[func]{min()@\lstinline{min()}}
\index[func]{max()@\lstinline{max()}}
Mit \lstinline!min(<<Vektor>>)! und \lstinline!max(<<Vektor>>)! können die Extremwerte eines Vektors erfragt werden. \lstinline!range(<<Vektor>>)!\index[func]{range()@\lstinline{range()}} gibt den größten und kleinsten Wert zusammengefasst als Vektor aus.
\begin{lstlisting}
> max(age)                      # Maximum
[1] 30

> range(c(17, 30, 30, 25, 23, 21))
[1] 17 30
\end{lstlisting}

Den Index des größten bzw.\ kleinsten Wertes liefern\index[func]{which.max()@\lstinline{which.max()}} \lstinline!which.max(<<Vektor>>)!\index[func]{which.min()@\lstinline{which.min()}} bzw.\ \lstinline!which.min(<<Vektor>>)!. Kommt der größte bzw.\ kleinste Wert mehrfach vor, ist das Ergebnis seine früheste Position. \lstinline!which.min()! lässt sich etwa nutzen, um herauszufinden, welches Element eines Vektors am nächsten an einem vorgegebenen Wert liegt.
\begin{lstlisting}
> which.min(age)              # Position des Minimums
[1] 1

> vec <- c(-5, -8, -2, 10, 9) # Vektor
> which.max(vec > 0)          # Index erstes Element größer 0
[1] 4

# Index des ersten Elements, das nicht in Zielmenge ist
> which.min(vec %in% c(-5, 10))
[1] 2

> val <- 0                    # Referenzwert
> which.min(abs(vec-val))     # welches Element liegt am nächsten an 0?
[1] 3
\end{lstlisting}

\index{range}
\index{Spannweite|see{range}}
Um die Spannweite (\emph{range}) von Werten eines Vektors, also die Differenz vom kleinsten und größten Wert zu ermitteln, ist \lstinline!diff()! nützlich.
\begin{lstlisting}
> diff(range(c(17, 30, 30, 25, 23, 21)))
[1] 13
\end{lstlisting}

Die Funktionen\index[func]{pmin()@\lstinline{pmin()}} \lstinline!pmin(<<Vektor1>>, <<Vektor2>>, ...)! und\index[func]{pmax()@\lstinline{pmax()}} \lstinline!pmax(<<Vektor1>>, <<Vektor2>>, ...)! vergleichen zwei oder mehr Vektoren elementweise hinsichtlich der Größe der in ihnen gespeicherten Werte. Sie liefern einen Vektor aus den pro Position größten bzw.\ kleinsten Werten zurück.
\begin{lstlisting}
> vec1 <- c(5, 2, 0, 7)
> vec2 <- c(3, 3, 9, 2)
> pmax(vec1, vec2)
[1] 5 3 9 7

> pmin(vec1, vec2)
[1] 3 2 0 2
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mittelwert, Median und Modalwert}
\label{sec:mean}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Mittelwert}
\index[func]{mean()@\lstinline{mean()}}
Mit \lstinline!mean(x=<<Vektor>>)! wird das arithmetische Mittel $\frac{1}{n} \sum_{i}{x_{i}}$ eines Vektors $\bm{x}$ der Länge $n$ berechnet.\footnote{Hier ist zu beachten, dass \lstinline!x! tatsächlich ein etwa mit \lstinline!c(...)! gebildeter Vektor ist: Der Aufruf \lstinline!mean(1, 7, 3)! gibt anders als \lstinline!mean(c(1, 7, 3))! nicht den Mittelwert der Daten $1, 7, 3$ aus. Stattdessen ist die Ausgabe gleich dem ersten übergebenen Argument.}
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> mean(age)
[1] 24.33333
\end{lstlisting}

Für die Berechnung eines gewichteten Mittels, bei dem die Gewichte nicht wie bei \lstinline!mean()! für alle Werte identisch sind ($\frac{1}{n}$), eignet sich die Funktion\index[func]{weighted.mean()@\lstinline{weighted.mean()}} \lstinline!weighted.mean(x=<<Vektor>>, w=<<Gewichte>>)!. Ihr zweites Argument \lstinline!w! muss ein Vektor derselben Länge wie \lstinline!x! sein und die Gewichte benennen. Der Einfluss jedes Wertes auf den Mittelwert ist gleich dem Verhältnis seines Gewichts zur Summe aller Gewichte.
\begin{lstlisting}
> weights <- c(0.6, 0.6, 0.3, 0.2, 0.4, 0.6)
> weighted.mean(age, w=weights)
[1] 23.70370
\end{lstlisting}

\index{Mittelwert!geometrischer}
\index{Mittelwert!harmonischer}
Um beim geometrischen Mittel $\frac{1}{n} \prod_{i}{x_{i}}$ sich fortsetzende Rundungsfehler zu vermeiden, eignet sich für echt positive $x_{i}$ \lstinline!exp(mean(log(x)))! als Umsetzung von $\euler^{\frac{1}{n} \sum_{i}{\ln x_{i}}}$ (Fußnote \ref{ftn:cumProd}). Das harmonische Mittel $n / \sum_{i}{\frac{1}{x_{i}}}$ berechnet sich als Kehrwert des Mittelwertes der Kehrwerte (für $x_{i} \neq 0$), also mit \lstinline!1 / mean(1/x)!. Alternativ stellt das Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} die Funktionen \lstinline!Gmean()!\index[func]{Gmean()@\lstinline{Gmean()}} und \lstinline!Hmean()!\index[func]{Hmean()@\lstinline{Hmean()}} bereit.

\index{Median}
\index[func]{median()@\lstinline{median()}}
\lstinline!median(x=<<Vektor>>)! gibt den Median, also das $50\%$-Quantil einer empirischen Verteilung aus. Dies ist der Wert, für den die empirische kumulative Häufigkeitsverteilung von \lstinline!x! erstmalig mindestens den Wert $0.5$ erreicht (Abschn.\ \ref{sec:stepfun}), der also $\geq 50\%$ (und $\leq 50\%$) der Werte ist. Im Fall einer geraden Anzahl von Elementen in \lstinline!x! wird zwischen den beiden mittleren Werten von \lstinline!sort(<<Vektor>>)! gemittelt, andernfalls das mittlere Element von \lstinline!sort(<<Vektor>>)! ausgegeben.
\begin{lstlisting}
> sort(age)
[1] 17 21 23 25 30 30

> median(age)
[1] 24

> ageNew <- c(age, 22)
> sort(ageNew)
[1] 17 21 22 23 25 30 30

> median(ageNew)
[1] 23
\end{lstlisting}

\index{Modalwert}
Für die Berechnung des Modalwertes, also des in einem Vektor am häufigsten vorkommenden Wertes, stellt der Basisumfang von R keine separate Funktion bereit. Es kann aber auf die Funktion \lstinline!Mode(<<Vektor>>)!\index[func]{Mode()@\lstinline{Mode()}} aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} ausgewichen werden.
\begin{lstlisting}
> vec <- c(11, 22, 22, 33, 33, 33, 33)      # häufigster Wert: 33
> library(DescTools)                        # für Mode()
> Mode(vec)
[1] 33
attr(,"freq")
[1] 4
\end{lstlisting}

Eine manuelle Alternative bietet \lstinline!table()! zur Erstellung von Häufigkeitstabellen (Abschn.\ \ref{sec:table}). Die folgende Methode gibt zunächst den Index des Maximums der Häufigkeitstabelle aus. Den Modalwert erhält man zusammen mit seiner Auftretenshäufigkeit durch Indizieren der mit \lstinline!unique()! gebildeten und dann geordneten Einzelwerte des Vektors mit diesem Index.
\begin{lstlisting}
> (tab <- table(vec))                       # Häufigkeitstabelle
vec
11  22  33
 1   2   4

> (modIdx <- which.max(tab))                # Index des Modalwerts
33
 3

> sort(unique(vec))[modIdx]                 # Modalwert selbst
[1] 33
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Robuste Maße der zentralen Tendenz}
\label{sec:meanRob}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{robuste Verfahren!zentrale Tendenz}
Wenn Daten Ausreißer aufweisen, kann dies den Mittelwert stark verzerren, so dass er die Lage der zugrundeliegenden Variable nicht mehr gut repräsentiert. Aus diesem Grund existieren Maße der zentralen Tendenz, die weniger stark durch einzelne extreme Werte beeinflusst werden.

\index{Mittelwert!gestutzter}
Der gestutzte Mittelwert wird ohne einen bestimmten Anteil an Extremwerten berechnet. Mit \lstinline!mean(<<Vektor>>, trim=<<Anteil>>)! wird der gewünschte Anteil an Extremwerten auf beiden Seiten der empirischen Verteilung aus der Berechnung des Mittelwerts ausgeschlossen. Um etwa den Mittelwert ohne die extremen $5\%$ der Daten zu berechnen, ist \lstinline!trim=0.025! zu setzen.
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> mean(age)                                 # Vergleich: Mittelwert
[1] 24.33333

> mean(age, trim=0.2)                       # gestutzter Mittelwert
[1] 24.75
\end{lstlisting}

\index{Mittelwert!winsorisierter}
\index{Daten!winsorisieren}
Bei der Winsorisierung von Daten mit \lstinline!Winsorize()!\index[func]{Winsorize()@\lstinline{Winsorize()}} aus dem Paket \lstinline!DescTools! wird ein bestimmter Anteil an Extremwerten auf beiden Seiten der empirischen Verteilung durch jeweils den letzten Wert ersetzt, der noch nicht als Extremwert gilt. Dafür legt das Argument \lstinline!probs! in Form eines Vektors die beiden Quantile als Grenzen fest. Der übliche Mittelwert dieser Daten ist dann der winsorisierte Mittelwert.
\begin{lstlisting}
> library(DescTools)                              # für Winsorize()
> (ageWins <- Winsorize(age, probs=c(0.2, 0.8)))  # winsorisierte Daten
[1] 21 30 30 25 23 21

> mean(ageWins)                                   # winsor. Mittelwert
[1] 25
\end{lstlisting}

\index{Hodges-Lehmann-Schatzer@Hodges-Lehmann-Schätzer}
\index{Pseudo-Median}
\index{Median!Pseudo-Median}
Der Hodges-Lehmann-Schätzer des Lageparameters einer Variable (\emph{Pseudo-Median}) berechnet sich als Median der $n (n+1) / 2$ vielen Walsh-Mittel -- der Mittelwerte aller Wertepaare $(x_{i}, x_{j})$ der Daten mit sich selbst (mit $j \geq i$). Vergleiche hierfür \index[func]{HodgesLehmann()@\lstinline{HodgesLehmann()}} \lstinline!HodgesLehmann()! aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} sowie \lstinline!wilcox.test()! in Abschn.\ \ref{sec:wilcoxSignRank}.
\begin{lstlisting}
> library(DescTools)                              # für HodgesLehmann()
> HodgesLehmann(age)
est
24

# manuelle Kontrolle -> Mittelwert aller Wertepaare
> pairM <- outer(age, age, FUN="+") / 2
> median(pairM[lower.tri(pairM, diag=TRUE)])      # deren Median
[1] 24
\end{lstlisting}

\index{Huber-M-Schatzer@Huber-$M$-Schätzer}
Für Huber $M$-Schätzer der Lage von Verteilungen existiert \lstinline!huberM()!\index[func]{huberM()@\lstinline{huberM()}} aus dem Paket \lstinline!robustbase!\index[pack]{robustbase@\lstinline{robustbase}|textbf} \cite{Rousseeuw2009}. Als Schätzer für die Differenz der Lageparameter von zwei Variablen wird der Hodges-Lehmann-Schätzer als Median aller $n_{1} \cdot n_{2}$ paarweisen Differenzen der Werte aus beiden Datenreihen gebildet (Abschn.\ \ref{sec:wilcoxRankSum}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Prozentrang, Quartile und Quantile}
\label{sec:quantile}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Prozentrang}
Angewendet auf Vektoren mit logischen Werten lassen sich mit \lstinline!sum()! Elemente zählen, die eine bestimmte Bedingung erfüllen. So kann der Prozentrang eines Wertes als prozentualer Anteil derjenigen Werte ermittelt werden, die nicht größer als er sind (Abschn.\ \ref{sec:stepfun}). Die Funktion \lstinline!PercentRank()!\index[func]{PercentRank()@\lstinline{PercentRank()}} aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} gibt -- multipliziert mit 100 -- für jeden Wert eines Vektors den Prozentrang aus. Bei der dabei intern vorgenommenen Rangtransformation mit \lstinline!rank()! (Abschn.\ \ref{sec:transformRank}) werden allerdings bei Bindungen mittlere Ränge berechnet.
\begin{lstlisting}
> library(DescTools)                      # für PercentRank()
> age <- c(17, 30, 30, 25, 23, 21)
> PercentRank(age) * 100
[1] 16.66667 83.33333 83.33333 66.66667 50.00000 33.33333

# manuell
> sum(age <= 25)                          # wie viele Elemente <= 25?
[1] 4

> 100 * (sum(age <= 25) / length(age))    # Prozentrang von 25
[1] 66.66667

# Prozentrang von 30, abweichende Definition von PercentRank()
> 100 * (sum(age <= 30) / length(age))
[1] 100
\end{lstlisting}

\index{Quartil}
\index{Quantil}
\index[func]{quantile()@\lstinline{quantile()}}
Mit \lstinline!quantile(<<Vektor>>, probs=seq(0, to=1, by=0.25))! werden in der Voreinstellung die Quartile eines Vektors bestimmt. Dies sind jene Werte, die größer oder gleich einem ganzzahligen Vielfachen von $25\%$ der Datenwerte und kleiner oder gleich den Werten des verbleibenden Anteils der Daten sind. Das erste Quartil ist etwa $\geq 25\%$ (und $\leq 75\%$) der Daten. Das Ergebnis von \lstinline!quantile()! ist ein Vektor mit benannten Elementen.
\begin{lstlisting}
> (quant <- quantile(age))
   0%    25%    50%    75%   100%
17.00  21.50  24.00  28.75  30.00

> quant[c("25%", "50%")]
 25%   50%
21.5  24.0
\end{lstlisting}

Über das Argument \lstinline!probs=<<Vektor>>! können statt der Quartile auch andere Anteile angegeben werden, deren Wertegrenzen gewünscht sind. Zur Berechnung der Werte, die einen bestimmten Anteil der Daten abschneiden, wird ggf.\ zwischen den in \lstinline!x! tatsächlich vorkommenden Werten interpoliert.\footnote{\label{ftn:quantile}Zur Berechnung von Quantilen stehen verschiedene Rechenwege zur Verfügung, vgl.\ \lstinline!?quantile!. Insbesondere ist zu beachten, dass andere Statistik-Software aufgrund anderer Voreinstellungen andere Ergebnisse liefern kann.}
\begin{lstlisting}
> vec <- sample(seq(0, to=1, by=0.01), 1000, replace=TRUE)
> quantile(vec, probs=c(0, 0.2, 0.4, 0.6, 0.8, 1))
   0%    20%    40%    60%    80%   100%
0.000  0.190  0.400  0.604  0.832  1.000
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Varianz, Streuung, Schiefe und Wölbung}
\label{sec:varSd}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Varianz}
\index[func]{var()@\lstinline{var()}}
Mit \lstinline!var(<<Vektor>>)! wird die korrigierte Varianz $s^{2} = \frac{1}{n-1} \sum_{i}{(x_{i}-\bar{x})^{2}}$ zur erwartungstreuen Schätzung der Populationsvarianz auf Basis einer Variable $X$ der Länge $n$ mit Mittelwert $\bar{x}$ ermittelt.\footnote{Für ein Diversitätsmaß kategorialer Daten s.\ Abschn.\ \ref{sec:divIdx} und für robuste Varianzschätzer Abschn.\ \ref{sec:varRob}.}
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)          # Daten
> N   <- length(age)                        # Anzahl Beobachtungen
> M   <- mean(age)                          # Mittelwert

> var(age)                                  # korrigierte Varianz
[1] 26.26667

> sum((age-M)^2) / (N-1)                    # manuelle Berechnung
[1] 26.26667
\end{lstlisting}

Die Umrechnungsformel zur Berechnung der\index{Varianz!unkorrigierte} unkorrigierten Varianz $S^{2} = \frac{1}{n} \sum_{i}{(x_{i}-\bar{x})^{2}}$ aus der korrigierten lautet $S^{2} = \frac{n-1}{n} s^{2}$.\footnote{\label{ftn:covWT}Als Alternative lässt sich \lstinline!cov.wt()! verwenden (Abschn.\ \ref{sec:covMat}).}
\begin{lstlisting}
> ((N-1) / N) * var(age)                    # unkorrigierte Varianz
[1] 21.88889

> sum((age-M)^2) / N                        # manuelle Berechnung
[1] 21.88889
\end{lstlisting}

\index{Streuung}
\index[func]{sd()@\lstinline{sd()}}
Die korrigierte Streuung $s$ kann durch Ziehen der Wurzel aus der korrigierten Varianz oder mit \lstinline!sd(<<Vektor>>)! berechnet werden. Auch hier basiert das Ergebnis auf der bei der Varianz erläuterten Korrektur zur Schätzung der Populationsstreuung auf Basis einer empirischen Stichprobe.
\begin{lstlisting}
> sqrt(var(age))                            # Wurzel aus Varianz
[1] 5.125102

> sd(age)                                   # korrigierte Streuung
[1] 5.125102
\end{lstlisting}

Die Umrechnungsformel zur Berechnung der unkorrigierten Streuung $S = \sqrt{\frac{1}{n} \sum_{i}{(x_{i}-\bar{x})^{2}}}$ aus der korrigierten lautet $S = \sqrt{\frac{n-1}{n}} s$.
\begin{lstlisting}
> sqrt((N-1) / N) * sd(age)                 # unkorrigierte Streuung
[1] 4.678556

> sqrt(sum((age-M)^2) / N)                  # manuelle Berechnung
[1] 4.678556
\end{lstlisting}

\index{Schiefe}
\index{Wolbung@Wölbung}
\index{Kurtosis|see{Wölbung}}
\index[func]{Skew()@\lstinline{Skew()}}
\index[func]{Kurt()@\lstinline{Kurt()}}
Schiefe und Wölbung (Kurtosis) als höhere zentrale Momente empirischer Verteilungen lassen sich mit \lstinline!Skew()! und \lstinline!Kurt()! aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} ermitteln.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Diversität kategorialer Daten}
\label{sec:divIdx}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Diversitätsindex}
\index{Shannon-Index}
Der Diversitätsindex $H$ ist ein Streuungsmaß für kategoriale Daten, der mit Werten im Intervall $[0, 1]$ angibt, wie sehr sich die Daten auf die Kategorien verteilen. Sind $f_{j}$ die relativen Häufigkeiten der $p$ Kategorien (Abschn.\ \ref{sec:table}), ist $H = -\frac{1}{\ln p} \sum{(f_{j} \cdot \ln{f_{j}})}$. Für $f_{j} = 0$ ist $f_{j} \cdot \ln{f_{j}}$ dabei als $0$ definiert. $H$ ist genau dann $0$, wenn die Daten konstant sind, also nur eine von mehreren Kategorien auftritt. Für eine Gleichverteilung, in der alle Kategorien dieselbe Häufigkeit besitzen, die Daten also maximal verteilt sind, ist $H = 1$. R verfügt über keine spezialisierte Funktion für die Berechnung von $H$. Es lässt sich aber der Umstand nutzen, dass $H$ bis auf den Faktor $\frac{1}{\ln p}$ mit dem Shannon-Index aus der Informationstheorie übereinstimmt, der sich mit der aus dem Paket\index[pack]{DescTools@\lstinline{DescTools}} \lstinline!DescTools! stammenden Funktion\index[func]{Entropy()@\lstinline{Entropy()}} \lstinline!Entropy()! berechnen lässt. Dafür ist das Argument \lstinline!base! auf die Eulersche Zahl e = \lstinline!exp(1)! zu setzen.\footnote{Zudem gilt folgende Beziehung zur diskreten Kullback-Leibler-Divergenz $\text{KL}_{\text{eq}}$ der beobachteten Häufigkeiten zur Gleichverteilung: $H = -\frac{1}{\ln p} \text{KL}_{\text{eq}} + 1$.} Die Funktion erwartet als Argument den Vektor der absoluten oder relativen Häufigkeiten der Kategorien.
\begin{lstlisting}
# Faktor inkl. einer nicht besetzten Stufe "Q"
> fac <- factor(c("C","D","A","D","E","D","C","E","E","B","E"),
+               levels=c(LETTERS[1:5], "Q"))

> P   <- nlevels(fac)                         # Anzahl Kategorien
> (Fj <- proportions(table(fac)))             # relative Häufigkeiten
         A          B          C          D          E          Q
0.09090909 0.09090909 0.18181818 0.27272727 0.36363636 0.00000000

> library(DescTools)                          # für Entropy()
> shannonIdx <- Entropy(Fj, base=exp(1))      # Shannon Index
> (H <- (1/log(P)) * shannonIdx)              # Diversität
[1] 0.8193845

> keep <- Fj > 0                              # Indizes Häufigk. > 0
> -(1/log(P)) * sum(Fj[keep] * log(Fj[keep])) # Kontrolle ...
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kovarianz und Korrelation}
\label{sec:covCor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Kovarianz}
\index[func]{cov()@\lstinline{cov()}|textbf}
Mit \lstinline!cov(x=<<Vektor1>>, y=<<Vektor2>>)! wird die korrigierte Kovarianz $\frac{1}{n-1} \sum_{i} \left((x_{i}-\bar{x}) \cdot (y_{i}-\bar{y})\right)$ zweier Variablen $X$ und $Y$ derselben Länge $n$ berechnet.
\begin{lstlisting}
> x <- c(17, 30, 30, 25, 23, 21)            # Daten Variable 1
> y <- c(1, 12, 8, 10, 5, 3)                # Daten Variable 2
> cov(x, y)                                 # korrigierte Kovarianz
[1] 19.2

> N  <- length(x)                           # Anzahl Objekte
> Mx <- mean(x)                             # Mittelwert Var 1
> My <- mean(y)                             # Mittelwert Var 2
> sum((x-Mx) * (y-My)) / (N-1)  # korrigierte Kovarianz manuell
[1] 19.2
\end{lstlisting}

Die\index{Kovarianz!unkorrigierte} unkorrigierte Kovarianz muss nach der bereits für die Varianz genannten Umrechnungsformel ermittelt werden (Abschn.\ \ref{sec:varSd}, Fußnote \ref{ftn:covWT}).
\begin{lstlisting}
> ((N-1) / N) * cov(x, y)       # unkorrig. Kovarianz aus korrigierter
[1] 16

> sum((x-Mx) * (y-My)) / N      # unkorrigierte Kovarianz manuell
[1] 16
\end{lstlisting}

Neben der voreingestellten Berechnungsmethode für die Kovarianz nach Pearson kann auch die Rang-Kovarianz nach Spearman oder Kendall berechnet werden (Abschn.\ \ref{sec:rhoTau}).

\index{Korrelation}
\index{Zusammenhangsmasse@Zusammenhangsmaße!Korrelation}
\index{Rangkorrelation|see{Korrelation}}
\index[func]{cor()@\lstinline{cor()}|textbf}
Analog zur Kovarianz kann mit \lstinline!cor(x=<<Vektor1>>, y=<<Vektor2>>)! die herkömmliche Pearson Korrelation $r_{XY} = \frac{\text{Kov}_{XY}}{s_{X} \cdot s_{Y}}$ oder die Rangkorrelation berechnet werden.\footnote{\label{ftn:polycor}Das Paket \lstinline!correlation!\index[pack]{correlation@\lstinline{correlation}} \cite{Makowski2024} berechnet neben der polychorischen\index{Korrelation!polychorische} und polyserialen\index{Korrelation!polyseriale} Korrelation zur Schätzung der latenten Korrelation von künstlich in Kategorien eingeteilten Variablen auch viele weitere Varianten. Für die multiple Korrelation i.\,S.\ der Wurzel aus dem Determinationskoeffizienten $R^{2}$ in der multiplen linearen Regression s.\ Abschn.\ \ref{sec:regrAnalysis}. Die\index{Korrelation!kanonische} kanonische Korrelation zweier Gruppen von Variablen, die an denselben Beobachtungsobjekten erhoben wurden, ermittelt\index[func]{cancor()@\lstinline{cancor()}} \lstinline!cancor()!.} Für die Korrelation gibt es keinen Unterschied beim Gebrauch von korrigierten und unkorrigierten Streuungen, so dass sich nur ein Kennwert ergibt.
\begin{lstlisting}
> cor(x, y)                     # Korrelation
[1] 0.8854667

> cov(x, y) / (sd(x) * sd(y))   # manuelle Berechnung
[1] 0.8854667
\end{lstlisting}

\index{Korrelation!Partialkorrelation}
\index{Partialkorrelation|see{Korrelation}}
Für die Berechnung der Partialkorrelation zweier Variablen $X$ und $Y$ ohne eine dritte Variable $Z$ kann die Formel $r_{(XY).Z} = \frac{r_{XY} - (r_{XZ} \cdot r_{YZ})}{\sqrt{(1-r_{XZ}^{2}) \cdot (1-r_{YZ}^{2})}}$ umgesetzt werden, da die Basisinstallation von R hierfür keine eigene Funktion bereitstellt.\footnote{Wohl aber das Paket\index[pack]{correlation@\lstinline{correlation}} \lstinline!correlation!.} Für eine alternative Berechnungsmethode, die sich die Eigenschaft der Partialkorrelation als Korrelation der Residuen der Regressionen von $X$ auf $Z$ und $Y$ auf $Z$ zunutze macht, s.\ Abschn.\ \ref{sec:partCorReg}.
\begin{lstlisting}
> NN <- 100
> zz <- runif(NN)
> xx <- zz + rnorm(NN, 0, 0.5)
> yy <- zz + rnorm(NN, 0, 0.5)
> (cor(xx, yy) - (cor(xx, zz)*cor(yy, zz))) /
+      sqrt((1-cor(xx, zz)^2) * (1-cor(yy, zz)^2))
[1] 0.0753442
\end{lstlisting}

\index{Korrelation!Semipartialkorrelation}
\index{Semipartialkorrelation|see{Korrelation}}
Die Semipartialkorrelation einer Variable $Y$ mit einer Variable $X$ ohne eine dritte Variable $Z$ unterscheidet sich von der Partialkorrelation dadurch, dass nur von $X$ der i.\,S.\ der linearen Regression durch $Z$ aufklärbare Varianzanteil auspartialisiert wird, nicht aber von $Y$. Die Semipartialkorrelation berechnet sich durch $r_{(X.Z)Y} = \frac{r_{XY} - (r_{XZ} \cdot r_{YZ})}{\sqrt{1-r_{XZ}^{2}}}$, oder als Korrelation von $Y$ mit den Residuen der Regression von $X$ auf $Z$ (Abschn.\ \ref{sec:partCorReg}).
\begin{lstlisting}
> (cor(xx, yy) - (cor(xx, zz) * cor(yy, zz))) / sqrt(1-cor(xx, zz)^2)
[1] 0.06275869
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Robuste Streuungsmaße und Kovarianzschätzer}
\label{sec:varRob}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{robuste Verfahren!Streuungsmaße}
Ausreißer können gewöhnliche Streuungen und Kovarianzen in dem Sinne stark verzerren, dass sie nicht mehr gut die Eigenschaften der zugrundeliegenden Verteilung der beteiligten Variablen repräsentieren. Aus diesem Grund existieren Streuungsmaße und Kovarianzschätzer, die weniger stark durch einzelne extreme Werte beeinflusst werden.

\index{Interquartilabstand}
\index[func]{IQR()@\lstinline{IQR()}}
Mit \lstinline!IQR(<<Vektor>>)! wird der Interquartilabstand erfragt, also die Differenz vom dritten und ersten Quartil.
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> sd(age)                     # Vergleich: gewöhnliche Streuung
[1] 5.125102

> quantile(age)               # Quartile
   0%     25%   50%    75%   100%
17.00  21.50  24.00  28.75  30.00

> IQR(age)                    # Interquartilabstand
[1] 7.25
\end{lstlisting}

\index[func]{mad()@\lstinline{mad()}}
Die mittlere absolute Abweichung vom Mittelwert oder Median ist manuell oder über\index[func]{MeanAD()@\lstinline{MeanAD()}} \lstinline!MeanAD()! aus dem Paket\index[pack]{DescTools@\lstinline{DescTools}} \lstinline!DescTools! zu berechnen. Dagegen steht für den Median der absoluten Abweichungen vom Median \lstinline!mad(<<Vektor>>)! bereit.\footnote{Die Funktion multipliziert den eigentlichen Median der absoluten Abweichungen mit dem Faktor $1.4826$, der über das Argument \lstinline!constant! auf einen anderen Wert gesetzt werden kann. Der Faktor ist so gewählt, dass der Kennwert bei normalverteilten Variablen asymptotisch mit der Streuung übereinstimmt, da für standardnormalverteilte Variablen $X$ gilt: $E(\text{MAD}(X)) = 0.6745 = \frac{1}{1.4826}$.}
\begin{lstlisting}
> mean(abs(age - mean(age)))  # mittlere abs. Abweichung vom Mittelwert
[1] 4

> mean(abs(age-median(age)))  # mittlere absolute Abweichung vom Median
[1] 4

> mad(age)                    # Median der abs. Abweichungen vom Median
[1] 6.6717
\end{lstlisting}

\index{Varianz!winsorisierte}
Bei der Winsorisierung von Daten mit \lstinline!Winsorize()!\index[func]{Winsorize()@\lstinline{Winsorize()}} aus dem Paket \lstinline!DescTools! wird ein bestimmter Anteil an Extremwerten auf beiden Seiten der Verteilung durch jeweils den letzten Wert ersetzt, der noch nicht als Extremwert gilt. Dafür legt das Argument \lstinline!probs! in Form eines Vektors die beiden Quantile als Grenzen fest. Die übliche Varianz dieser Daten ist dann die winsorisierte Varianz.
\begin{lstlisting}
> library(DescTools)                            # für Winsorize()
> ageWins <- Winsorize(age, probs=c(0.2, 0.8)   # winsorisierte Daten
> var(ageWins)                                  # winsorisierte Varianz
[1] 17.2
\end{lstlisting}

\index{Kovarianz!robuste Schätzer}
\index{robuste Verfahren!Kovarianzschätzer}
Weitere robuste Streuungsschätzer stellt das Paket \lstinline!robustbase!\index[pack]{robustbase@\lstinline{robustbase}} mit \index[func]{Sn()@\lstinline{Sn()}} \lstinline!Sn()!, \index[func]{Qn()@\lstinline{Qn()}} \lstinline!Qn()! und \index[func]{scaleTau2()@\lstinline{scaleTau2()}} \lstinline!scaleTau2()! bereit. Für robuste Schätzer einer theoretischen Kovarianzmatrix vgl.\ \lstinline!covOGK()!\index[func]{covOGK()@\lstinline{covOGK()}} und\index[func]{covMcd()@\lstinline{covMcd()}} \lstinline!covMcd()! aus demselben Paket. Die mittlere absolute Differenz nach Gini kann mit \index[func]{GiniMd()@\lstinline{GiniMd()}} \lstinline!GiniMd()! aus dem Paket \lstinline!rms!\index[pack]{rms@\lstinline{rms}|textbf} \cite{HarrellJr2009} ermittelt werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kennwerte getrennt nach Gruppen berechnen}
\label{sec:tapply}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Funktion!getrennt nach Gruppen anwenden}
\index{Daten!getrennt nach Gruppen auswerten}
Oft sind die Werte einer in verschiedenen Bedingungen erhobenen Variable in einem Vektor \lstinline!x! gespeichert, wobei sich die zu jedem Wert gehörende Beobachtungsbedingung aus einem Faktor oder der Kombination mehrerer Faktoren ergibt. Jeder Faktor besitzt dabei dieselbe Länge wie \lstinline!x! und codiert die Zugehörigkeit der Beobachtungen in \lstinline!x! zu den Stufen einer Gruppierungsvariable. Dabei müssen nicht für jede Bedingung auch gleich viele Beobachtungen vorliegen.

Sollen Kennwerte von \lstinline!x! jeweils getrennt für jede Bedingung bzw.\ Kombination von Bedingungen berechnet werden, können\index[func]{ave()@\lstinline{ave()}} \lstinline!ave()! und\index[func]{tapply()@\lstinline{tapply()}} \lstinline!tapply()! herangezogen werden.\footnote{Abschnitte \ref{sec:aggregate} und \ref{sec:dplyr_aggregate} illustrieren das analoge Vorgehen in Situationen, wenn die Variablen Teil eines Datensatzes sind.}
\begin{lstlisting}
ave(x=<<Vektor>>, <<Faktor1>>, <<Faktor2>>, ..., FUN=<<Funktion>>)
tapply(X=<<Vektor>>, INDEX=<<Liste mit Faktoren>>, FUN=<<Funktion>>, ...)
\end{lstlisting}

Als Argumente werden neben dem zuerst zu nennenden Datenvektor die Faktoren übergeben. Bei \lstinline!ave()! geschieht dies einfach in Form mehrerer durch Komma getrennter Gruppierungsfaktoren. Bei \lstinline!tapply()! müssen die Faktoren in einer Liste zusammengefasst werden, deren Komponenten die einzelnen Faktoren sind (Abschn.\ \ref{sec:list}). Mit dem Argument \lstinline!FUN! wird schließlich die pro Gruppe auf die Daten anzuwendende Funktion angegeben. Der Argumentname \lstinline!FUN! ist bei \lstinline!ave()! immer zu nennen, andernfalls wäre nicht ersichtlich, dass kein weiterer Faktor gemeint ist. In der Voreinstellung von \lstinline!ave()! wird \lstinline!mean()! angewendet.

In der Ausgabe von \lstinline!ave()! wird jeder Einzelwert von \lstinline!x! durch den für die entsprechende Gruppe berechneten Kennwert ersetzt, was etwa in der Berechnung von Quadratsummen linearer Modelle Anwendung finden kann (Abschn.\ \ref{sec:contrCRp}).

Im Beispiel sei ein IQ-Test mit Personen durchgeführt worden, die aus einer Treatment- (\lstinline!T!), Wartelisten- (\lstinline!WL!) oder Kontrollgruppe (\lstinline!CG!) stammen. Weiterhin sei das Geschlecht als Faktor berücksichtigt worden.
\begin{lstlisting}
> Njk   <- 2                            # Zellbesetzung
> P     <- 2                            # Anzahl Stufen Geschlecht
> Q     <- 3                            # Anzahl Stufen Treatment
> sex   <- factor(rep(c("f", "m"), times=Q*Njk))
> group <- factor(rep(c("T", "WL", "CG"), each=P*Njk))
> table(sex, group)                     # Zellbesetzungen
       group
sex  CG  T  WL
  f   2  2   2
  m   2  2   2

> IQ <- round(rnorm(Njk*P*Q, mean=100, sd=15))
> ave(IQ, sex, FUN=mean)                # Mittelwerte nach Geschlecht
[1] 96.83333 100.33333 96.83333 100.33333 96.83333 100.33333 96.83333
[8] 100.33333 96.83333 100.33333 96.83333 100.33333
\end{lstlisting}

\index{Mittelwertstabelle}
Die Ausgabe von \lstinline!tapply()! dient der Übersicht über die gruppenweise berechneten Kennwerte, wobei das Ergebnis ein Objekt der Klasse \lstinline!array! ist (Abschn.\ \ref{sec:array}). Bei einem einzelnen Gruppierungsfaktor ist dies einem benannten Vektor ähnlich und bei zweien einer zweidimensionalen Kreuztabelle (Abschn.\ \ref{sec:table}).
\begin{lstlisting}
> (tapRes <- tapply(IQ, group, FUN=mean))     # Mittelwert pro Gruppe
   CG      T      WL
94.25  99.75  101.75

# Mittelwert pro Bedingungskombination
> tapply(IQ, list(sex, group), FUN=mean)
     CG      T     WL
f  98.0   91.0  101.5
m  90.5  108.5  102.0
\end{lstlisting}

%Wenn das Ergebnis ein eindimensionales array ist, lässt sich auch \lstinline!tapply()! dazu verwenden, um jeden Wert durch einen für seine Gruppe berechneten Kennwert zu ersetzen: Die Elemente der Ausgabe tragen dann als Namen die zugehörigen Gruppenbezeichnungen und lassen sich über diese Namen indizieren. Die als Indizes verwendbaren Gruppenbezeichnungen finden sich im Faktor, wobei jeder Index entsprechend der zugehörigen Gruppengröße mehrfach auftaucht.
%\begin{lstlisting}
%> tapRes[group]
%    T     T     T     T     WL     WL     WL     WL    CG    CG    CG    CG
%99.75 99.75 99.75 99.75 101.75 101.75 101.75 101.75 94.25 94.25 94.25 94.25
%\end{lstlisting}

Da für \lstinline!FUN! beliebige Funktionen an \lstinline!tapply()! übergeben werden können, muss man sich nicht darauf beschränken, für Gruppen getrennt einzelne Kennwerte zu berechnen. Genauso sind Funktionen zugelassen, die pro Gruppe mehr als einen einzelnen Wert ausgeben, wobei das Ergebnis von \lstinline!tapply()! dann eine Liste ist (Abschn.\ \ref{sec:list}): Jede Komponente der Liste beinhaltet die Ausgabe von \lstinline!FUN! für eine Gruppe.

So ist es etwa auch möglich, sich die Werte jeder Gruppe selbst ausgeben zu lassen, indem man die Funktion\index[func]{identity()@\lstinline{identity()}} \lstinline!identity()! verwendet, die ihr Argument unverändert ausgibt (Abschn.\ \ref{sec:split} für \lstinline!split()!).
\begin{lstlisting}
> tapply(IQ, sex, FUN=identity)         # IQ-Werte pro Geschlecht
$f
[1] 100 82 88 115 86 110

$m
[1] 120 97 97 107 80 101

> split(IQ, sex)                        # Kontrolle ...
> IQ[sex == "f"]                        # Kontrolle ...
> IQ[sex == "m"]                        # Kontrolle ...
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktionen auf geordnete Paare von Werten anwenden}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{geordnete Paare}
\index[func]{outer()@\lstinline{outer()}}
Eine Verallgemeinerung der Anwendung einer Funktion auf jeden Wert eines Vektors stellt die Anwendung einer Funktion auf alle geordneten Paare aus den Werten zweier Vektoren dar.
\begin{lstlisting}
outer(X=<<Vektor1>>, Y=<<Vektor2>>, FUN="*", ...)
\end{lstlisting}

Für die Argumente \lstinline!X! und \lstinline!Y! ist dabei jeweils ein Vektor einzutragen, unter \lstinline!FUN! eine Funktion, die zwei Argumente in Form von Vektoren verarbeiten kann.\footnote{Vor dem Aufruf von \lstinline!FUN! verlängert \lstinline!outer()! \lstinline!X! und \lstinline!Y! so, dass beide die Länge \lstinline!length(X)*length(Y)! besitzen und sich aus der Kombination der Elemente mit gleichem Index alle geordneten Paare ergeben.} Da Operatoren nur Funktionen mit besonderer Schreibweise sind, können sie hier ebenfalls eingesetzt werden, müssen dabei aber in Anführungszeichen stehen (Abschn.\ \ref{sec:funcParam}, Fußnote \ref{ftn:functional}). Voreinstellung ist die\index{ausseres Produkt@äußeres Produkt} Multiplikation, für diesen Fall existiert auch die Kurzform in Operatorschreibweise\index[func]{\%o\%@\texttt{\%o\%}} \lstinline!X %o% Y!\@. Sollen an \lstinline!FUN! weitere Argumente übergeben werden, kann dies an Stelle der \lstinline!...! geschehen, wobei mehrere Argumente durch Komma zu trennen sind. Die Ausgabe erfolgt in Form einer Matrix (Abschn.\ \ref{sec:matrix}).

Als Beispiel sollen alle Produkte der Zahlen 1--5 als Teil des kleinen $1 \times 1$ ausgegeben werden.
\begin{lstlisting}
> outer(1:5, 1:5, FUN="*")
     [,1]  [,2]  [,3]  [,4]  [,5]
[1,]    1     2     3     4     5
[2,]    2     4     6     8    10
[3,]    3     6     9    12    15
[4,]    4     8    12    16    20
[5,]    5    10    15    20    25
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Matrizen}
\label{sec:matrix}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!erstellen}
\index[func]{matrix()@\lstinline{matrix()}}
Wenn für jedes Beobachtungsobjekt Daten von mehreren Variablen vorliegen, könnten die Werte jeder Variable in einem separaten Vektor gespeichert werden. Eine andere Möglichkeit zur gemeinsamen Repräsentation aller Variablen bieten Objekte der Klasse \lstinline!matrix! als Spezialfall von arrays (Abschn.\ \ref{sec:array}).\footnote{Eine Matrix ist in R zunächst nur eine rechteckige Anordnung von Werten und nicht mit dem gleichnamigen mathematischen Konzept zu verwechseln. Wie \lstinline!attributes(<<Matrix>>)! zeigt, sind Matrizen intern lediglich Vektoren mit einem Attribut (Abschn.\ \ref{sec:objects}), das Auskunft über die Dimensionierung der Matrix, also die Anzahl ihrer Zeilen und Spalten liefert. Eine Matrix kann deshalb maximal so viele Werte speichern, wie ein Vektor Elemente besitzen kann (Abschn.\ \ref{sec:vector}, Fußnote \ref{ftn:vecDetails}). Für Rechenoperationen mit Matrizen im Kontext der linearen Algebra s.\ Abschn.\ \ref{sec:linAlg}.}
\begin{lstlisting}
matrix(data=<<Vektor>>, nrow=<<Anzahl>>, ncol=<<Anzahl>>, byrow=FALSE)
\end{lstlisting}

Unter \lstinline!data! ist der Vektor einzutragen, der alle Werte der zu bildenden Matrix enthält. Mit \lstinline!nrow! wird die Anzahl der Zeilen dieser Matrix festgelegt, mit \lstinline!ncol! die der Spalten. Die Länge des Vektors muss gleich dem Produkt von \lstinline!nrow! und \lstinline!ncol! sein, das gleich der Zahl der Zellen ist. Fehlt eine Angabe entweder von \lstinline!nrow! oder \lstinline!ncol!, wird das fehlende Argument passend zur Länge des Vektors und zum jeweils anderen Argument gesetzt. Mit dem auf \lstinline!FALSE! voreingestellten Argument \lstinline!byrow! wird die Art des Einlesens der Daten aus dem Vektor in die Matrix bestimmt -- es werden zunächst die Spalten nacheinander gefüllt. Mit \lstinline!byrow=TRUE! werden die Werte über die Zeilen eingelesen.
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> matrix(age, nrow=3, ncol=2, byrow=FALSE)
     [,1]  [,2]
[1,]   17    25
[2,]   30    23
[3,]   30    21

> (ageMat <- matrix(age, nrow=2, ncol=3, byrow=TRUE))
     [,1]  [,2]  [,3]
[1,]   17    30    30
[2,]   25    23    21
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datentypen in Matrizen}
\label{sec:matDataTypes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Datentypen}
\index{Datentyp!mischen}
Wie Vektoren können Matrizen verschiedene Datentypen besitzen, etwa \lstinline!numeric!, wenn sie Zahlen beinhalten, oder \lstinline!character! im Fall von Zeichenketten.\footnote{Indem einer Liste (Abschn.\ \ref{sec:list}) eine Dimensionierung als Attribut hinzugefügt wird, lässt sich diese Einschränkung indirekt umgehen: \lstinline!mat <- list(1, "X"); dim(mat) <- c(2, 1)! erstellt eine heterogene Matrix. Dies bietet jedoch in üblichen Anwendungen keine Vorteile.} Jede einzelne Matrix kann dabei aber ebenso wie ein Vektor nur einen einzigen Datentyp haben, alle Matrixelemente müssen also vom selben Datentyp sein. Fügt man einer numerischen Matrix eine Zeichenkette als Element hinzu, so werden die numerischen Matrixelemente automatisch in Zeichenketten umgewandelt, was an den hinzugekommenen Anführungszeichen zu erkennen ist.\footnote{Allgemein gesprochen werden alle Elemente in den umfassendsten Datentyp umgewandelt, der notwendig ist, um alle Werte ohne Informationsverlust zu speichern (Abschn.\ \ref{sec:dataTypes}).} Auf die ehemals numerischen Werte können dann keine Rechenoperationen mehr angewendet werden. Dieser Umstand macht Matrizen letztlich weniger geeignet für empirische Datensätze, für die stattdessen Objekte der Klasse \lstinline!data.frame! bevorzugt werden sollten (Abschn.\ \ref{sec:dataframe}).\footnote{Da Matrizen numerisch effizienter als Objekte der Klasse \lstinline!data.frame! verarbeitet werden können, sind sie dagegen bei der Analyse sehr großer Datenmengen vorzuziehen.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dimensionierung, Zeilen und Spalten}
\label{sec:asVecMat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Dimensionierung}
\index{Dimensionierung|see{Datensatz, Matrix}}
\index[func]{dim()@\lstinline{dim()}}
Die Dimensionierung einer Matrix (die Anzahl ihrer Zeilen und Spalten) liefert die Funktion \lstinline!dim(<<Matrix>>)!, die auch auf arrays (Abschn.\ \ref{sec:array}) oder Datensätze (Abschn.\ \ref{sec:dataframe}) anwendbar ist. Sie gibt einen Vektor aus, der die Anzahl der Zeilen und Spalten in dieser Reihenfolge als Elemente besitzt. Über\index[func]{nrow()@\lstinline{nrow()}} \lstinline!nrow(<<Matrix>>)! und\index[func]{ncol()@\lstinline{ncol()}} \lstinline!ncol(<<Matrix>>)! kann die Anzahl der Zeilen bzw.\ Spalten auch einzeln ausgegeben werden.
\begin{lstlisting}
> age    <- c(17, 30, 30, 25, 23, 21)
> ageMat <- matrix(age, nrow=2, ncol=3, byrow=FALSE)
> dim(ageMat)                       # Dimensionierung
[1] 2 3

> nrow(ageMat)                      # Anzahl der Zeilen
[1] 2

> ncol(ageMat)                      # Anzahl der Spalten
[1] 3

> length(ageMat)                    # Anzahl der Elemente
[1] 6
\end{lstlisting}

Eine Matrix wird mit \lstinline!t(<<Matrix>>)! transponiert, wodurch ihre Zeilen zu den Spalten der Transponierten und entsprechend ihre Spalten zu Zeilen der Transponierten werden.
\begin{lstlisting}
> t(ageMat)
     [,1]  [,2]
[1,]   17    30
[2,]   30    25
[3,]   23    21
\end{lstlisting}

\index{Matrix!Umwandlung in Matrix}
Wird ein Vektor über \lstinline!as.matrix(<<Vektor>>)! in eine Matrix umgewandelt, entsteht als Ergebnis eine Matrix mit einer Spalte und so vielen Zeilen, wie der Vektor Elemente enthält.
\begin{lstlisting}
> as.matrix(1:3)
     [,1]
[1,]    1
[2,]    2
[3,]    3
\end{lstlisting}

\index{Matrix!umwandeln}
Um eine Matrix in einen Vektor umzuwandeln, sollte entweder \lstinline!as.vector(<<Matrix>>)! oder einfach \lstinline!c(<<Matrix>>)! verwendet werden.\footnote{\lstinline!c()! entfernt die Attribute der übergebenen Argumente bis auf ihre Elementnamen. Matrizen verlieren damit ihre Dimensionierung \lstinline!dim! und ihre Klasse \lstinline!matrix!.} Die Anordnung der Elemente entspricht dabei dem Aneinanderhängen der Spalten der Matrix.
\begin{lstlisting}
> c(ageMat)
[1] 17 30 30 25 23 21
\end{lstlisting}

\index{Matrix!Zeilen- und Spaltenindex}
Mitunter ist es nützlich, zu einer gegebenen Matrix zwei zugehörige Matrizen zu erstellen, in denen jedes ursprüngliche Element durch seinen Zeilen- bzw.\ Spaltenindex ersetzt wurde. Dieses Ziel lässt sich mit den\index[func]{row()@\lstinline{row()}} \lstinline!row(<<Matrix>>)! und\index[func]{col()@\lstinline{col()}} \lstinline!col(<<Matrix>>)! erreichen.
\begin{lstlisting}
> P <- 2                            # Anzahl der Zeilen
> Q <- 3                            # Anzahl der Spalten
> (pqMat <- matrix(seq_len(P*Q), nrow=P, ncol=Q))
     [,1]  [,2]  [,3]
[1,]    1     3     5
[2,]    2     4     6

> (rowMat <- row(pqMat))            # Zeilenindizes
     [,1]  [,2]  [,3]
[1,]    1     1     1
[2,]    2     2     2

> (colMat <- col(pqMat))            # Spaltenindizes
     [,1]  [,2]  [,3]
[1,]    1     2     3
[2,]    1     2     3
\end{lstlisting}

Die so gewonnenen Matrizen können etwa dazu verwendet werden, eine dreispaltige Matrix zu erstellen, die in einer Spalte alle Elemente der ursprünglichen Matrix besitzt und in den anderen beiden Spalten die zugehörigen Zeilen- und Spaltenindizes enthält (Abschn.\ \ref{sec:matCbind}).
\begin{lstlisting}
> cbind(rowIdx=c(rowMat), colIdx=c(colMat), val=c(pqMat))
     rowIdx  colIdx  val
[1,]      1       1    1
[2,]      2       1    2
[3,]      1       2    3
[4,]      2       2    4
[5,]      1       3    5
[6,]      2       3    6
\end{lstlisting}

Eine andere Anwendungsmöglichkeit besteht darin, logische untere\index{Matrix!Dreiecksmatrix} bzw.\ obere Dreiecksmatrizen zu erstellen, die auch von\index[func]{lower.tri()@\lstinline{lower.tri()}} \lstinline!lower.tri()! und\index[func]{upper.tri()@\lstinline{upper.tri()}} \lstinline!upper.tri()! erzeugt werden können. Diese Matrizen können später zur Auswahl von Elementen dienen (Abschn.\ \ref{sec:matrix_selother}).
\begin{lstlisting}
> mat <- matrix(sample(1:10, 16, replace=TRUE), nrow=4, ncol=4)
> col(mat) >= row(mat)                          # obere Dreiecksmatrix
      [,1]   [,2]   [,3]  [,4]
[1,]  TRUE   TRUE   TRUE  TRUE
[2,] FALSE   TRUE   TRUE  TRUE
[3,] FALSE  FALSE   TRUE  TRUE
[4,] FALSE  FALSE  FALSE  TRUE
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elemente auswählen und verändern}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Elemente auswählen und verändern}
\index{Matrix!indizieren}
\index[func]{[]@\lstinline{[]}}
In einer Matrix ist es ähnlich wie bei einem Vektor möglich, sich einzelne Elemente mit dem \lstinline![<<Zeile>>, <<Spalte>>]! Operator anzeigen zu lassen. Der erste Index in der eckigen Klammer gibt dabei die Zeile des gewünschten Elements an, der zweite dessen Spalte.\footnote{Für Hilfe zu diesem Thema vgl.\ \lstinline!?Extract!.}
\begin{lstlisting}
> ageMat
     [,1] [,2] [,3]
[1,]   17   30   23
[2,]   30   25   21

> ageMat[2, 2]
[1] 25
\end{lstlisting}

Analog zum Vorgehen bei Vektoren können auch bei Matrizen einzelne Elemente unter Angabe ihres Zeilen- und Spaltenindex durch die Zuweisung eines Wertes verändert werden. Fehlt bei Zuweisungen der Index \lstinline!<<Matrix>>[]!, werden alle Elemente der Matrix ersetzt. Wenn der zugewiesene Vektor dabei weniger Elemente als die Matrix besitzt, wird er automatisch passend verlängert (Abschn.\ \ref{sec:recycling}).
\begin{lstlisting}
> ageMat[2, 2] <- 24
> ageMat[2, 2]
[1] 24

> ageMatCopy <- ageMat        # zu verändernde Kopie der Matrix

# Veränderung mit zyklischer Verlängerung
> ageMatCopy[] <- c(1, 2, 3)  # nicht verwechseln mit ageMatCopy <- ...
> ageMatCopy
     [,1] [,2] [,3]
[1,]    1    3    2
[2,]    2    1    3
\end{lstlisting}

Man kann sich Zeilen oder Spalten auch vollständig ausgeben lassen. Dafür wird für die vollständig aufzulistende Dimension kein Index eingetragen, jedoch das Komma trotzdem gesetzt. Dabei können auch beide Dimensionen weggelassen werden. Um einzelne Zeilen oder Spalten zu entfernen, ist ihr Index mit vorangestelltem Minus-Zeichen zu verwenden.
\begin{lstlisting}
> ageMat[2, ]                 # Werte 2. Zeile
[1] 30 24 21

> ageMat[ , 1]                # Werte 1. Spalte
[1] 17 30

> ageMat[ , ]                 # gesamte Matrix
     [,1]  [,2]  [,3]
[1,]   17    30    23
[2,]   30    24    21

> ageMat[ , -1]               # Werte bis auf 1. Spalte
     [,1] [,2]
[1,]   30   23
[2,]   25   21
\end{lstlisting}

Bei der Ausgabe einer einzelnen Zeile oder Spalte wird diese automatisch in einen Vektor umgewandelt, verliert also eine Dimension. Möchte man dies -- wie es häufig der Fall ist -- verhindern, kann beim \lstinline![<<Index>>]! Operator als weiteres Argument \lstinline!drop=FALSE!\index[func]{drop@\lstinline{drop}} angegeben werden. Das Ergebnis ist dann eine Matrix mit nur einer Zeile oder Spalte.\footnote{Dagegen bleibt \lstinline!ageMat[FALSE, FALSE]! eine leere Matrix mit $0$ Zeilen und $0$ Spalten.}
\begin{lstlisting}
> ageMat[ , 1, drop=FALSE]
     [,1]
[1,]   17
[2,]   30
\end{lstlisting}

Aufgrund der Voreinstellung \lstinline!drop=TRUE! beim Indizieren unterscheidet sich bei einer Matrix \lstinline!<<m>>! mit nur einer Zeile bzw.\ nur einer Spalte die Ausgabe von \lstinline!m! (gleichbedeutend: \lstinline!<<m>>[])! von \lstinline!<<m>>[ , ]!.
\begin{lstlisting}
> rowMat <- matrix(1:3, nrow=1)    # Matrix mit 1 Zeile
> rowMat                           # Ausgabe: Matrix
     [,1] [,2] [,3]
[1,]    1    2    3

> rowMat[]                         # Ausgabe: Matrix
     [,1] [,2] [,3]
[1,]    1    2    3

> rowMat[ , ]                      # Ausgabe ohne drop=FALSE: Vektor
[1] 1 2 3
\end{lstlisting}

Analog zum Vorgehen bei Vektoren können auch gleichzeitig mehrere Matrixelemente ausgewählt und verändert werden, indem man etwa eine Sequenz oder einen anderen Vektor als Indexvektor für eine Dimension festlegt.
\begin{lstlisting}
> ageMat[ , 2:3]                            # 2. und 3. Spalte
     [,1]  [,2]
[1,]   30    23
[2,]   24    21

> ageMat[ , c(1, 3)]                        # 1. und 3. Spalte
     [,1]  [,2]
[1,]   17    23
[2,]   30    21

> ageMatNew   <- ageMat
> (replaceMat <- matrix(c(11, 21, 12, 22), nrow=2, ncol=2))
     [,1]  [,2]
[1,]   11    12
[2,]   21    22

> ageMatNew[ , c(1, 3)] <- replaceMat       # ersetze Spalten 1 und 3
> ageMatNew
     [,1]  [,2]  [,3]
[1,]   11    30    12
[2,]   21    24    22
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Weitere Wege, Elemente auszuwählen und zu verändern}
\label{sec:matrix_selother}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Elemente auswählen und verändern}
\index{Matrix!indizieren}
Auf Matrixelemente kann auch zugegriffen werden, wenn nur ein einzelner Index genannt wird. Die Matrix wird dabei implizit in den Vektor der untereinander gehängten Spalten umgewandelt.
\begin{lstlisting}
> ageMat
     [,1] [,2] [,3]
[1,]   17   30   23
[2,]   30   24   21

> idxVec <- c(1, 3, 4)
> ageMat[idxVec]
[1] 17 30 24
\end{lstlisting}

Weiter können Matrizen auch durch eine logische Matrix derselben Dimensionierung indiziert werden, die für jedes Element bestimmt, ob es ausgegeben werden soll. Solche Matrizen können das Ergebnis eines logischen Vergleichs oder der Funktionen \lstinline!lower.tri()! bzw.\ \lstinline!upper.tri()! sein. Das Ergebnis ist ein Vektor der ausgewählten Elemente.
\begin{lstlisting}
> (idxMatLog <- ageMat >= 25)
      [,1]   [,2]   [,3]
[1,] FALSE   TRUE  FALSE
[2,]  TRUE  FALSE  FALSE

> ageMat[idxMatLog]
[1] 30 30
\end{lstlisting}

Schließlich ist es möglich, eine zweispaltige numerische Indexmatrix zu verwenden, wobei jede Zeile dieser Matrix ein Element der indizierten Matrix auswählt -- der erste Eintrag einer Zeile gibt den Zeilenindex, der zweite den Spaltenindex des auszuwählenden Elements an. Eine solche Matrix entsteht etwa bei der Umwandlung einer logischen in eine numerische Indexmatrix mittels\index[func]{which()@\lstinline{which()}} \lstinline!which()! (Abschn.\ \ref{sec:which}), wenn das Argument \lstinline!arr.ind=TRUE! gesetzt ist. Auch hier ist das Ergebnis ein Vektor der ausgewählten Elemente.
\begin{lstlisting}
> (idxMatNum <- which(idxMatLog, arr.ind=TRUE))
     row  col
[1,]   2    1
[2,]   1    2

> ageMat[idxMatNum]
[1] 30 30
\end{lstlisting}

\lstinline!arrayInd(<<Indexvektor>>, dim(<<Matrix>>))!\index[func]{arrayInd()@\lstinline{arrayInd()}} konvertiert einen numerischen Indexvektor, der eine Matrix im obigen Sinn als Vektor indiziert, in eine zweispaltige numerische Indexmatrix.
\begin{lstlisting}
> (idxMat <- arrayInd(idxVec, dim(ageMat)))
     [,1]  [,2]
[1,]    1     1
[2,]    1     2
[3,]    2     2
\end{lstlisting}

\index{Matrix!Diagonalelemente}
\index[func]{diag()@\lstinline{diag()}}
Die Diagonalelemente einer Matrix gibt \lstinline!diag(<<Matrix>>)! in Form eines Vektors aus.\footnote{Bei nicht quadratischen $(p \times q)$-Matrizen $\bm{X}$ sind dies die Elemente $x_{11}, \ldots, x_{pp}$ (für $p < q$) bzw.\ $x_{11}, \ldots, x_{qq}$ (für $p > q$).} Abschnitt \ref{sec:matAlg} zeigt den Einsatz von \lstinline!diag()!, um Diagnoalmatrizen zu erstellen.
\begin{lstlisting}
> diag(ageMat)
[1] 17 24
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Matrizen verbinden}
\label{sec:matCbind}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!erstellen}
\index{Matrix!verbinden}
\lstinline!cbind(<<Vektor1>>, <<Vektor2>>, ...)!\index[func]{cbind()@\lstinline{cbind()}|textbf} und\index[func]{rbind()@\lstinline{rbind()}} \lstinline!rbind(<<Vektor1>>, <<Vektor2>>, ...)! fügen Vektoren zu Matrizen zusammen. Das \lstinline!c! bei \lstinline!cbind()! steht für \emph{columns} (Spalten), das \lstinline!r! entsprechend für \emph{rows} (Zeilen). In diesem Sinn werden die Vektoren mit \lstinline!cbind()! spaltenweise nebeneinander, und mit \lstinline!rbind()! zeilenweise untereinander angeordnet. R verlängert Vektoren ungleicher Länge dabei zyklisch und gibt eine Warnung aus. Zeilen und Spalten können beim Erstellen auch in der Form \lstinline!<<Name>>=<<Vektor>>! benannt werden.
\begin{lstlisting}
> vec1 <- c(19, 19, 19, 31, 24)
> vec2 <- c(95, 76, 76, 94, 76)
> vec3 <- c(197, 179, 186, 189, 173)
> rbind(vec1, vec2, vec3)
     [,1] [,2] [,3] [,4] [,5]
vec1   19   19   31   19   24
vec2   95   76   94   76   76
vec3  197  178  189  184  173

> (mat <- cbind(age=vec1, weight=vec2, height=vec3))
     age  weight  height
[1,]  19      95     197
[2,]  19      76     178
[3,]  31      94     189
[4,]  19      76     184
[5,]  24      76     173
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Matrizen sortieren}
\label{sec:sortMat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!sortieren}
\index[func]{order()@\lstinline{order()}}
Die Zeilen von Matrizen können mit Hilfe von \lstinline!order()! entsprechend der Reihenfolge der Werte in einer oder mehrerer ihrer Spalten sortiert werden. Die Funktion \lstinline!sort()! ist hier nicht anwendbar, ihr Einsatz ist auf Vektoren beschränkt.
\begin{lstlisting}
order(<<Vektor>>, partial, decreasing=FALSE)
\end{lstlisting}

Für \lstinline!<<Vektor>>! ist die Spalte einer Datenmatrix einzutragen, deren Werte in eine Reihenfolge gebracht werden sollen. Unter \lstinline!decreasing! wird die Sortierreihenfolge eingestellt: In der Voreinstellung \lstinline!FALSE! wird aufsteigend sortiert, auf \lstinline!TRUE! gesetzt absteigend. Die Ausgabe ist ein Indexvektor, der die Zeilenindizes der zu ordnenden Matrix in der Reihenfolge der Werte des Sortierkriteriums enthält (Abschn.\ \ref{sec:revSortOrder}).\footnote{Die Funktion sortiert \emph{stabil}: Zeilen mit gleich großen Werten des Sortierkriteriums behalten ihre Reihenfolge relativ zueinander bei, werden also beim Sortiervorgang nicht zufällig vertauscht.}
\begin{lstlisting}
> (rowOrder1 <- order(mat[ , "age"]))       # Kriterium: Alter
[1] 1 2 4 5 3
\end{lstlisting}

Soll die gesamte Matrix entsprechend der Reihenfolge dieser Variable angezeigt werden, ist der von \lstinline!order()! ausgegebene Indexvektor zum Indizieren der Zeilen der Matrix zu benutzen. Dabei ist der Spaltenindex unter Beibehaltung des Kommas wegzulassen.
\begin{lstlisting}
> mat[rowOrder1, ]
     age  weight  height
[1,]  19      95     197
[2,]  19      76     178
[3,]  19      76     184
[4,]  24      76     173
[5,]  31      94     189
\end{lstlisting}

Mit dem Argument \lstinline!partial! kann noch eine weitere Matrixspalte eingetragen werden, die dann als sekundäres Sortierkriterium verwendet wird. So kann eine Matrix etwa zunächst hinsichtlich einer die Gruppenzugehörigkeit darstellenden Variable sortiert werden und dann innerhalb jeder Gruppe nach der Reihenfolge der Werte einer anderen Variable. Es können noch weitere Sortierkriterien durch Komma getrennt als Argumente vorhanden sein, es gibt also keine Beschränkung auf nur zwei solcher Kriterien.
\begin{lstlisting}
# sortiere primär nach Alter und sekundär nach Gewicht
> rowOrder2 <- order(mat[ , "age"], partial=mat[ , "weight"])
> mat[rowOrder2, ]
     age  weight  height
[1,]  19      76     178
[2,]  19      76     184
[3,]  19      95     197
[4,]  24      76     173
[5,]  31      94     189
\end{lstlisting}

Das Argument \lstinline!decreasing! legt global für alle Sortierkriterien fest, ob auf- oder absteigend sortiert wird. Soll die Sortierreihenfolge dagegen zwischen den Kriterien variieren, kann einzelnen numerischen Kriterien ein \lstinline!-! vorangestellt werden, was als Umkehrung der mit \lstinline!decreasing! eingestellten Reihenfolge zu verstehen ist.
\begin{lstlisting}
# sortiere aufsteigend nach Gewicht und absteigend nach Größe
> rowOrder3 <- order(mat[ , "weight"], -mat[ , "height"])
> mat[rowOrder3, ]
     age  weight  height
[1,]  19      76     184
[2,]  19      76     178
[3,]  24      76     173
[4,]  31      94     189
[5,]  19      95     197
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Randkennwerte berechnen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Randkennwerte}
Die Summe aller Elemente einer numerischen Matrix lässt sich mit \lstinline!sum(<<Matrix>>)!, die separat über jede Zeile oder jede Spalte gebildeten Summen durch\index[func]{rowSums()@\lstinline{rowSums()}} \lstinline!rowSums(<<Matrix>>)!\index[func]{colSums()@\lstinline{colSums()}} bzw.\ \lstinline!colSums(<<Matrix>>)! berechnen. Gleiches gilt für den Mittelwert aller Elemente, der mit \lstinline!mean(<<Matrix>>)! ermittelt wird und die mit\index[func]{rowMeans()@\lstinline{rowMeans()}} \lstinline!rowMeans()!\index[func]{colMeans()@\lstinline{colMeans()}} bzw.\ \lstinline!colMeans()! separat über jede Zeile oder jede Spalte berechneten Mittelwerte.
\begin{lstlisting}
> sum(mat)                                # Summe aller Elemente
[1] 1450

> rowSums(mat)                            # Summen jeder Zeile
[1] 311 273 314 279 273

> mean(mat)                               # Mittelwert aller Elemente
[1] 96.66667

> colMeans(mat)                           # Mittelwerte jeder Spalte
 age  weight  height
22.4    83.4   184.2
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Beliebige Funktionen auf Matrizen anwenden}
\label{sec:apply}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Funktionen anwenden}
\index[func]{apply()@\lstinline{apply()}}
Wenn eine andere Funktion als die Summe oder der Mittelwert separat auf jeweils jede Zeile oder jede Spalte angewendet werden soll, ist dies mit \lstinline!apply()! zu erreichen.
\begin{lstlisting}
apply(X=<<Matrix>>, MARGIN=<<Nummer>>, FUN=<<Funktion>>, ...)
\end{lstlisting}

\lstinline!X! erwartet die Matrix der zu verarbeitenden Daten. Unter \lstinline!MARGIN! wird angegeben, ob die Funktion Kennwerte der Zeilen (\lstinline!1!) oder Spalten (\lstinline!2!) berechnet. Für \lstinline!FUN! ist die anzuwendende Funktion einzusetzen, die als Argument einen Vektor akzeptieren muss. Gibt sie mehr als einen Wert zurück, ist das Ergebnis eine Matrix mit den Rückgabewerten von \lstinline!FUN! in den Spalten. Die drei Punkte \lstinline!...! stehen für optionale, ggf.\ durch Komma getrennte Argumente von \lstinline!FUN!, die an diese Funktion weitergereicht werden.
\begin{lstlisting}
> apply(mat, 2, sum)                      # Summen jeder Spalte
age  weight  height
112     417     921

> apply(mat, 1, max)                      # Maximum jeder Zeile
[1] 197 178 189 184 173

> apply(mat, 1, range)                    # Range jeder Zeile
     [,1]  [,2]  [,3]  [,4]  [,5]
[1,]   19    19    31    19    24
[2,]  197   178   189   184   173

> apply(mat, 2, mean, trim=0.1)   # gestutzter Mittelwert jeder Spalte
 age  weight  height
22.4    83.4   184.2
\end{lstlisting}

Im letzten Beispiel wird das für \lstinline!...! eingesetzte Argument \lstinline!trim=0.1! an \lstinline!mean()! weitergereicht.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Matrix zeilen- oder spaltenweise mit Kennwerten verrechnen}
\label{sec:mat_colwise}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!mit Kennwert verrechnen}
Zeilen- und Spaltenkennwerte sind häufig Zwischenergebnisse, die für weitere Berechnungen mit einer Matrix nützlich sind. So ist es etwa zum spaltenweisen\index{Matrix!zentrieren} Zentrieren einer Matrix notwendig, von jedem Wert den zugehörigen Spaltenmittelwert abzuziehen. Anders gesagt soll die Matrix dergestalt mit einem Vektor verrechnet werden, dass auf jede Spalte dieselbe Operation (hier: Subtraktion), aber mit einem anderen Wert angewendet wird -- nämlich mit dem Element des Vektors der Spaltenmittelwerte, das dieselbe Position im Vektor besitzt wie die Spalte in der Matrix. Die genannte Operation lässt sich mit\index[func]{sweep()@\lstinline{sweep()}} \lstinline!sweep()! durchführen.
\begin{lstlisting}
sweep(x=<<Matrix>>, MARGIN=<<Nummer>>, STATS=<<Kennwerte>>,
      FUN=<<Funktion>>, ...)
\end{lstlisting}

Das Argument \lstinline!x! erwartet die Matrix der zu verarbeitenden Daten. Unter \lstinline!MARGIN! wird angegeben, ob die Funktion jeweils Zeilen (\lstinline!1!) oder Spalten (\lstinline!2!) mit den Kennwerten verrechnet. Bei Objekten mit benannten Dimensionen ist auch der zugehörige Name der gemeinten Dimension möglich -- etwa bei mit \lstinline!xtabs()! erstellten Kreuztabellen (Abschn.\ \ref{sec:table}). An \lstinline!STATS! sind diese Kennwerte in Form eines Vektors mit so vielen Einträgen zu übergeben, wie \lstinline!x! Zeilen (\lstinline!MARGIN=1!) bzw.\ Spalten (\lstinline!MARGIN=2!) besitzt. Für \lstinline!FUN! ist die anzuwendende Funktion einzusetzen, Operatoren müssen dabei in Anführungszeichen stehen. Voreinstellung ist die Subtraktion \lstinline!"-"!. Die drei Punkte \lstinline!...! stehen für optionale, ggf.\ durch Komma getrennte Argumente von \lstinline!FUN!, die an diese Funktion weitergereicht werden.

Im Beispiel sollen die Daten einer Matrix erst spaltenweise, dann zeilenweise zentriert werden (s.\ Abschn.\ \ref{sec:rowNames} für \lstinline!dimnames()!).
\begin{lstlisting}
> Mj <- rowMeans(mat)                       # Mittelwerte der Zeilen
> Mk <- colMeans(mat)                       # Mittelwerte der Spalten

# benenne Dimensionen
> dimnames(mat) <- list(obs=NULL, vars=c("age", "weight", "height"))
> sweep(mat, "vars", Mk, "-")               # spaltenweise zentrieren
      age  weight  height
[1,] -3.4    11.6    12.8
[2,] -3.4    -7.4    -6.2
[3,]  8.6    10.6     4.8
[4,] -3.4    -7.4    -0.2
[5,]  1.6    -7.4   -11.2

> scale(mat, center=TRUE, scale=FALSE)      # Kontrolle mit scale() ...
> sweep(mat, 1, Mj, "-")                    # zeilenweise zentrieren
           age     weight    height
[1,] -84.66667  -8.666667  93.33333
[2,] -72.00000 -15.000000  87.00000
[3,] -73.66667 -10.666667  84.33333
[4,] -74.00000 -17.000000  91.00000
[5,] -67.00000 -15.000000  82.00000

> t(scale(t(mat), center=TRUE, scale=FALSE))  # Kontrolle mit scale()
# ...
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kovarianz- und Korrelationsmatrizen}
\label{sec:covMat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Kovarianz!Kovarianzmatrix}
\index{Korrelation!Korrelationsmatrix}
Zum Erstellen von Kovarianz- und Korrelationsmatrizen können die aus Abschn.\ \ref{sec:covCor} bekannten Funktionen \lstinline!cov(<<Matrix>>)!\index[func]{cov()@\lstinline{cov()}} und\index[func]{cor()@\lstinline{cor()}} \lstinline!cor(<<Matrix>>)! verwendet werden, wobei die Werte in Form einer Matrix mit Variablen in den Spalten übergeben werden müssen. \lstinline!cov()! liefert die korrigierte Kovarianzmatrix.
\begin{lstlisting}
> cov(mat)                                      # Kovarianzmatrix
         age  weight  height
age    27.80   22.55     0.4
weight 22.55  102.80    82.4
height  0.40   82.40    87.7

> cor(mat)                                      # Korrelationsmatrix
               age     weight       height
age    1.000000000  0.4218204  0.008100984
weight 0.421820411  1.0000000  0.867822404
height 0.008100984  0.8678224  1.000000000
\end{lstlisting}

\index{Kovarianz!unkorrigierte}
\index{Varianz!unkorrigierte}
\index[func]{cov.wt()@\lstinline{cov.wt()}}
\lstinline!cov2cor(<<K>>)!\index[func]{cov2cor()@\lstinline{cov2cor()}} wandelt eine korrigierte Kovarianzmatrix $\bm{K}$ in eine Korrelationsmatrix um. Analog erzeugt \lstinline!cor2cov(<<R>>, <<s>>)!\index[func]{cor2cov()@\lstinline{cor2cov()}} aus dem Paket\index[pack]{MBESS@\lstinline{MBESS}} \lstinline!MBESS! \cite{Kelley2010} aus einer Korrelationsmatrix $\bm{R}$ und einem Vektor der Streuungen $\bm{s}$ der Variablen die zugehörige Kovarianzmatrix. Weiterhin existiert mit \lstinline!cov.wt()! eine Funktion, die direkt die unkorrigierte Kovarianzmatrix ermitteln kann.
\begin{lstlisting}
cov.wt(x=<<Matrix>>, method=c("unbiased", "ML"))
\end{lstlisting}

Unter \lstinline!x! ist die Matrix einzutragen, von deren Spalten paarweise die Kovarianz bestimmt werden soll. Um diese Funktion auf einen einzelnen Vektor anwenden zu können, muss dieser zunächst mit \lstinline!as.matrix(<<Vektor>>)! in eine einspaltige Matrix konvertiert werden. Mit \lstinline!method! lässt sich wählen, ob die korrigierten oder unkorrigierten Varianzen und Kovarianzen ausgerechnet werden -- Voreinstellung ist \lstinline!"unbiased"! für die korrigierten Kennwerte. Sind die unkorrigierten Kennwerte gewünscht, ist \lstinline!"ML"! zu wählen, da sie bei normalverteilten Variablen die Maximum-Likelihood-Schätzung der theoretischen Parameter auf Basis einer Stichprobe darstellen.

Das Ergebnis der Funktion ist eine Liste (Abschn.\ \ref{sec:list}), die die Kovarianzmatrix als Komponente \lstinline!cov!, die Mittelwerte als Komponente \lstinline!center! und die Anzahl der eingegangenen Fälle als Komponente \lstinline!n.obs! (\emph{number of observations}) besitzt.
\begin{lstlisting}
> cov.wt(mat, method="ML")
$cov
         age  weight  height
age    22.24   18.04    0.32
weight 18.04   82.24   65.92
height  0.32   65.92   70.16

$center
 age  weight  height
22.4    83.4   184.2

$n.obs
[1] 5
\end{lstlisting}

Mit \lstinline!diag(<<Matrix>>)! lassen sich aus einer Kovarianzmatrix die in der Diagonale stehenden Varianzen extrahieren (Abschn.\ \ref{sec:matAlg}).
\begin{lstlisting}
> diag(cov(mat))
 age  weight  height
27.8   102.8    87.7
\end{lstlisting}

Um gleichzeitig die Kovarianz oder Korrelation einer durch \lstinline!<<Vektor>>! gegebenen Variable mit mehreren anderen, spaltenweise zu einer Matrix zusammengefassten Variablen zu berechnen, dient der Aufruf \lstinline!cov(<<Matrix>>, <<Vektor>>)! bzw.\ \lstinline!cor(<<Matrix>>, <<Vektor>>)!. Das Ergebnis ist eine Matrix mit so vielen Zeilen, wie das erste Argument Spalten besitzt.
\begin{lstlisting}
> vec <- rnorm(nrow(mat))
> cor(mat, vec)
             [,1]
age    -0.1843847
weight -0.6645798
height -0.6503452
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Arrays}
\label{sec:array}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{array}
\index[func]{array()@\lstinline{array()}}
Das Konzept der Speicherung von Daten in eindimensionalen Vektoren und zweidimensionalen Matrizen lässt sich mit der Klasse \lstinline!array! auf höhere Dimensionen verallgemeinern. In diesem Sinne sind Vektoren und Matrizen ein- bzw.\ zweidimensionale Spezialfälle von arrays, weshalb sich arrays in allen wesentlichen Funktionen auch wie Matrizen verhalten. So müssen die in einem array gespeicherten Werte alle denselben Datentyp aufweisen, wie es auch bei Vektoren und Matrizen der Fall ist (Abschn.\ \ref{sec:matDataTypes}).\footnote{So, wie sich Matrizen mit \lstinline!cbind()! und \lstinline!rbind()! aus Vektoren zusammenstellen lassen, ermöglicht\index[func]{abind()@\lstinline{abind()}} \lstinline!abind()! aus dem gleichnamigen Paket\index[pack]{abind@\lstinline{abind}} \cite{Plate2004} das Verbinden von Matrizen zu einem array.}
\begin{lstlisting}
array(data=<<Vektor>>, dim=length(data), dimnames=NULL)
\end{lstlisting}

Für \lstinline!data! ist ein Datenvektor mit den Werten anzugeben, die das array speichern soll. Mit \lstinline!dim! wird die Dimensionierung festgelegt, also die Anzahl der Dimensionen und der Werte pro Dimension. Dies geschieht mit Hilfe eines Vektors, der pro Dimension ein Element beinhaltet, das die Anzahl der zugehörigen Werte spezifiziert. Das Argument \lstinline!dim=c(2, 3, 4)! würde etwa festlegen, dass das array zwei Zeilen, drei Spalten und vier Schichten umfassen soll. Ein dreidimensionales array lässt sich nämlich als Quader vorstellen, der aus mehreren zweidimensionalen Matrizen besteht, die in Schichten hintereinander gereiht sind. Das Argument \lstinline!dimnames! dient dazu, die Dimensionen und die einzelnen Stufen in jeder Dimension gleichzeitig mit Namen zu versehen. Dies geschieht unter Verwendung einer Liste (Abschn.\ \ref{sec:list}), die für jede Dimension eine Komponente in Form eines Vektors mit den gewünschten Bezeichnungen der einzelnen Stufen besitzt. Die Namen der Dimensionen selbst können über die Benennung der Komponenten der Liste festgelegt werden.

Als Beispiel soll die Kontingenztafel dreier kategorialer Variablen dienen: Geschlecht mit zwei Stufen und zwei weitere Variablen mit drei bzw.\ zwei Stufen. Ein dreidimensionales array wird durch separate zweidimensionale Matrizen für jede Stufe der dritten Dimension ausgegeben.
\begin{lstlisting}
> (myArr1 <- array(1:12, dim=c(2, 3, 2), dimnames=list(row=c("f", "m"),
+                  column=c("CG", "WL", "T"), layer=c("high", "low"))))
, , layer = high
      column
row  CG  WL  T
  f   1   3  5
  m   2   4  6

, , layer = low
      column
row  CG  WL   T
  f   7   9  11
  m   8  10  12
\end{lstlisting}

Das array wird durch die mit dem Vektor \lstinline!1:12! bereitgestellten Daten in Reihenfolge der Dimensionen aufgefüllt: zunächst alle Zeilen der ersten Spalte der ersten Schicht, dann in diesem Muster alle Spalten der ersten Schicht und zuletzt in diesem Muster alle Schichten. Auf arrays lassen sich mit \lstinline!apply()! wie bei Matrizen beliebige Funktionen in Richtung der einzelnen Dimensionen anwenden.

Arrays lassen sich analog zu Matrizen mit dem \lstinline![<<Index>>]!\index[func]{[]@\lstinline{[]}} Operator indizieren, wobei die Indizes für die zusätzlichen Dimensionen durch Komma getrennt hinzugefügt werden.
\begin{lstlisting}
> myArr1[1, 3, 2]         # Element in 1. Zeile, 3. Spalte, 2. Schicht
[1] 11

> myArr2 <- myArr1*2
> myArr2[ , , "high"]     # zeige nur 1. Schicht
     column
row  CG  WL   T
  f   2   6  10
  m   4   8  12
\end{lstlisting}

\index[func]{aperm()@\lstinline{aperm()}}
Ähnlich wie sich bei Matrizen durch Transponieren mit \lstinline!t()! Zeilen und Spalten vertauschen lassen, können mit \lstinline!aperm(<<array>>, perm=<<Vektor>>)! auch bei arrays Dimensionen ausgetauscht werden. Als erstes Argument ist das zu transformierende $p$-dimensionale array anzugeben. \lstinline!perm! legt in Form eines Vektors mit den Elementen $1$ bis $p$ fest, welche Dimensionen vertauscht werden sollen. Die Position eines Elements von \lstinline!perm! bezieht sich auf die alte Dimension, das Element selbst bestimmt, zu welcher neuen Dimension die alte gemacht wird. Sollen in einem dreidimensionalen array die Schichten zu Zeilen (und umgekehrt) werden, wäre \lstinline!perm=c(3, 2, 1)! zu setzen. Das Vertauschen von Zeilen und Spalten wäre mit \lstinline!perm=c(2, 1, 3)! zu erreichen. Im Fall benannter Dimensionen kann \lstinline!perm! statt der Werte $1, \ldots, p$ auch die Namen der Dimensionen enthalten.
\begin{lstlisting}
# vertausche Zeile und Spalte
> aperm(myArr1, perm=c("column", "row", "layer"))
, , layer = high
      row
column f m
    CG 1 2
    WL 3 4
    T  5 6

, , layer = low
      row
column  f  m
    CG  7  8
    WL  9 10
    T  11 12
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Listen}
\label{sec:list}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index[func]{list()@\lstinline{list()}}
\index{Liste}
\index{Datentyp!mischen}
Vektoren, Matrizen und arrays sind dahingehend eingeschränkt, dass sie gleichzeitig nur Werte desselben Datentyps aufnehmen können. Da in empirischen Erhebungen meist Daten unterschiedlichen Typs -- etwa numerische Variablen, Faktoren und Zeichenketten -- anfallen, sind sie nicht unmittelbar geeignet, vollständige Datensätze zu speichern. Objekte der Klasse \lstinline!list! sind in dieser Hinsicht flexibler: Sie erlauben es, gleichzeitig Variablen unterschiedlichen Datentyps und auch unterschiedlicher Klasse als Komponenten zu besitzen.

Listen eignen sich zur Repräsentation heterogener Sammlungen von Daten und werden deshalb von vielen Funktionen genutzt, um ihr Ergebnis zurückzugeben. Listen sind darüber hinaus die allgemeine Grundform von Datensätzen (Klasse \lstinline!data.frame!), der gewöhnlich am besten geeigneten Struktur für empirische Daten (Abschn.\ \ref{sec:dataframe}).

Listen werden mit dem Befehl \lstinline!list(<<Komponente1>>, <<Komponente2>>, ...)! erzeugt, wobei für jede Komponente ein (ggf.\ bereits bestehendes) Objekt zu nennen ist. Alternativ lässt sich eine Liste mit \lstinline!<<Anzahl>>! vielen leeren Komponenten über \lstinline!vector("list", <<Anzahl>>)! erstellen. Komponenten einer Liste können Objekte jeglicher Klasse und jedes Datentyps, also auch selbst wieder Listen sein. Die erste Komponente könnte also z.\,B.\ ein numerischer Vektor, die zweite ein Vektor von Zeichenketten und die dritte eine Matrix aus Wahrheitswerten sein. Die von \lstinline!length(<<Liste>>)!\index[func]{length()@\lstinline{length()}} ausgegebene Länge einer Liste ist die Anzahl ihrer Komponenten auf oberster Ebene, \lstinline!lengths(<<Liste>>)!\index[func]{lengths()@\lstinline{lengths()}} nennt die jeweilige Länge der Listenkomponenten.
\begin{lstlisting}
> myList1 <- list(c(1,3), c(12,8,29,5))   # Liste erstellen
> length(myList1)                         # Anzahl Komponenten
[1] 2

> lengths(myList1)                        # Länge der Komponenten
[1] 2 4

> vector("list", 2)                       # Liste: 2 leere Komponenten
[[1]]
NULL

[[2]]
NULL
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Komponenten auswählen und verändern}
\label{sec:listExtract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index[func]{[[]]@\lstinline{[[]]}}
Um auf eine Listen-Komponente zuzugreifen, kann der \lstinline![[<<Index>>]]! Operator benutzt werden, der als Argument die Position der zu extrahierenden Komponente in der Liste benötigt. Dabei kann der Index auch in einem Objekt gespeichert sein. \lstinline![[<<Index>>]]! gibt immer nur eine Komponente zurück, selbst wenn mehrere Indizes in Form eines Indexvektors übergeben werden.\footnote{Für Hilfe zu diesem Thema vgl.\ \lstinline!?Extract!.} Die zweite Komponente einer Liste könnte also so ausgelesen werden:
\begin{lstlisting}
> myList1[[2]]
[1] 12 8 29 5

> idx <- 2
> myList1[[idx]]
[1] 12 8 29 5
\end{lstlisting}

Einzelne Elemente einer aus mehreren Werten bestehenden Komponente können auch direkt abgefragt werden, etwa das dritte Element des obigen Vektors. Dazu wird der für Vektoren genutzte \lstinline![<<Index>>]! Operator an den Listenindex \lstinline![[<<Index>>]]! angehängt, weil die Auswertung des Befehls \lstinline!myList1[[2]]! zuerst erfolgt und den im zweiten Schritt zu indizierenden Vektor zurückliefert:
\begin{lstlisting}
> myList1[[2]][3]
[1] 29
\end{lstlisting}

Beispiel sei eine Liste aus drei Komponenten. Die erste soll ein Vektor sein, die zweite eine aus je zwei Zeilen und Spalten bestehende Matrix, die dritte ein Vektor aus Zeichenketten.
\begin{lstlisting}
> (myList2 <- list(1:4, matrix(1:4, 2, 2), c("Lorem", "ipsum")))
[[1]]
[1] 1 2 3 4

[[2]]
     [,1]  [,2]
[1,]    1     3
[2,]    2     4

[[3]]
[1] "Lorem" "ipsum"
\end{lstlisting}

Das Element in der ersten Zeile und zweiten Spalte der Matrix, die ihrerseits die zweite Komponente der Liste darstellt, wäre dann so aufzurufen:
\begin{lstlisting}
> myList2[[2]][1, 2]
[1] 3
\end{lstlisting}

Auch bei Listen kann der \lstinline![<<Index>>]! Operator verwendet werden, der immer ein Objekt desselben Datentyps zurückgibt wie den des indizierten Objekts. Im Unterschied zu \lstinline![[<<Index>>]]! liefert er deshalb nicht die Komponente selbst zurück, sondern eine Liste, die wiederum als einzige Komponente das gewünschte Objekt besitzt -- also gewissermaßen eine Teilliste ist. \citeA{Wickham2014a} verwendet die Analogie eines Zuges, bei dem die Waggons den Komponenten einer Liste entsprechen: \lstinline![]! koppelt Waggons vom Zug ab, während \lstinline![[]]! den Inhalt eines Waggons extrahiert. Während \lstinline!myList2[[2]]! also eine numerische Matrix ausgibt, ist das Ergebnis von \lstinline!myList2[2]! eine Liste, deren einzige Komponente diese Matrix ist.
\begin{lstlisting}
> myList2[[2]]     # Komponente: numerische Matrix -> Datentyp numeric
     [,1]  [,2]
[1,]    1     3
[2,]    2     4

> mode(myList2[[2]])
[1] "numeric"

> myList2[2]       # Teilliste -> Datentyp list
[[1]]
     [,1]  [,2]
[1,]    1     3
[2,]    2     4

> mode(myList2[2])
[1] "list"
\end{lstlisting}

Wie auch bei Vektoren können die Komponenten einer Liste benannt sein und mittels \lstinline!<<Liste>>[["<<Variablenname>>"]]! über ihren Namen ausgewählt werden.
\begin{lstlisting}
> (myList3 <- list(numvec=1:5, word="dolor"))
$numvec
[1] 1 2 3 4 5

$word
[1] "dolor"

> myList3[["word"]]
[1] "dolor"
\end{lstlisting}

Welche Namen die Komponenten einer Liste tragen, erfährt man mit \lstinline!names(<<Liste>>)!\index[func]{names()@\lstinline{names()}}. Ob eine bestimmte Komponente in einer Liste enthalten ist, gibt \lstinline!hasName(<<Liste>>, "<<Name>>")!\index[func]{hasName()@\lstinline{hasName()}} aus. \lstinline!setNames(<<Liste>>, c("<<Name1>>", ...))!\index[func]{setNames()@\lstinline{setNames()}} ändert die Namen der Komponenten der übergebenen Liste auf die Elemente des als zweites Argument genannten Vektors von Zeichenketten. Die Funktion verändert die Liste selbst nicht, sondern liefert eine modifizierte Liste zurück.
\begin{lstlisting}
> hasName(myList3, "numbers")
[1] FALSE

> (myList4 <- setNames(myList3, c("numbers", "chars")))
$numbers
[1] 1 2 3 4 5

$chars
[1] "dolor"
\end{lstlisting}

Wenn man auf eine benannte Komponente zugreifen will, kann dies mittels \lstinline![[]]! Operator und ihrem numerischen Index oder ihrem Namen geschehen, zusätzlich aber auch über den Operator\index[func]{$@\lstinline{$}} \lstinline!<<Liste>>$<<Name>>!. Dieser bietet den Vorteil, dass er ohne Klammern und numerische Indizes auskommt und damit recht übersichtlich ist. Nur\index{Anfuhrungszeichen@Anführungszeichen} wenn der Name Leerzeichen enthält, wie es bisweilen bei von R zurückgegebenen Objekten der Fall ist, muss er zudem in Anführungszeichen stehen. \lstinline!$! benötigt immer den Variablennamen selbst, anders als mit \lstinline![[]]! kann kein Objekt verwendet werden, das den Namen speichert.
\begin{lstlisting}
> myList3$numvec
[1] 1 2 3 4 5

> mat     <- cbind(1:10, sample(-10:10, 10, replace=FALSE))
> retList <- cov.wt(mat, method="ML")   # unkorrigierte Kovarianzmatrix
> names(retList)                        # Komponenten der Liste
[1] "cov" "center" "n.obs"

> retList$cov                           # Kovarianzmatrix selbst
     [,1]   [,2]
[1,] 8.25   6.20
[2,] 6.20  28.44

> retList[["center"]]                   # Spaltenmittel
[1] 5.5 3.4

> component <- "n.obs"                  # Anzahl Beobachtungen
> retList[[component]]
[1] 10
\end{lstlisting}

In automatisiert verarbeiteten Befehlsskripten ist es sicherer, die Variante \lstinline![["<<Name>>"]]! zu verwenden. Dies liegt daran, dass bei \lstinline!$<<Name>>! unvollständige Anfänge von Variablennamen akzeptiert und automatisch ergänzt werden, wenn dies eindeutig möglich ist. Anfänge von Variablennamen mit mehreren möglichen Ergänzungen resultieren dagegen im Ergebnis \lstinline!NULL!. Dieses \emph{partial matching} Verhalten kann zu unentdeckten Fehlern in der Variablenauswahl führen.
\begin{lstlisting}
> retList$n                             # wird ergänzt zu n.obs
[1] 10

> retList$c                             # nicht eindeutig ergänzbar
NULL
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Komponenten hinzufügen und entfernen}
\label{sec:addRemove}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Auf dieselbe Weise, wie sich die Komponenten einer Liste anzeigen lassen, können auch weitere Komponenten zu einer bestehenden Liste hinzugefügt werden, also mit
\begin{itemize}
\item \lstinline!<<Liste>>[[<<Index>>]]!
\item \lstinline!<<Liste>>[["<<neue Komponente>>"]]!
\item \lstinline!<<Liste>>$<<neue Komponente>>!
\end{itemize}

\begin{lstlisting}
> myList1[[3]]          <- LETTERS[1:5]   # 1. neue Komponente
> myList1[["neuKomp2"]] <- letters[1:5]   # 2. neue Komponente
> myList1$neuKomp3      <- 100:105        # 3. neue Komponente
> myList1
[[1]]
[1] 1 3

[[2]]
[1] 12 8 29 5

[[3]]
[1] "A" "B" "C" "D" "E"

$neuKomp2
[1] "a" "b" "c" "d" "e"

$neuKomp3
[1] 100 101 102 103 104 105
\end{lstlisting}

Um die Komponenten mehrerer Listen zu einer Liste zu verbinden, eignet sich wie bei Vektoren \lstinline!c(<<Liste1>>, <<Liste2>>, ...)!.
\begin{lstlisting}
> myListJoin <- c(myList1, myList2)                # verbinde Listen
\end{lstlisting}

Die Komponente einer Liste wird gelöscht, indem ihr die leere Menge \lstinline!NULL! zugewiesen wird -- bei Verwendung des \lstinline![<<Index>>]! Operators ist dies auch für mehrere Komponenten gleichzeitig möglich.
\begin{lstlisting}
> myList1$neuKomp3 <- NULL                         # lösche Komponente
> myListJoin[c("neuKomp2", "neuKomp3")] <- NULL    # lösche Komponenten
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Listen mit mehreren Ebenen}
\label{sec:unlist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Da Komponenten einer Liste Objekte verschiedener Klassen und auch selbst Listen sein können, ergibt sich die Möglichkeit, Listen zur Repräsentation hierarchisch organisierter Daten unterschiedlicher Art zu verwenden. Derartige Objekte können auch als Baum mit mehreren Verästelungsebenen betrachtet werden. Um aus einem solchen Objekt einen bestimmten Wert zu erhalten, kann man sich zunächst mit \lstinline!str(<<Liste>>)! einen Überblick über die Organisation der Liste verschaffen und sich ggf.\ sukzessive von Ebene zu Ebene zum gewünschten Element vorarbeiten.

Im Beispiel soll aus einer Liste mit letztlich drei Ebenen ein Wert aus einer Matrix extrahiert werden, die sich in der dritten Verästelungsebene befindet.
\begin{lstlisting}
# 4 Komponenten in der zweiten Ebene
> myListAA <- list(AAA=c(1, 2), AAB=c("AAB1", "AAB2", "AAB3"))
> myMatAB  <- matrix(1:8, nrow=2)
> myListBA <- list(BAA=matrix(rnorm(10), ncol=2), BAB=c("BAB1", "BAB2"))
> myVecBB  <- sample(1:10, 5)

# 2 Komponenten in der ersten Ebene
> myListA <- list(AA=myListAA, AB=myMatAB)
> myListB <- list(BA=myListBA, BB=myVecBB)

# Gesamtliste
> myList4 <- list(A=myListA, B=myListB)
> str(myList4)                            # Gesamtstruktur
List of 2
$ A:List of 2
 ..$ AA:List of 2
 .. ..$ AAA: num [1:2]  1 2
 .. ..$ AAB: chr [1:3]  "AAB1" "AAB2" "AAB3"
 ..$ AB: int [1:2, 1:4]  1 2 3 4 5 6 7 8

$ B:List of 2
 ..$ BA:List of 2
 .. ..$ BAA: num [1:5, 1:2]  -0.618 -1.059 -1.150 0.919 -1.146 ...
 .. ..$ BAB: chr [1:2]  "BAB1" "BAB2"
 ..$ BB: int [1:5]  3 5 7 2 9

# Struktur der 2. Komponente (B) der 1. Ebene
> str(myList4$B)
List of 2
$ BA:List of 2
  ..$ BAA: num [1:5, 1:2]  -0.618 -1.059 -1.150 0.919 -1.146 ...
  ..$ BAB: chr [1:2]  "BAB1" "BAB2"
$ BB: int [1:5]  3 5 7 2 9

# Struktur der 3. Komponente (BA) der 2. Ebene
> str(myList4$B$BA)
List of 2
$ BAA: num [1:5, 1:2]  -0.618 -1.059 -1.150 0.919 -1.146 ...
$ BAB: chr [1:2]  "BAB1" "BAB2"

# Element der 1. Komponente (BAA) der 3. Ebene
> myList4$B$BA$BAA[4, 2]
[1] 0.1446770
\end{lstlisting}

Die hierarchische Struktur einer Liste kann mit dem Befehl \lstinline!unlist(<<Liste>>)!\index[func]{unlist()@\lstinline{unlist()}} aufgelöst werden. Der Effekt besteht darin, dass alle Komponenten (in der Voreinstellung \lstinline!recursive=TRUE! rekursiv, d.\,h.\ einschließlich aller Ebenen) in denselben Datentyp umgewandelt und seriell in einem Vektor zusammengefügt werden. Als Datentyp wird jener gewählt, der alle Einzelwerte ohne Informationsverlust speichern kann (Abschn.\ \ref{sec:dataTypes}).
\begin{lstlisting}
> myList5 <- list(c(1, 2, 3), c("A", "B"), matrix(5:12, 2))
> unlist(myList5)
[1] "1" "2" "3" "A" "B" "5" "6" "7" "8" "9" "10" "11" "12"
\end{lstlisting}

Das Argument \lstinline!recursive=FALSE! führt dazu, dass nur die oberste Verästelungsebene entfernt wird.
\begin{lstlisting}
> myList6 <- list(L1=list(L1a=1:3,      L1b=LETTERS[1:3]),
+                 L2=list(L2a=rnorm(2), L2b=letters[7:8]))

> str(myList6)
List of 2
 $ L1:List of 2
  ..$ L1a: int [1:3] 1 2 3
  ..$ L1b: chr [1:3] "A" "B" "C"
 $ L2:List of 2
  ..$ L2a: num [1:2] -2.17 1.49
  ..$ L2b: chr [1:2] "g" "h"

> unlist(myList6, recursive=FALSE)
$L1.L1a
[1] 1 2 3

$L1.L1b
[1] "A" "B" "C"

$L2.L2a
[1] -2.166634  1.491034

$L2.L2b
[1] "g" "h"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Datensätze}
\label{sec:dataframe}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Datensatz}
\index{Datentyp!mischen}

Ein Datensatz ist eine spezielle Liste und besitzt die Klasse \lstinline!data.frame! sowie den von \lstinline!mode()! ermittelten Datentyp \lstinline!list!. Datensätze erben die Grundeigenschaften einer Liste, besitzen aber bestimmte einschränkende Merkmale -- so müssen ihre Komponenten alle dieselbe Länge besitzen. Die in einem Datensatz zusammengefassten Objekte können von unterschiedlicher Klasse sein und Werte unterschiedlichen Datentyps beinhalten. Dies entspricht der empirischen Situation, dass Werte verschiedener Variablen an derselben Menge von Beobachtungsobjekten erhoben wurden. Anders gesagt enthält jede einzelne Variable Werte einer festen Menge von Beobachtungsobjekten, die auch die Werte für die übrigen Variablen geliefert haben. Werte auf unterschiedlichen Variablen lassen sich somit einander hinsichtlich des Beobachtungsobjekts zuordnen, von dem sie stammen. Da Datensätze gewöhnliche Objekte sind, ist es im Gegensatz zu einigen anderen Statistikprogrammen möglich, mit mehreren von ihnen gleichzeitig zu arbeiten.

Der Basisumfang von R beinhaltet im automatisch geladenen Paket \lstinline!datasets! viele vorbereitete Datensätze, an denen sich statistische Auswertungsverfahren erproben lassen, vgl.\ \lstinline!data()! für eine Übersicht. Weitere Datensätze werden durch\index{Datensatz!Pakete} Zusatzpakete bereitgestellt und lassen sich mit \lstinline!data(<<Datensatz>>, package="<<Paketname>>")! laden.\footnote{Hervorzuheben sind \lstinline!DAAG!\index[pack]{DAAG@\lstinline{DAAG}} \cite{Maindonald2009}, \lstinline!carData!\index[pack]{carData@\lstinline{carData}} \cite{Fox2019} und \lstinline!HSAUR3!\index[pack]{HSAUR3@\lstinline{HSAUR3}} \cite{Everitt2011}.} Nähere Erläuterungen zu einem dokumentierten Datensatz gibt \lstinline!help(<<Datensatz>>)! aus. Abschnitt \ref{sec:dataImport} zeigt, wie Datensätze aus externen Quellen eingelesen werden können. Die notwendigen Schritte, um sie anschließend aufzubereiten und zu aggregieren, werden in Abschn.\ \ref{sec:dfTransform} und \ref{sec:dplyr} dargestellt.

\index{Datensatz!erstellen}
\index[func]{data.frame()@\lstinline{data.frame()}}
Objekte der Klasse \lstinline!data.frame! sind die bevorzugte Organisationsweise für empirische Datensätze.\footnote{Außer bei sehr großen Datensätzen, die sich effizienter als Matrix verarbeiten lassen.} Die Komponenten spielen dabei die Rolle von Variablen. Werden Datensätze in R ausgegeben, stehen die Variablen als Komponenten in den Spalten, während jede Zeile für eine Beobachtungseinheit\index{Datensatz!Aufbau} steht. Datensätze werden mit \lstinline!data.frame(<<Objekt1>>, <<Objekt2>>, ...)! aus mehreren einzelnen Objekten erzeugt, die typischerweise Vektoren oder Faktoren sind. Matrizen werden dabei wie separate, durch die Spalten der Matrix gebildete Vektoren behandelt.\footnote{Gleiches gilt für Listen -- hier werden die Komponenten als separate Vektoren gewertet. Soll dieses Verhalten verhindert werden, um eine Liste als eine einzelne Variable des Datensatzes zu erhalten, muss sie in \lstinline!I()!\index[func]{I()@\lstinline{I()}} eingeschlossen werden: \lstinline!data.frame(I(<<Liste>>), <<Objekt2>>, ...)!. Datensätze mit Listen als Variablen werden hier zur Vereinfachung nicht weiter betrachtet.} Die Objektnamen bilden die Variablennamen im Datensatz, wenn sie nicht mit \lstinline!data.frame(<<Name>>=<<Objekt>>)! geändert werden.

% \index[func]{stringsAsFactors@\lstinline{stringsAsFactors}}
% Bis einschließlich R Version 3.6.3 wurden Variablen mit Zeichenketten von \lstinline!data.frame()! in der Voreinstellung \lstinline!stringsAsFactors=TRUE! automatisch in Gruppierungsfaktoren (Klasse \lstinline!factor!, Abschn.\ \ref{sec:factor}) konvertiert. Sollen stattdessen \lstinline!character! Vektoren gebildet werden, ist dieses Argument auf \lstinline!FALSE! zu setzen. Beginnend mit R Version 4.0.0 ist \lstinline!FALSE! die Voreinstellung, so dass keine automatische Konvertierung stattfindet.

Als Beispiel seien $12$ Personen betrachtet, die zufällig auf drei Untersuchungsgruppen (Kontrollgruppe \lstinline!CG!, Wartelisten-Gruppe \lstinline!WL!, Treatment-Gruppe \lstinline!T!) verteilt werden. Als Variablen werden demografische Daten, Ratings und der IQ-Wert simuliert. Zudem soll die fortlaufende Nummer jeder Person gespeichert werden.\footnote{Die automatisierte\index{Simulation} Simulation von Datensätzen nach vorgegebenen Kriterien ist mit dem Paket \lstinline!simstudy!\index[pack]{simstudy@\lstinline{simstudy}} \cite{Goldfeld2024} möglich.}
\begin{lstlisting}
> N      <- 12
> sex    <- sample(c("f", "m"), N, replace=TRUE)
> group  <- sample(rep(c("CG", "WL", "T"), 4), N, replace=FALSE)
> age    <- sample(18:35, N, replace=TRUE)
> IQ     <- round(rnorm(N, mean=100, sd=15))
> rating <- round(runif(N, min=0, max=6))
> (myDf1 <- data.frame(id=1:N, sex, group, age, IQ, rating))
    id  sex  group  age   IQ  rating
 1   1    f      T   26  112       1
 2   2    m     CG   30  122       3
 3   3    m     CG   25   95       5
 4   4    m      T   34  102       5
 5   5    m     WL   22   82       2
 6   6    f     CG   24  113       0
 7   7    m      T   28   92       3
 8   8    m     WL   35   90       2
 9   9    m     WL   23   88       3
10  10    m     WL   29   81       5
11  11    m     CG   20   92       1
12  12    f      T   21   98       1
\end{lstlisting}

In der ersten Spalte der Ausgabe befinden sich die Zeilennamen, die in der Voreinstellung mit den Zeilennummern übereinstimmen. Eine spätere Teilauswahl der Zeilen (Abschn.\ \ref{sec:subset}, \ref{sec:dplyr_subset}) hebt diese Korrespondenz jedoch häufig auf.

\index{Datensatz!Dimensionierung}
\index[func]{dim()@\lstinline{dim()}}
\index[func]{nrow()@\lstinline{nrow()}}
\index[func]{ncol()@\lstinline{ncol()}}
\index[func]{length()@\lstinline{length()}}
\index[func]{summary()@\lstinline{summary()}}
Die Anzahl von Beobachtungen (Zeilen) und Variablen (Spalten) kann wie bei Matrizen mit \lstinline!dim(<<Datensatz>>)!, \lstinline!nrow(<<Datensatz>>)! und \lstinline!ncol(<<Datensatz>>)! ausgegeben werden. Die mit \lstinline!length()! ermittelte Länge eines Datensatzes ist die Anzahl der in ihm gespeicherten Variablen, also Spalten. Eine Übersicht über Art und Werte aller Variablen eines Datensatzes erhält man durch \lstinline!summary(<<Datensatz>>)!.
\begin{lstlisting}
> dim(myDf1)
[1] 12  6

> nrow(myDf1)
[1] 12

> ncol(myDf1)
[1] 6

> summary(myDf1)                                    # gekürzte Ausgabe
           id      sex          ...      age              IQ       ...
Min.   : 1.00  Length:12        ...  Min.   :20.00  Min.   : 81.00 ...
1st Qu.: 3.75  Class :character ...  1st Qu.:22.75  1st Qu.: 89.50 ...
Median : 6.50  Mode  :character ...  Median :25.50  Median : 93.50 ...
Mean   : 6.50                        Mean   :26.42  Mean   : 97.25 ...
3rd Qu.: 9.25                        3rd Qu.:29.25  3rd Qu.:104.50 ...
Max.   :12.00                        Max.   :35.00  Max.   :122.00 ...
\end{lstlisting}

\index[func]{head()@\lstinline{head()}}
\index[func]{tail()@\lstinline{tail()}}
\index[func]{View()@\lstinline{View()}}
\index{Daten!Viewer}
Will man sich einen Überblick über die in einem Datensatz gespeicherten Werte verschaffen, können die Funktionen \lstinline!head(<<Datensatz>>, n=<<Anzahl>>)! und \lstinline!tail(<<Datensatz>>, n=<<Anzahl>>)! verwendet werden, die seine ersten bzw.\ letzten \lstinline!n! Zeilen anzeigen. Mit \lstinline!View(<<Datensatz>>)! ist es zudem möglich, ein separates Fenster -- in RStudio ein Tab -- mit dem Inhalt eines Datensatzes zu öffnen. Dessen Werte sind dabei vor Veränderungen geschützt.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datentypen in Datensätzen}
\label{sec:dfDataTypes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Mit \lstinline!str(<<Datensatz>>)!\index[func]{str()@\lstinline{str()}} kann die interne Struktur des Datensatzes erfragt werden, d.\,h.\ aus welchen Gruppierungsfaktoren und wie vielen Beobachtungen an welchen Variablen er besteht.
\begin{lstlisting}
> str(myDf1)
data.frame': 12 obs. of 6 variables:
$ id    : int  1 2 3 4 5 6 7 8 9 10 ...
$ sex   : chr  "f" "m" "m" "m" ...
$ group : chr  "T" "CG" "CG" "T" ...
$ age   : int  26 30 25 34 22 24 28 35 23 29 ...
$ IQ    : num  112 122 95 102 82 113 92 90 88 81 ...
$ rating: num  1 3 5 5 2 0 3 2 3 5 ...
\end{lstlisting}

Ist gewünscht, dass ein \lstinline!character! Vektor als Objekt der Klasse \lstinline!factor! im Datensatz enthalten ist, so ist er vor oder nach der Zusammenstellung des Datensatzes manuell mit \lstinline!factor()! zu konvertieren.
\begin{lstlisting}
> group_fac <- factor(group)
> myDf2     <- data.frame(group_fac, IQ)
> str(myDf2)
'data.frame':	12 obs. of  2 variables:
 $ group_fac: Factor w/ 3 levels "CG","T","WL": 2 1 1 2 3 1 2 3 3 3 ...
 $ IQ       : num  112 122 95 102 82 113 92 90 88 81 ...
\end{lstlisting}

Matrizen und Vektoren können mit \lstinline!as.data.frame(<<Objekt>>)!\index[func]{as.data.frame()@\lstinline{as.data.frame()}}\index{Datensatz!Umwandlung in Datensatz} in einen Datensatz umgewandelt werden. Dabei sind die in Matrizen und Vektoren notwendigerweise identischen Datentypen nachträglich zu konvertieren, wenn sie eigentlich unterschiedliche Variablentypen repräsentieren. Listen können in Datensätze umgewandelt werden, wenn ihre Komponenten alle dieselbe Länge besitzen.

Umgekehrt lassen sich Datensätze mit \lstinline!data.matrix(<<Datensatz>>)!\index[func]{data.matrix()@\lstinline{data.matrix()}} und auch mit \lstinline!as.matrix(<<Datensatz>>)!\index[func]{as.matrix()@\lstinline{as.matrix()}} zu Matrizen machen, wobei alle Werte in denselben Datentyp umgewandelt werden: Bei \lstinline!data.matrix()! ist der Datentyp immer \lstinline!numeric!, bei \lstinline!as.matrix()! der umfassendste Datentyp, der notwendig ist, um alle Werte ohne Informationsverlust zu speichern (Abschn.\ \ref{sec:dataTypes}). Bei der Umwandlung in eine Liste mit \lstinline!as.list(<<Datensatz>>)!\index[func]{as.list()@\lstinline{as.list()}} ist dagegen keine Umwandlung der Datentypen notwendig.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elemente auswählen und verändern}
\label{sec:dfIndex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Datensatz!Elemente auswählen und verändern}
\index{Datensatz!indizieren}
\index[func]{[[]]@\lstinline{[[]]}}
\index[func]{$@\lstinline{$}}
Um einzelne Elemente anzeigen zu lassen und diese zu ändern, lassen sich dieselben Befehle wie bei Listen verwenden. Um Teilmengen von Beobachtungen oder Variablen auszuwählen, sind aber die in Abschn.\ \ref{sec:subset} bzw.\ \ref{sec:dplyr_subset} vorgestellten Methoden oft übersichtlicher.
\begin{lstlisting}
> myDf1[[3]][2]                     # 2. Element der 3. Variable
[1] CG
Levels: CG T WL

> myDf1$rating                      # Variable rating
[1] 1 3 5 5 2 0 3 2 3 5 1 1

> myDf1$age[4]                      # Alter der 4. Person
[1] 34

> myDf1$IQ[10:12] <- c(99, 110, 89) # ändere IQ-Werte Person 10-12
\end{lstlisting}

Als Besonderheit können Datensätze analog zu Matrizen mit dem Operator
\begin{itemize}
\item \lstinline![<<Index Element der Komponente>>, <<Index der Komponente>>]!\index[func]{[]@\lstinline{[]}}
\end{itemize}
indiziert werden. Bei dieser Variante bleibt die gewohnte Reihenfolge von Zeile (entspricht einem Beobachtungsobjekt) -- Spalte (entspricht einer Variable) erhalten, ist also in vielen Fällen dem \lstinline![[<<Index>>]]! Operator vorzuziehen.
\begin{lstlisting}
> myDf1[3, 4]                       # 3. Element der 4. Variable
[1] 25

> myDf1[4, "group"]                 # 4. Person, Variable group
[1] T
Levels: CG T WL
\end{lstlisting}

Wie bei Matrizen gilt das Weglassen eines Index unter Beibehaltung des Kommas als Anweisung, die Werte von allen Indizes der ausgelassenen Dimension anzuzeigen.\footnote{Das Komma ist von Bedeutung: So gibt etwa \lstinline!<<Datensatz>>[3]! wie in Listen nicht die dritte Variable von \lstinline!<<Datensatz>>! zurück, sondern einen Datensatz, dessen einzige Komponente diese Variable ist.} Auch hier ist das Argument \lstinline!drop=FALSE!\index[func]{drop@\lstinline{drop}} notwendig, wenn ein einspaltiges Ergebnis bei der Ausgabe weiterhin ein Datensatz sein soll. Bei der Arbeit mit Indexvektoren, um Spalten eines Datensatzes auszuwählen, ist häufig im voraus nicht absehbar, ob letztlich nur eine oder mehrere Spalten auszugeben sind. Um inkonsistentes Verhalten zu vermeiden, empfiehlt es sich in solchen Situationen, \lstinline!drop=FALSE! in jedem Fall zu verwenden.
\begin{lstlisting}
> myDf1[2, ]        # alle Werte der 2. Person -> Ergebnis Datensatz
  id  sex  group  age   IQ  rating
2  2    m     CG   30  122       3

> myDf1[ , "age"]   # alle Elemente Variable age -> Ergebnis Vektor
[1] 26 30 25 34 22 24 28 35 23 29 20 21

> myDf1[1:5, 4, drop=FALSE]         # Variable als Datensatz
  age
1  26
2  30
3  25
4  34
5  22
\end{lstlisting}

% Enthält der Datensatz möglicherweise fehlende Werte, müssen diese zunächst im Indexvektor mit \lstinline!is.na()! identifiziert und logisch ausgeschlossen werden (Abschn.\ \ref{sec:isna}).
% \begin{lstlisting}
% > ok <- myDf1$sex == "f"            # Indizes weibliche Personen
% > myDf1[ok & !is.na(ok), ]          # entferne ggf. NA aus Indexvektor
%     id  sex  group  age   IQ  rating
% 1    1    f      T   26  112       1
% 6    6    f     CG   24  113       0
% 12  12    f      T   21   89       1
% \end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Namen von Variablen und Beobachtungen}
\label{sec:rowNames}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Datensatz!Variablennamen}
\index[func]{dimnames()@\lstinline{dimnames()}}
Die Funktion \lstinline!dimnames(<<Datensatz>>)! dient dazu, die Namen eines Datensatzes auf beiden Dimensionen (Zeilen und Spalten, also meist Beobachtungsobjekte und Variablen) zu erfragen und auch zu ändern.\footnote{Namen werden als Attribut gespeichert und sind mit \lstinline!attributes(<<Datensatz>>)! sichtbar (Abschn.\ \ref{sec:objects}).} Sie gibt eine Liste aus, in der die einzelnen Namen für jede der beiden Dimensionen als Komponenten enthalten sind. Wurden die Zeilen nicht benannt, werden ihre Nummern ausgegeben.
\begin{lstlisting}
> dimnames(myDf1)
[[1]]
[1] "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12"

[[2]]
[1] "id" "sex" "group" "age" "IQ" "rating"
\end{lstlisting}

Die Namen der Variablen in einem Datensatz können mit der \lstinline!names(<<Datensatz>>)!\index[func]{names()@\lstinline{names()}} Funktion erfragt werden.
\begin{lstlisting}
> names(myDf1)
[1] "id" "sex" "group" "age" "IQ" "rating"
\end{lstlisting}

Die Bezeichnungen der Zeilen können mit \lstinline!rownames(<<Datensatz>>)!\index[func]{rownames()@\lstinline{rownames()}} ausgegeben und auch geändert werden. Abschnitt \ref{sec:df_rename} bzw.\ \ref{sec:dplyr_rename} stellen vor, wie Variablen umbenannt werden können.
\begin{lstlisting}
> (rows <- paste("Z", 1:12, sep=""))
[1] "Z1" "Z2" "Z3" "Z4" "Z5" "Z6" "Z7" "Z8" "Z9" "Z10" "Z11" "Z12"

> rownames(myDf1) <- rows
> head(myDf1)
   id  sex  group  age   IQ  rating
Z1  1    f      T   26  112       1
Z2  2    m     CG   30  122       3
Z3  3    m     CG   25   95       5
Z4  4    m      T   34  102       5
Z5  5    m     WL   22   82       2
Z6  6    f     CG   24  113       0

> rownames(myDf1) <- NULL                 # entferne Zeilennamen
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datensätze in den Suchpfad einfügen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Datensatz!Suchpfad}
\index{Suchpfad|see{Datensatz}}
Die in einem Datensatz vorhandenen Variablen sind außerhalb des Datensatzes unbekannt. Enthält ein Datensatz \lstinline!myDf! die Variable \lstinline!var!, so kann auf diese mit \lstinline!myDf$var!, nicht aber einfach mit \lstinline!var! zugegriffen werden. Nun kann es bequem sein, die Variablennamen auch ohne das wiederholte Aufführen von \lstinline!myDf$! zu verwenden. Eine temporär wirkende Möglichkeit hierzu bietet\index[func]{with()@\lstinline{with()}} \lstinline!with()!.
\begin{lstlisting}
with(data=<<Datensatz>>, expr=<<R-Befehle>>)
\end{lstlisting}

Innerhalb der unter \lstinline!expr! angegebenen Befehle sind die Variablennamen des unter \lstinline!data! genannten Datensatzes bekannt. Der Datensatz selbst kann innerhalb von \lstinline!with()! nicht verändert, sondern nur gelesen werden.
\begin{lstlisting}
> with(myDf1, tapply(IQ, group, FUN=mean))
    KG       T     WL
105.50  101.00  85.25
\end{lstlisting}

Demselben Zweck dient in vielen Funktionen das Argument
\lstinline!data=<<Datensatz>>!, das es erlaubt, in anderen Argumenten der Funktion Variablen von \lstinline!data! zu verwenden.
\begin{lstlisting}
> xtabs(~ sex + group, data=myDf1)   # xtabs() -> folgender Abschnitt
         group
sex  CG  T  WL
  f   1  2   0
  m   3  2   4
\end{lstlisting}

Mit \lstinline!attach(<<Datensatz>>)!\index[func]{attach()@\lstinline{attach()}} ist es möglich, einen Datensatz in den Suchpfad einzuhängen und die Namen seiner Variablen so auch permanent ohne wiederholtes Voranstellen von \lstinline!<<Datensatz>>$! verfügbar zu machen. Dies wird etwa an der Ausgabe von \lstinline!search()! deutlich, die den Datensatz nach Einhängen in den Suchpfad mit aufführt (Abschn.\ \ref{sec:objectNames}).
\begin{lstlisting}
> IQ[3]
Fehler: Objekt "IQ" nicht gefunden

> attach(myDf1)
> IQ[3]
[1] 95

> search()[1:4]
[1] ".GlobalEnv"  "myDf1"  "package:grDevices"  "package:datasets"
\end{lstlisting}

Wichtig ist, dass durch \lstinline!attach()! Kopien aller Variablen des Datensatzes angelegt werden.\footnote{Bei sehr großen Datensätzen empfiehlt es sich daher aus Gründen der Speichernutzung, nur eine geeignete Teilmenge von Fällen mit \lstinline!attach()! verfügbar zu machen (Abschn.\ \ref{sec:subset}, \ref{sec:dplyr_subset}).} Greift man daraufhin auf eine Variable \lstinline!var! ohne Nennung von \lstinline!myDf$! zu, so verwendet man diese Kopie. Insbesondere schlagen sich spätere Änderungen am Datensatz selbst nicht in den früher angelegten Kopien nieder, genauso wirken sich Veränderungen an den Kopien nicht auf den eigentlichen Datensatz aus. Wegen dieser Gefahr, nicht synchronisierte Änderungen vorzunehmen, sollte auf \lstinline!attach()! generell verzichtet werden.

Mit dem Befehl \lstinline!detach(<<Datensatz>>)!\index[func]{detach()@\lstinline{detach()}} kann der Datensatz wieder aus dem Suchpfad entfernt werden, wenn nicht mehr auf seine Variablen zugegriffen werden muss. Dies sollte nicht vergessen werden, sonst besteht das Risiko, mit einem neuerlichen Aufruf von \lstinline!attach()! denselben Datensatz mehrfach verfügbar zu machen, was für Verwirrung sorgen kann.
\begin{lstlisting}
> IQ[3] <- 130                            # Änderung der Kopie
> IQ[3]
[1] 130

> myDf1$IQ[3]                             # Original
[1] 95

> detach(myDf1)
> IQ
Fehler: Objekt "IQ" nicht gefunden
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Häufigkeiten bestimmen}
\label{sec:table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Bei der Analyse kategorialer Variablen besteht ein typischer Auswertungsschritt darin, die Auftretenshäufigkeiten der Kategorien auszuzählen und relative sowie bedingte relative Häufigkeiten zu berechnen. Wird nur eine Variable betrachtet, ergeben sich einfache Häufigkeitstabellen, bei mehreren Variablen mehrdimensionale Kontingenztafeln der gemeinsamen Häufigkeiten.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Einfache Tabellen absoluter und relativer Häufigkeiten}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!absolute}
\index[func]{table()@\lstinline{table()}}
Eine Tabelle der absoluten Häufigkeiten von Variablenwerten erstellt \lstinline!table(<<Faktor>>)! und erwartet dafür als Argument ein eindimensionales Objekt, das sich als Faktor interpretieren lässt, z.\,B.\ einen Vektor. Das Ergebnis ist eine Übersicht über die Auftretenshäufigkeit jeder vorkommenden Ausprägung, wobei fehlende Werte ignoriert werden.\footnote{Fehlende Werte können mit in die Auszählung einbezogen werden, indem der Vektor in\index[func]{addNA()@\lstinline{addNA()}} \lstinline!addNA()! eingeschlossen wird.}
\begin{lstlisting}
> (myLetters <- sample(LETTERS[1:5], size=12, replace=TRUE))
[1] "C" "D" "A" "D" "E" "D" "C" "E" "E" "B" "E" "E"

> table(myLetters)
myLetters
A  B  C  D  E
1  1  2  3  5
\end{lstlisting}

Häufigkeitstabellen können alternativ mit der Funktion\index[func]{xtabs()@\lstinline{xtabs()}} \lstinline!xtabs()! erstellt werden, die sich insbesondere dann eignet, wenn die Variablen aus Datensätzen stammen.
\begin{lstlisting}
xtabs(formula=<<Modellformel>>, data=<<Datensatz>>, addNA=FALSE)
\end{lstlisting}

Im ersten Argument wird eine \emph{Modellformel} erwartet (Abschn.\ \ref{sec:formula}). Hier ist dabei rechts der \lstinline!~! der Faktor zu nennen, von dessen Stufen die Häufigkeiten gezählt werden sollen. Durch \lstinline!addNA=TRUE! führt die Häufigkeitstabelle fehlende Werte als separate Gruppe auf. Stammen die in der Modellformel genannten Variablen aus einem Datensatz, ist dieser unter \lstinline!data! zu nennen. Eine links der \lstinline!~! genannte Variable wird als Vektor von Häufigkeiten interpretiert, die pro Stufe des rechts der \lstinline!~! genannten Faktors zu addieren sind.
\begin{lstlisting}
> (tab <- xtabs(~ myLetters))
myLetters
A  B  C  D  E 
1  1  2  3  5
\end{lstlisting}

In der oberen Zeile der Ausgabe sind die Ausprägungen der Variable, in der unteren Zeile die jeweils zugehörigen Auftretenshäufigkeiten aufgeführt. Eindimensionale Häufigkeitstabellen verhalten sich wie Vektoren mit benannten Elementen, wobei die Benennungen den vorhandenen Ausprägungen der Variable entsprechen. Die Ausprägungen lassen sich mit dem Befehl \lstinline!names(<<Tabelle>>)! separat ausgeben.
\begin{lstlisting}
> names(tab)
[1] "A" "B" "C" "D" "E"

> tab["B"]
B
1
\end{lstlisting}

\index{Haufigkeiten@Häufigkeiten!relative}
\index{Haufigkeiten@Häufigkeiten!kumulierte relative}
\index[func]{proportions()@\lstinline{proportions()}}
Relative Häufigkeiten ergeben sich durch Division der absoluten Häufigkeiten mit der Gesamtzahl der Beobachtungen. Für diese Rechnung existiert die Funktion \lstinline!proportions(<<Tabelle>>)!, welche als Argument eine Tabelle der absoluten Häufigkeiten erwartet und die relativen Häufigkeiten ausgibt. Durch Anwendung von \lstinline!cumsum()! auf das Ergebnis erhält man die kumulierten relativen Häufigkeiten (für eine andere Methode und die Berechnung von Prozenträngen s.\ Abschn.\ \ref{sec:stepfun}).
\begin{lstlisting}
> (relFreq <- proportions(tab))     # relative Häufigkeiten
myLetters
         A           B           C           D           E
0.08333333  0.08333333  0.16666667  0.25000000  0.41666667

> cumsum(relFreq)                   # kumulierte relative Häufigkeiten
         A           B           C           D           E
0.08333333  0.16666667  0.33333333  0.58333333  1.00000000
\end{lstlisting}

Kommen mögliche Variablenwerte in einem Vektor nicht vor, so tauchen sie auch in einer Häufigkeitstabelle nicht als ausgezählte Kategorie auf. Um deutlich zu machen, dass Variablen außer den tatsächlich vorhandenen Ausprägungen potentiell auch weitere Werte annehmen, können die Daten vorab in einen Faktor umgewandelt werden. Dem Faktor lässt sich dann der nicht auftretende, aber prinzipiell mögliche Wert als weitere Stufe hinzufügen.
\begin{lstlisting}
> letFac <- factor(myLetters, levels=c(LETTERS[1:5], "Q"))
> letFac
[1] C D A D E D C E E B E E
Levels: A B C D E Q

> xtabs(~ letFac)
letFac
A  B  C  D  E  Q
1  1  2  3  5  0
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Iterationen zählen}
\label{sec:runs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!Iterationen}
\index{Iterationen|see{Häufigkeiten}}
\index[func]{rle()@\lstinline{rle()}}
Eine \emph{Iteration} innerhalb einer Abfolge von Symbolen ist ein Abschnitt, der aus der ein- oder mehrfachen Wiederholung desselben Symbols besteht (\emph{run}). Iterationen werden durch Iterationen eines anderen Symbols begrenzt, oder besitzen kein vorangehendes bzw.\ auf sie folgendes Symbol. Die Iterationen eines Vektors zählt die \lstinline!rle(<<Vektor>>)! Funktion, deren Ergebnis eine Liste mit zwei Komponenten ist: Die erste Komponente \lstinline!lengths! ist ein Vektor, der die jeweilige Länge jeder Iteration als Elemente besitzt. Die zweite Komponente \lstinline!values! ist ein Vektor mit den Symbolen, um die es sich bei den Iterationen handelt (Abschn.\ \ref{sec:list}).
\begin{lstlisting}
> (vec <- rep(rep(c("f", "m"), times=3), times=c(1, 3, 2, 4, 1, 2)))
[1] "f" "m" "m" "m" "f" "f" "m" "m" "m" "m" "f" "m" "m"

> (res <- rle(vec))
Run Length Encoding
lengths: int [1:6] 1 3 2 4 1 2
values : chr [1:6] "f" "m" "f" "m" "f" "m"

> length(res$lengths)                 # zähle Anzahl der Iterationen
[1] 6
\end{lstlisting}

\index[func]{inverse.rle()@\lstinline{inverse.rle()}}
Aus der jeweiligen Länge und dem wiederholten Symbol jeder Iteration lässt sich die ursprüngliche Sequenz eindeutig rekonstruieren. Dies kann durch die \lstinline!inverse.rle(<<rle-Ergebnis>>)! Funktion geschehen, die eine Liste erwartet, wie sie \lstinline!rle()! als Ergebnis besitzt.
\begin{lstlisting}
> inverse.rle(res)
[1] "f" "m" "m" "m" "f" "f" "m" "m" "m" "m" "f" "m" "m"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Absolute und (bedingte) relative relative Häufigkeiten in Kreuztabellen}
\label{sec:xtabs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!Kreuztabelle}
\index{Kreuztabelle|see{Häufigkeiten}}
\index{Kontingenztafel|see{Häufigkeiten}}
Mit \lstinline!xtabs(~ <<Faktor1>> + <<Faktor2>> + ...)! können mehrdimensionale Kontingenztafeln erstellt werden.\footnote{Analog \lstinline!table(<<Faktor1>>, <<Faktor2>>, ...)!.} Die Elemente der Faktoren an gleicher Position werden als denselben Beobachtungsobjekten zugehörig interpretiert. Das erste Element von \lstinline!<<Faktor1>>! bezieht sich also auf dieselbe Beobachtung wie das erste Element von \lstinline!<<Faktor2>>!, usw. Das Ergebnis ist eine Kreuztabelle mit den gemeinsamen absoluten Häufigkeiten der Merkmale, wobei die Ausprägungen des zuerst genannten Faktors in den Zeilen stehen. Links der \lstinline!~! kann auch eine -- ggf.\ mit \lstinline!cbind()! aus Variablen zusammengefügte -- Matrix stehen, deren Spaltenwerte dann jeweils pro Stufenkombination addiert werden.

Als Beispiel sollen Personen betrachtet werden, die nach ihrem Geschlecht und dem Ort ihres Arbeitsplatzes unterschieden werden. An diesen Personen sei weiterhin eine Gruppenzugehörigkeit sowie eine Variable erhoben worden, die die absolute Häufigkeit eines Ereignisses codiert.
\begin{lstlisting}
> N <- 10
> (persons <- data.frame(
+     sex  =factor(sample(c("home", "office"), size=N, replace=TRUE)),
+     work =factor(sample(c("f", "m"),         size=N, replace=TRUE)),
+     group=factor(sample(c("A", "B"),         size=N, replace=TRUE)),
+     counts=      sample(0:5,                 size=N, replace=TRUE)))
   sex   work group counts
1    f   home     B      0
2    m office     B      3
3    f office     A      3
4    m   home     B      1
5    m   home     A      1
6    f office     B      1
7    m office     A      3
8    f office     B      5
9    m office     A      2
10   m office     A      4

# gemeinsame absolute Häufigkeiten von Geschlecht und Arbeitsplatz
> (absFreq <- xtabs(~ sex + work, data=persons))
   work
sex home office
  f    1      3
  m    2      4

# Summe von counts pro Zelle
> xtabs(counts ~ sex + work, data=persons)
        work
sex  home  office
  f     0       9
  m     2      12
\end{lstlisting}

\index{Haufigkeiten@Häufigkeiten!bedingte relative}
Um relative Häufigkeiten auf Basis von Kreuztabellen absoluter Häufigkeiten zu ermitteln, eignet sich die \lstinline!proportions()! Funktion. Für bedingte relative Häufigkeiten besitzt sie ein zweites Argument \lstinline!margin!, an das etwa \lstinline!1! zur Bestimmung der auf die Zeilen bezogenen bedingten relativen Häufigkeiten übergeben werden kann. Jede Zeile der Tabelle absoluter Häufigkeiten wird dafür durch die zugehörige Zeilensumme dividiert. Mit \lstinline!margin=2! erhält man analog die auf die Spalten bezogenen bedingten relativen Häufigkeiten. Bei benannten Zeilen bzw.\ Spalten ist auch \lstinline!margin="<<Name>>"! möglich.
\begin{lstlisting}
> (relFreq <- proportions(absFreq))         # relative Häufigkeiten
        work
sex  home  office
  f   0.1     0.3
  m   0.2     0.4

> proportions(absFreq, 1)       # auf Zeilen bedingte rel. Häufigk.
              work
sex       home     office
  f  0.2500000  0.7500000
  m  0.3333333  0.6666667

> proportions(absFreq, "work")  # auf Spalten bedingte rel. Häufigk.
              work
sex       home     office
  f  0.3333333  0.4285714
  m  0.6666667  0.5714286

# manuelle Kontrolle
> rSums <- rowSums(relFreq)     # Zeilensummen
> cSums <- colSums(relFreq)     # Spaltensummen
> sweep(relFreq, 1, rSums, "/") # auf Zeilen bedingte rel. Häufigk...
> sweep(relFreq, 2, cSums, "/") # auf Spalten bedingte rel. Häufigk...
\end{lstlisting}

Um Häufigkeitsauszählungen für mehr als zwei Variablen zu berechnen, können beim Aufruf von \lstinline!xtabs()! in der Modellformel rechts der \lstinline!~! einfach weitere Faktoren mit \lstinline!+! hinzugefügt werden. Die Ausgabe verhält sich dann wie ein array. Hierbei werden etwa im Fall von drei Variablen so viele zweidimensionale Kreuztabellen ausgegeben, wie Stufen der dritten Variable vorhanden sind. Soll dagegen auch in diesem Fall eine einzelne Kreuztabelle mit verschachteltem Aufbau erzeugt werden, ist\index[func]{ftable()@\lstinline{ftable()}} \lstinline!ftable()! (\emph{flat table}) zu nutzen.
\begin{lstlisting}
ftable(x, row.vars=NULL, col.vars=NULL)
\end{lstlisting}

Unter \lstinline!x! kann entweder eine bereits mit \lstinline!xtabs()! erzeugte Kreuztabelle eingetragen werden, oder aber eine durch Komma getrennte Reihe von Faktoren bzw.\ von Objekten, die sich als Faktor interpretieren lassen. Die Argumente \lstinline!row.vars! und \lstinline!col.vars! kontrollieren, welche Variablen in den Zeilen und welche in den Spalten angeordnet werden. Beide Argumente akzeptieren numerische Vektoren mit den Nummern der entsprechenden Variablen, oder aber Vektoren aus Zeichenketten, die den Namen der Faktoren entsprechen.
\begin{lstlisting}
> with(persons,
+      ftable(work, sex, group,
+             row.vars="work", col.vars=c("sex", "group")))
         sex    f      m
       group  A  B   A  B
work
home          0  1   1  1
office        1  2   3  1
\end{lstlisting}

Einen Überblick über die Zahl der in einer Häufigkeitstabelle ausgewerteten Faktoren sowie die Anzahl der zugrundeliegenden Beobachtungen erhält man mit\index[func]{summary()@\lstinline{summary()}} \lstinline!summary(<<Tabelle>>)!. Im Fall von Kreuztabellen wird hierbei zusätzlich ein $\chi^{2}$-Test auf Unabhängigkeit bzw.\ auf Gleichheit von Verteilungen berechnet (Abschn.\ \ref{sec:chisqInd}, \ref{sec:chisqEq}).
\begin{lstlisting}
> summary(xtabs(~ sex + work, data=persons))
Number of cases in table: 10
Number of factors: 2
Test for independence of all factors:
Chisq = 4.444, df = 1, p-value = 0.03501
Chi-squared approximation may be incorrect
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Randkennwerte von Kreuztabellen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!Randkennwerte}
Um Randsummen, Randmittelwerte oder ähnliche Kennwerte für eine Kreuztabelle zu berechnen, können alle für Matrizen vorgestellten Funktionen verwendet werden, insbesondere \lstinline!apply()!, aber etwa auch \lstinline!rowSums()! und \lstinline!colSums()! sowie \lstinline!rowMeans()! und \lstinline!colMeans()!. Hier nimmt die Tabelle die Rolle der Matrix ein.
\begin{lstlisting}
> colMeans(xtabs(~ sex + work, data=persons))      # Spaltenmittel
home  office
 1.5     3.5
\end{lstlisting}

\lstinline!addmargins()!\index[func]{addmargins()@\lstinline{addmargins()}} berechnet beliebige Randkennwerte für eine Kreuztabelle \lstinline!A! entsprechend der mit dem Argument \lstinline!FUN! bezeichneten Funktion (Voreinstellung ist \lstinline!sum! für Randsummen). Die Funktion operiert separat über jeder der mit dem Vektor \lstinline!margin! bezeichneten Dimensionen -- in der Voreinstellung über alle. Die Ergebnisse der Anwendung von \lstinline!FUN! werden \lstinline!A! in der Ausgabe als weitere Zeile und Spalte hinzugefügt.
\begin{lstlisting}
addmargins(A=<<Tabelle>>, margin=<<Vektor>>, FUN=<<Funktion>>)
\end{lstlisting}

\begin{lstlisting}
> addmargins(xtabs(~ sex + work, data=persons))    # Randsummen
            work
sex  home  office  sum
  f     1       3    4
  m     2       4    6
sum     3       7   10
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datensätze aus Häufigkeitstabellen erstellen}
\label{sec:tab2df}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In manchen Situationen liegen Daten nur in Form von Häufigkeitstabellen vor -- etwa wenn sie aus der Literatur übernommen werden. Um die Daten selbst auszuwerten, ist es dann notwendig, sie zunächst in ein Format umzuwandeln, das die Variablen als separate Spalten verwendet und pro Beobachtungsobjekt eine Zeile besitzt. Diese Aufgabe erledigt die Funktion \lstinline!Untable()!\index[func]{Untable()@\lstinline{Untable()}} aus dem Paket \index[pack]{DescTools@\lstinline{DescTools}} \lstinline!DescTools!. Als Ausgabe liefert sie einen Datensatz.
\begin{lstlisting}
> cTab <- xtabs(~ sex + work, data=persons)     # Kreuztabelle
> library(DescTools)                            # für Untable()
> Untable(cTab)
   sex   work
1    f   home
2    f office
3    f office
4    f office
5    m   home
6    m   home
7    m office
8    m office
9    m office
10   m office
\end{lstlisting}

Eine andere Darstellung liefert die explizite Umwandlung der Kreuztabelle in einen Datensatz mit \lstinline!as.data.frame()!. Der erzeugte Datensatz besitzt für jede Zelle der Kreuztabelle eine Zeile und neben den Spalten für die ausgezählten Variablen eine weitere Spalte \lstinline!Freq! mit der Häufigkeit der Merkmalskombination.
\begin{lstlisting}
> as.data.frame(cTab)
  sex   work Freq
1   f   home    1
2   m   home    2
3   f office    3
4   m office    4
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kumulierte relative Häufigkeiten und Prozentrang}
\label{sec:stepfun}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!kumulierte relative}
\index{kumulierte relative Häufigkeiten|see{Häufigkeiten}}
\index[func]{ecdf()@\lstinline{ecdf()}}
\lstinline!ecdf(x=<<Vektor>>)! (\emph{empirical cumulative distribution function}) ermittelt für ordinale Daten die kumulierten relativen Häufigkeiten. Diese geben für einen Wert $x_{i}$ an, welcher Anteil der Daten nicht größer als $x_{i}$ ist. Das Ergebnis ist analog zur Verteilungsfunktion quantitativer Zufallsvariablen.

Das Ergebnis von \lstinline!ecdf()! ist eine\index{Stufenfunktion} Stufenfunktion mit so vielen Sprungstellen, wie es unterschiedliche Werte in \lstinline!x! gibt. Die Höhe jedes Sprungs entspricht der relativen Häufigkeit des Wertes an der Sprungstelle. Enthält \lstinline!x! also keine mehrfach vorkommenden Werte, erzeugt \lstinline!ecdf()! eine Stufenfunktion mit so vielen Sprungstellen, wie \lstinline!x! Elemente besitzt. Dabei weist jeder Sprung dieselbe Höhe auf -- die relative Häufigkeit \lstinline!1/length(x)! jedes Elements von \lstinline!x!. Tauchen in \lstinline!x! Werte mehrfach auf, unterscheiden sich die Sprunghöhen dagegen entsprechend den relativen Häufigkeiten.

Die Ausgabe von \lstinline!ecdf()! ist ihrerseits eine Funktion, die zunächst einem eigenen Objekt zugewiesen werden muss, ehe sie die kumulierten relativen Häufigkeiten ermitteln kann. Ist \lstinline!Fn()! diese Stufenfunktion, und möchte man die kumulierten relativen Häufigkeiten der in \lstinline!x! gespeicherten Werte erhalten, ist \lstinline!x! selbst als Argument für \lstinline!Fn()! einzusetzen. Andere Werte als Argument von \lstinline!Fn()! sind aber genauso möglich. Indem \lstinline!Fn()! für beliebige Werte ausgewertet wird, lassen sich empirische und interpolierte\index{Prozentrang} Prozentränge ermitteln (Abschn.\ \ref{sec:quantile}). Mit \lstinline!ecdf()! erstellte Funktionen können über \lstinline!plot()!\index[func]{plot()@\lstinline{plot()}} in einem Diagramm gezeigt werden (Abb.\ \ref{fig:ks}, Abb.\ \ref{fig:ecdf}, Abschn.\ \ref{sec:ecdfPlot}).
\begin{lstlisting}
> (vec <- round(rnorm(10), 2))
[1] -1.57 2.21 -1.01 0.21 -0.29 -0.61 -0.17 1.90 0.17 0.55

# kumulierte relative Häufigkeiten der vorhandenen Werte
> Fn <- ecdf(vec)
> Fn(vec)
[1] 0.1 1.0 0.2 0.7 0.4 0.3 0.5 0.9 0.6 0.8

> 100 * Fn(0.1)                              # Prozentrang von 0.1
[1] 50

> 100 * (sum(vec <= 0.1) / length(vec))      # Kontrolle
[1] 50
\end{lstlisting}

Soll die Ausgabe der kumulierten relativen Häufigkeiten in der richtigen Reihenfolge erfolgen, müssen die Werte mit \lstinline!sort()! geordnet werden.
\begin{lstlisting}
> Fn(sort(vec))
[1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
\end{lstlisting}

Die Sprungstellen einer von \lstinline!ecdf()! erstellten Funktion lassen sich mit\index[func]{knots()@\lstinline{knots()}} \lstinline!knots()! extrahieren. Das Ergebnis sind gerade die in \lstinline!x! enthaltenen unterschiedlichen sortierten Werte.
\begin{lstlisting}
> knots(Fn)
[1] -1.57 -1.01 -0.61 -0.29 -0.17 0.17 0.21 0.55 1.90 2.21
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fehlende Werte behandeln}
\label{sec:na}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!Qualität}
\index{Daten!fehlende Werte|textbf}
\index{fehlende Werte|see{Daten}}
Empirische Datensätze besitzen häufig zunächst keine zufriedenstellende Qualität (Abschn.\ \ref{sec:tidyData}), wozu auch unvollständige Daten beitragen -- wenn also nicht für alle Beobachtungsobjekte Werte von allen erhobenen Variablen vorliegen. So können etwa Messgeräte defekt sein, Personen die Auskunft bzgl.\ bestimmter Fragen verweigern oder zu bearbeitende Aufgaben übersehen.

Fehlende Werte bergen aus versuchsplanerischer Perspektive die Gefahr, dass sie womöglich nicht zufällig, sondern systematisch entstanden sind und so zu verzerrten Ergebnissen führen.\footnote{Die hier relevante Unterscheidung zwischen den Szenarien \emph{missing completely at random} (MCAR), \emph{missing at random} (MAR) und \emph{not missing at random} (NMAR) erläutert \citeA{vanBuuren2012}.} Bei der statistischen Auswertung sind verschiedene Strategien des Umgangs mit fehlenden Werten denkbar, die nicht unbedingt zu gleichen Ergebnissen führen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Fehlende Werte codieren und identifizieren}
\label{sec:isna}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!codieren}
\index[func]{NA@\lstinline{NA}}
Wenn ein Datensatz eingegeben wird und fehlende Werte vorliegen, müssen sie explizit mit der Konstante \lstinline!NA! (\emph{not available}) codiert werden. Auch bei \lstinline!character! Vektoren ist dabei \lstinline!NA! nicht in Anführungszeichen zu setzen.\footnote{\label{ftn:na_type}Für jeden Datentyp existiert jeweils eine passende Konstante, nämlich \lstinline!NA_real_!, \lstinline!NA_integer_! und \lstinline!NA_character_!. All diese Konstanten werden aber als \lstinline!NA! angezeigt. Der mit \lstinline!typeof(NA)! ausgegebene Basis-Datentyp ist \lstinline!logical!. Damit ist die Ausgabe etwa von \lstinline!c(1, 2, 3)[NA]! gleich \lstinline!NA NA NA!, da logische Indexvektoren zyklisch verlängert werden (Abschn.\ \ref{sec:vecSel}, \ref{sec:which}).}
\begin{lstlisting}
> (vec1 <- c(10, 20, NA, 40, 50, NA))
[1] 10 20 NA 40 50 NA

> length(vec1)      # fehlende Werte werden bei length() mitgezählt
[1] 6
\end{lstlisting}

In manchen Situationen werden Zeichenketten prinzipiell ohne Anführungszeichen ausgegeben, etwa als Faktorstufen oder Datensätzen. Zur leichteren Unterscheidung von gültigen Zeichenketten erscheinen fehlende Werte deshalb dann als \lstinline!<NA>!.\footnote{In solchen Situationen ist also \lstinline!NA! die Ausgabe eines gültigen Elements und von einem fehlenden Wert \lstinline!<NA>! zu unterscheiden. So erzeugt \lstinline!factor(c("A", "NA", "C"))[c(NA, 2, 3)]! die Ausgabe \lstinline!<NA> NA C!. Einzig die gültige Faktorstufe \lstinline!\"<NA>\"! lässt sich in der Ausgabe nicht von einem fehlenden Wert unterscheiden. In diesem Fall kann nur mit Hilfe von \lstinline!is.na()! festgestellt werden, ob es sich tatsächlich um einen fehlenden Wert handelt.}
\begin{lstlisting}
# Ausgabe von Zeichenketten mit Anführungszeichen -> nur NA
> LETTERS[c(1, NA, 3)]
[1] "A" NA "C"

# Ausgabe von Zeichenketten ohne Anführungszeichen -> <NA>
> factor(LETTERS[c(1, NA, 3)])
[1] A <NA> C
Levels: A C
\end{lstlisting}

\index{Daten!fehlende Werte!identifizieren}
\index[func]{is.na()@\lstinline{is.na()}}
Ob in einem Vektor fehlende Werte vorhanden sind, wird mit der Funktion \lstinline!is.na(<<Vektor>>)! ermittelt.\footnote{Der \lstinline!==! Operator eignet sich nicht zur Prüfung auf fehlende Werte, da das Ergebnis von \lstinline!<<Wert>> == NA! selbst \lstinline!NA! ist (Abschn.\ \ref{sec:treatNA}). Da die Unterscheidung zwischen \emph{not a number} und \emph{missing} nicht zuverlässig möglich ist, ergibt auch die Prüfung \lstinline!is.na(NaN)! das Ergebnis \lstinline!TRUE!.} Sie gibt einen logischen Vektor aus, der für jede Position angibt, ob das Element ein fehlender Wert ist. Im Fall eines Datensatzes liefert \lstinline!is.na()! eine Matrix aus Wahrheitswerten, die für jedes Element des Datensatzes angibt, ob es sich um einen fehlenden Wert handelt.
\begin{lstlisting}
> is.na(vec1)
[1] FALSE FALSE TRUE FALSE FALSE TRUE

> vec2   <- c(NA, 7, 9, 10, 1, 8)
> (datNA <- data.frame(vec1, vec2))
  vec1 vec2
1   10   NA
2   20    7
3   NA    9
4   40   10
5   50    1
6   NA    8

> is.na(datNA)
      vec1  vec2
[1,] FALSE  TRUE
[2,] FALSE FALSE
[3,]  TRUE FALSE
[4,] FALSE FALSE
[5,] FALSE FALSE
[6,]  TRUE FALSE
\end{lstlisting}

\index{Daten!fehlende Werte!zählen}
Bei einem großen Datensatz ist es mühselig, die Ausgabe von \lstinline!is.na()! manuell nach \lstinline!TRUE! Werten zu durchsuchen. Daher bietet sich \lstinline!anyNA()!\index[func]{anyNA()@\lstinline{anyNA()}} an, um zu erfahren, ob überhaupt fehlende Werte vorliegen. \lstinline!sum(is.na())! ermittelt deren Anzahl und \lstinline!which(is.na())! die zugehörigen Positionen.
\begin{lstlisting}
> anyNA(vec1)                           # gibt es fehlende Werte?
[1] TRUE

> sum(is.na(vec1))                      # wie viele?
[1] 2

> which(is.na(vec1))                    # wo im Vektor?
[1] 3 6

> which(is.na(datNA), arr.ind=TRUE)     # wo im Datensatz?
     row col
[1,]   3   1
[2,]   6   1
[3,]   1   2
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Fehlende Werte ersetzen und umcodieren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!recodieren}
Fehlende Werte werden bei der Dateneingabe in anderen Programmen oft mit Zahlen codiert, die keine mögliche Ausprägung einer Variable sind, z.\,B.\ mit $999$. Bisweilen ist diese Codierung auch nicht einheitlich, sondern verwendet verschiedene Zahlen, etwa wenn Daten aus unterschiedlichen Quellen zusammengeführt werden. Bei der Verarbeitung von aus anderen Programmen übernommenen Datensätzen in R muss die Codierung fehlender Werte also ggf.\ angepasst werden (Abschn.\ \ref{sec:dataImport}, insbesondere das Argument \lstinline!na.strings! in Abschn.\ \ref{sec:readTable} und \ref{sec:scan}).

Die Identifikation der zu ersetzenden Werte kann über \lstinline!<<Vektor>> %in% <<Menge>>! erfolgen, wobei \lstinline!<<Menge>>! ein Vektor mit allen Werten ist, die als fehlend gelten sollen (Abschn.\ \ref{sec:setOps}). Der damit erzeugte Indexvektor lässt sich direkt an das Ergebnis von \lstinline!is.na()! zuweisen, wodurch die zugehörigen Elemente auf \lstinline!NA! gesetzt werden.
\begin{lstlisting}
# fehlende Werte sind zunächst mit -999 und 999 codiert
> vec <- c(30, 25, 23, 21, -999, 999)   # Vektor mit fehlenden Werten
> is.na(vec) <- vec %in% c(-999, 999)   # ersetze missings durch NA
> vec
[1] 30 25 23 21 NA NA
\end{lstlisting}

Abschnitte \ref{sec:naDf} und \ref{sec:dplyr_naDf} zeigen, wie fehlende Werte in Datensätzen identifiziert und codiert werden können.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behandlung fehlender Werte bei der Berechnung einfacher Kennwerte}
\label{sec:treatNA}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!ausschließen}
Wenn in einem Vektor oder einem Datensatz fehlende Werte vorhanden sind, muss Funktionen zur Berechnung statistischer Kennwerte über ein Argument angegeben werden, wie mit ihnen zu verfahren ist. Andernfalls kann der Kennwert nicht berechnet werden, und das Ergebnis der Funktion ist seinerseits \lstinline!NA!\@.\footnote{\label{ftn:whenNA}Allgemein ist das Ergebnis aller Rechnungen \lstinline!NA!, sofern der fehlende Wert für das Ergebnis relevant ist. Ist das Ergebnis auch ohne den fehlenden Wert eindeutig bestimmt, wird es ausgegeben. So erzeugt \lstinline!TRUE | NA! die Ausgabe \lstinline!TRUE!, da sich bei einem logischen ODER das zweite Argument nicht auf das Ergebnis auswirkt, wenn das erste WAHR ist.} Allerdings lassen sich \lstinline!NA! Einträge zunächst manuell entfernen, ehe die Daten an eine Funktion übergeben werden. Zu diesem Zweck existiert die Funktion\index[func]{na.omit()@\lstinline{na.omit()}|textbf} \lstinline!na.omit()!, die den übergebenen Vektor um fehlende Werte bereinigt ausgibt.
\begin{lstlisting}
> sd(na.omit(vec))              # um NA bereinigten Vektor übergeben
[1] 5.125102

# fehlende Werte manuell entfernen
> keep <- !is.na(vec)           # Indizes der nicht fehlenden Werte
> mean(vec[keep])               # um NA bereinigten Vektor übergeben
[1] 24.33333
\end{lstlisting}

Die Behandlung fehlender Werte lässt sich in vielen Funktionen auch direkt über das Argument \lstinline!na.rm! steuern. In der Voreinstellung \lstinline!FALSE! sorgt es dafür, dass fehlende Werte nicht stillschweigend bei der Berechnung des Kennwertes ausgelassen werden, sondern das Ergebnis \lstinline!NA! ist. Soll der Kennwert dagegen auf Basis der vorhandenen Werte berechnet werden, muss das Argument \lstinline!na.rm=TRUE! gesetzt werden.
\begin{lstlisting}
> sum(vec)
[1] NA

> sum(vec, na.rm=TRUE)
[1] 146
\end{lstlisting}

Auf die dargestellte Weise lassen sich fehlende Werte u.\,a.\ in \lstinline!sum()!, \lstinline!prod()!, \lstinline!range()!, \lstinline!mean()!, \lstinline!median()!, \lstinline!quantile()!, \lstinline!var()! und \lstinline!sd()! behandeln.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behandlung fehlender Werte in Matrizen}
\label{sec:naMat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Bei den Funktionen \lstinline!cov()! und \lstinline!cor()! stehen zur Behandlung fehlender Werte der \emph{zeilenweise} und \emph{paarweise} Fallausschluss zur Verfügung, die über das Argument \lstinline!use="complete.obs"! bzw. \lstinline!use="pairwise.complete.obs"! ausgewählt werden. Bei der Kovarianz bzw. Korrelation zweier Variablen führen sie zum selben Ergebnis,
unterscheiden sich aber bei Kovarianz- bzw. Korrelationsmatrizen von mehr als zwei Variablen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Zeilenweiser (fallweiser) Fallausschluss}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!fallweiser Ausschluss}
Beim zeilenweisen Fallausschluss werden die Matrixzeilen komplett entfernt, in denen \lstinline!NA! Werte auftauchen, ehe die Matrix für Berechnungen herangezogen wird. Weil eine Zeile oft allen an einem Beobachtungsobjekt erhobenen Daten entspricht, wird dies auch als fallweiser Fallausschluss bezeichnet. \index[func]{na.omit()@\lstinline{na.omit()}} \lstinline!na.omit(<<Matrix>>)! bereinigt eine Matrix mit fehlenden Werten um Zeilen, in denen \lstinline!NA! Einträge auftauchen. Die Indizes der dabei ausgeschlossenen Zeilen werden der ausgegebenen Matrix als Attribut hinzugefügt. Mit der so gebildeten Matrix fließen im Beispiel die Zeilen $1$ und $2$ nicht mit in Berechnungen ein.
\begin{lstlisting}
> ageNA  <- c(18, NA, 27, 22)
> DV1    <- c(NA, 1, 5, -3)
> DV2    <- c(9, 4, 2, 7)
> (matNA <- cbind(ageNA, DV1, DV2))
     ageNA  DV1  DV2
[1,]    18   NA    9
[2,]    NA    1    4
[3,]    27    5    2
[4,]    22   -3    7

> na.omit(matNA)                            # Zeilen mit NA entfernen
     ageNA  DV1  DV2
[1,]    27    5    2
[2,]    22   -3    7

attr(,"na.action")
[1] 2 1

attr(,"class")
[1] "omit"

> colMeans(na.omit(matNA))                  # Berechnung ohne NAs
ageNA  DV1  DV2
 24.5  1.0  4.5
\end{lstlisting}

Bei \lstinline!cov()! und \lstinline!cor()! bewirkt bei der Berechnung von Kovarianz- und Korrelationsmatrizen mit mehr als zwei Variablen das Argument \lstinline!use="complete.obs"! den fallweisen Ausschluss fehlender Werte. Dessen Verwendung hat denselben Effekt wie die vorherige Reduktion der Matrix um Zeilen, in denen fehlende Werte auftauchen.
\begin{lstlisting}
> cov(matNA, use="complete.obs")
      age  DV1    DV2
age  12.5   20  -12.5
DV1  20.0   32  -20.0
DV2 -12.5  -20   12.5

# beide Arten des fallweisen Ausschlusses erzielen dasselbe Ergebnis
> all.equal(cov(matNA, use="complete.obs"), cov(na.omit(matNA)))
[1] TRUE
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Paarweiser Fallausschluss}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!paarweiser Ausschluss}
Der paarweise Fallausschluss unterscheidet sich erst bei der Berechnung von Kovarianz- bzw.\ Korrelationsmatrizen für mehr als zwei Variablen vom fallweisen Ausschluss. Beim paarweisen Fallausschluss werden die Werte einer auch \lstinline!NA! beinhaltenden Zeile soweit als möglich in Berechnungen berücksichtigt, die Zeile wird also nicht vollständig ausgeschlossen. Welche Werte einer Zeile Verwendung finden, hängt von der konkreten Auswertung ab. Der paarweise Fallausschluss wird im Fall der Berechnung der Summe oder des Mittelwertes über Zeilen oder Spalten mit dem Argument \lstinline!na.rm=TRUE! realisiert, das alle Werte außer \lstinline!NA! einfließen lässt.
\begin{lstlisting}
> rowMeans(matNA)
[1] NA NA 11.333333 8.666667

> rowMeans(matNA, na.rm=TRUE)
[1] 13.500000 2.500000 11.333333 8.666667
\end{lstlisting}

Bei der Berechnung von Kovarianz- und Korrelationsmatrizen für mehr als zwei Variablen mit \lstinline!cov()! und \lstinline!cor()! bewirkt das Argument \lstinline!use="pairwise.complete.obs"! den paarweisen Ausschluss fehlender Werte. Es wird dann bei der Berechnung jeder Kovarianz pro Zeile geprüft, ob in den zugehörigen beiden Spalten ein gültiges Wertepaar existiert und dieses ggf.\ verwendet. Anders als beim fallweisen Ausschluss geschieht dies also auch dann, wenn in derselben Zeile Werte anderer Variablen fehlen, die für die zu berechnende Kovarianz aber irrelevant sind.\footnote{Eine mit diesem Verfahren ermittelte Matrix kann auch nicht positiv semidefinit sein, und stellt dann keine Kovarianzmatrix bzw.\ Korrelationsmatrix im engeren Sinne dar.}

Angewendet auf die Daten in \lstinline!matNA! bedeutet das beispielsweise, dass beim fallweisen Ausschluss das von Beobachtungsobjekt $1$ gelieferte Wertepaar nicht in die Berechnung der Kovarianz von \lstinline!ageNA! und \lstinline!DV2! einfließt, weil der Wert für \lstinline!DV1! bei diesem Beobachtungsobjekt fehlt. Beim paarweisen Ausschluss werden diese Werte dagegen berücksichtigt. Lediglich bei der Berechnung der Kovarianz von \lstinline!DV1! und \lstinline!DV2! werden keine Daten des ersten Beobachtungsobjekts verwendet, weil ein Wert für \lstinline!DV1! von ihr fehlt.
\begin{lstlisting}
> cov(matNA, use="pairwise.complete.obs")
          ageNA  DV1         DV2
ageNA  20.33333   20  -16.000000
  DV1  20.00000   16  -10.000000
  DV2 -16.00000  -10    9.666667
\end{lstlisting}

%Ob fehlende Werte fall- oder paarweise ausgeschlossen werden sollten, hängt u.\,a.\ von den Ursachen ab, warum manche Untersuchungseinheiten unvollständige Daten geliefert haben und andere nicht. Insbesondere stellt sich die Frage, ob Untersuchungseinheiten mit fehlenden Werten systematisch andere Eigenschaften haben, so dass von ihren Daten generell kein Gebrauch gemacht werden sollte.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behandlung fehlender Werte beim Sortieren von Daten}
\label{sec:sortNA}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!sortieren}
Beim Sortieren von Daten mit \lstinline!sort()! und \lstinline!order()! wird die Behandlung fehlender Werte mit dem Argument \lstinline!na.last! kontrolliert, das auf \lstinline!NA!, \lstinline!TRUE! oder \lstinline!FALSE! gesetzt werden kann. Bei \lstinline!sort()! ist \lstinline!na.last! per Voreinstellung auf \lstinline!NA! gesetzt und sorgt so dafür, dass fehlende Werte entfernt werden. Bei \lstinline!order()! ist die Voreinstellung \lstinline!TRUE!, wodurch fehlende Werte ans Ende plaziert werden. Auf \lstinline!FALSE! gesetzt bewirkt \lstinline!na.last! die Plazierung fehlender Werte am Anfang.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behandlung fehlender Werte in inferenzstatistischen Tests}
\label{sec:naTests}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte}
Viele Funktionen zur Berechnung statistischer Tests besitzen das Argument \lstinline!na.action!, das festlegt, wie mit fehlenden Werten zu verfahren ist. Mögliche Werte sind u.\,a.\ die Namen der Funktionen \lstinline!na.omit()!\index[func]{na.omit()@\lstinline{na.omit()}} und \lstinline!na.fail()!\index[func]{na.fail()@\lstinline{na.fail()}}, die sich auch direkt auf Daten anwenden lassen (Abschn.\ \ref{sec:treatNA}, \ref{sec:naDf}, \ref{sec:dplyr_naDf}). Die Voreinstellung \lstinline!na.omit! bewirkt den fallweisen Ausschluss (Abschn.\ \ref{sec:naMat}), mit \lstinline!na.fail! wird die Auswertung bei fehlenden Werten abgebrochen und eine Fehlermeldung ausgegeben. Global kann dieses Verhalten mit \lstinline!options(na.action="<<Wert>>")!\index[func]{options()@\lstinline{options()}} geändert werden (vgl.\ \lstinline!?na.action!). Generell empfiehlt es sich, Daten außerhalb von Auswertungsfunktionen um fehlende Werte zu bereinigen, bzw.\ sie mit Techniken der multiplen Imputation zu vervollständigen. So lässt sich die Konsistenz bzgl.\ der in einzelne Auswertungen eingeflossenen Beobachtungsobjekte besser sichern.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Multiple Imputation}
\label{sec:multipleImputation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!multiple Imputation}
\index{Daten!fehlende Werte!ersetzen}
\index{multiple Imputation|see{Daten}}
\index{Imputation|see{Daten}}
Die \emph{multiple Imputation} eliminiert fehlende Werte, indem sie an ihrer Stelle plausible mögliche Werte einfügt. Sie ersetzt fehlende Werte eines aus mehreren Variablen bestehenden Datensatzes in mehreren Durchgängen jeweils durch solche Werte, die mit bestimmten Annahmen und unter Berücksichtigung der tatsächlich vorhandenen Daten künstlich generiert wurden. Die simulierten Daten sollen so die Verteilungseigenschaften der empirisch beobachteten Daten teilen. Für jeden einzelnen Durchgang der Imputation aller fehlenden Werte lassen sich dann z.\,B.\ Parameterschätzungen eines statistischen Regressionsmodells berechnen. Die sich ergebene Menge unterschiedlicher Schätzungen -- eine Schätzung aller Koeffizienten pro Imputation -- kann dann über Durchgänge hinweg zu einer Gesamtschätzung kombiniert werden.

Multiple Imputation wird in R u.\,a.\ von den Paketen\index[pack]{mice@\lstinline{mice}} \lstinline!mice! \cite{vanBuuren2011,vanBuuren2012} und \index[pack]{Amelia@\lstinline{Amelia}} \lstinline!Amelia! \cite{Honaker2011} unterstützt. Für weitere vgl.\ den Abschnitt \emph{Official Statistics \& Survey Methodology} der CRAN Task Views \cite{CRANtvOffStat}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zeichenketten verarbeiten}
\label{sec:stringMan}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Zeichenketten tauchen bei der Auswertung von Daten z.\,B.\ als Bezeichnungen für Variablen oder Gruppen auf. Vor allem bei der Aufbereitung eines Rohdatensatzes ist es hilfreich, sie flexibel erstellen und manipulieren zu können.\footnote{Das Paket \index[pack]{stringr@\lstinline{stringr}} \lstinline!stringr! \cite{Wickham2011a} stellt für viele der im Folgenden aufgeführten Funktionen Alternativen bereit, die den Umgang mit Zeichenketten erleichtern und konsistenter gestalten sollen.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Objekte in Zeichenketten umwandeln}
\label{sec:sink}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Umwandlung in Zeichenketten}
\index[func]{toString()@\lstinline{toString()}}
Mit \lstinline!toString(<<Objekt>>)! lassen sich Objekte in Zeichenketten umwandeln. Das Ergebnis ist eine einzelne Zeichenkette mit den Inhalten des Objekts, wobei einzelne Elemente durch Komma mit folgendem Leerzeichen getrennt werden. Komplexe Objekte (z.\,B.\ Matrizen) werden dabei wie Vektoren verarbeitet.
\begin{lstlisting}
> randVals <- round(rnorm(5), digits=2)
> toString(randVals)
[1] "-0.03, 1.01, -0.52, -1.03, 0.18"
\end{lstlisting}

\index[func]{capture.output()@\lstinline{capture.output()}}
Analog wandelt \lstinline!capture.output(<<Ausdruck>>)! die normalerweise auf der Konsole erscheinende Ausgabe eines Befehls in eine Zeichenkette um. Die Ausgabe mehrerer Bearbeitungsschritte lässt sich mit\index[func]{sink()@\lstinline{sink()}} \lstinline!sink()! in eine Zeichenkette oder mit \lstinline!sink("<<Dateiname>>")! in eine Datei umleiten. Soll dies als Protokoll\index{Protokoll} aller Vorgänge in Kopie geschehen, während die Ausgabe auf der Konsole weiter angezeigt wird, ist dabei das Argument \lstinline!split=TRUE! zu setzen. Eine aktive Umleitung wird mit \lstinline!sink()! wieder beendet.

\index[func]{formatC()@\lstinline{formatC()}}
\lstinline!formatC()! ist auf die Umwandlung von Zahlen in Zeichenketten spezialisiert und bietet sich vor allem für die formatierte Ausgabe von Dezimalzahlen an.
\begin{lstlisting}
formatC(x=<<Zahl>>, digits=<<Dezimalstellen>>, width=<<Breite>>,
        flag="<<Modifikation>>", format="<<Zahlentyp>>")
\end{lstlisting}

Ist \lstinline!x! eine Dezimalzahl, wird sie mit \lstinline!digits! vielen Dezimalstellen ausgegeben. Die Angabe von \lstinline!digits! fügt ganzen Zahlen keine Dezimalstellen hinzu, allerdings verbreitert sich die ausgegebene Zeichenkette auf \lstinline!digits! viele Zeichen, indem \lstinline!x! entsprechend viele Leerzeichen vorangestellt werden. Sollen der Zahl stattdessen Nullen vorangestellt werden, ist \lstinline!flag="0"! zu setzen. Linksbündig ausgerichtete Zeichenketten sind mit \lstinline!flag="-"! zu erreichen. Die Länge der Zeichenkette lässt sich auch unabhängig von der Zahl der Dezimalstellen mit dem Argument \lstinline!width! kontrollieren. Schließlich ermöglicht \lstinline!format! die Angabe, was für ein Zahlentyp bei \lstinline!x! vorliegt, insbesondere ob es eine ganze Zahl (\lstinline!"d"!) oder eine Dezimalzahl ist. Im letztgenannten Fall kann die Ausgabeform etwa mit \lstinline!"f"! wie gewohnt erfolgen (z.\,B.\ \lstinline!"1.234"!) oder mit \lstinline!"e"! in wissenschaftlicher Notation (z.\,B.\ \lstinline!"1.23e+03"!) -- für weitere Möglichkeiten vgl.\ \lstinline!?formatC!\@.
\begin{lstlisting}
> formatC(3, digits=5, format="d")
[1] "    3"

> formatC(c(1, 2.345), width=5, format="f")
[1] "1.0000" "2.3450"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenketten erstellen und ausgeben}
\label{sec:strings}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Die einfachste Möglichkeit zum Erstellen eigener Zeichenketten ist ihre manuelle Eingabe auf der Konsole oder im Editor. Für Vektoren von Zeichenketten ist dabei zu beachten, dass \lstinline!length()! jede Zeichenkette als ein Element betrachtet. Dagegen gibt \lstinline!nchar("<<Zeichenkette>>")!\index{Zeichenketten!Länge}\index{Lange@Länge!Zeichenkette}\index[func]{nchar()@\lstinline{nchar()}} die Wortlänge jedes Elements an, aus wie vielen einzelnen Zeichen jede Zeichenkette des Vektors also besteht.
\begin{lstlisting}
> length("ABCDEF")
[1] 1

> nchar("ABCDEF")
[1] 6

> nchar(c("A", "BC", "DEF"))
[1] 1 2 3
\end{lstlisting}

Fehlende Werte \lstinline!NA! wandelt \lstinline!nchar()! intern in die Zeichenkette \lstinline!"NA"! um. Daher liefert \lstinline!nchar(NA)! das Ergebnis $2$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Zeichenketten nach Muster erstellen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Die Methode, Zeichenketten manuell in Vektoren zu erstellen, stößt dort schnell an ihre Grenzen, wo sie von Berechnungen abhängen sollen oder viele Zeichenketten nach demselben Muster erzeugt werden müssen. \lstinline!paste()! und \lstinline!sprintf()! sind hier geeignete Alternativen.

\index{Zeichenketten!nach Muster erstellen}

\index[func]{paste()@\lstinline{paste()}}
Mit \lstinline!paste()! lassen sich Zeichenketten mit einem bestimmten Aufbau erzeugen, indem verschiedene Komponenten aneinandergehängt werden, die etwa aus einem gemeinsamen Präfix und unterschiedlicher laufender Nummer bestehen können.
\begin{lstlisting}
paste(<<Objekt1>>, <<Objekt2>>, ..., sep=" ", collapse=NULL)
\end{lstlisting}

Die ersten Argumente von \lstinline!paste()! sind Objekte, deren Elemente jeweils die Bestandteile der zu erstellenden Zeichenketten ausmachen und zu diesem Zweck aneinandergefügt werden. Das erste Element des ersten Objekts wird dazu mit den ersten Elementen der weiteren Objekte verbunden, ebenso die jeweils zweiten und folgenden Elemente. Das Argument \lstinline!sep! kontrolliert, welche Zeichen jeweils zwischen Elementen aufeinander folgender Objekte einzufügen sind -- in der Voreinstellung ist dies das Leerzeichen. In der Voreinstellung \lstinline!collapse=NULL! ist das Ergebnis ein Vektor aus Zeichenketten, wobei jedes seiner Elemente aus der Kombination jeweils eines Elements aus jedem übergebenen Objekt besteht. Hierbei werden unterschiedlich lange Vektoren ggf.\ zyklisch verlängert (Abschn.\ \ref{sec:recycling}). Wird stattdessen für \lstinline!collapse! eine Zeichenfolge übergeben, ist das Ergebnis eine einzelne Zeichenkette, deren Bestandteile durch diese Zeichenfolge getrennt sind.
\begin{lstlisting}
> paste("group", LETTERS[1:5], sep="_")
[1] "group_A" "group_B" "group_C" "group_D" "group_E"

# Farben der Default-Farbpalette
> paste(1:5, palette()[1:5], sep=": ")
[1] "1: black" "2: #DF536B" "3: #61D04F" "4: #13A5FD" "5: #33DBDF"

> paste(1:5, letters[1:5], sep=".", collapse=" ")
[1] "1.a 2.b 3.c 4.d 5.e"
\end{lstlisting}

Fehlende Werte \lstinline!NA! wandelt \lstinline!paste()! in die Zeichenkette \lstinline!"NA"! um. Treten innerhalb von \lstinline!paste()! die leere Menge \lstinline!NULL! oder leere Vektoren \lstinline!character(0)! gemeinsam mit anderen Zeichen auf, werden sie wie die leere Zeichenkette \lstinline!""! der Länge $1$ behandelt, was an den eingefügten Trennzeichen \lstinline!sep! deutlich wird.
\begin{lstlisting}
> paste(1, NA, 2, NULL, 3, character(0), sep="_")
[1] "1_NA_2__3_"
\end{lstlisting}

\index[func]{sprintf()@\lstinline{sprintf()}}
Die an die gleichnamige Funktion der Programmiersprache C angelehnte Funktion \lstinline!sprintf()! erzeugt Zeichenketten, deren Aufbau durch zwei Komponenten bestimmt wird: Einerseits durch einen die Formatierung und feste Elemente definierenden Teil (den\index{format string} \emph{format string}), andererseits durch eine Reihe von Objekten, deren Werte an festgelegten Stellen des format strings einzufügen sind.
\begin{lstlisting}
sprintf(fmt="<<format string>>", <<Objekt1>>, <<Objekt2>>, ...)
\end{lstlisting}

Das Argument \lstinline!fmt! erwartet eine Zeichenkette aus festen und variablen Elementen. Gewöhnliche Zeichen werden als feste Elemente interpretiert und tauchen unverändert in der erzeugten Zeichenkette auf. Variable Elemente werden durch das\index[func]{"\%@\texttt{\%}} Prozentzeichen \lstinline!%! eingeleitet, auf das ein Buchstabe folgen muss, der die Art des hier einzufügenden Wertes definiert. So gibt etwa \lstinline!%d! an, dass hier ein ganzzahliger Wert einzufügen ist, \lstinline!%f! dagegen weist auf eine Dezimalzahl hin und \lstinline!%s! auf eine Zeichenfolge. Das Prozentzeichen selbst wird durch \lstinline!%%! ausgegeben, doppelte\index[func]{""@\lstinline{"", '}} Anführungszeichen durch \lstinline!\"!,\footnote{Alternativ\index{Anfuhrungszeichen@Anführungszeichen} kann \lstinline!fmt! in einfache Anführungszeichen \lstinline!'<<format string>>'! gesetzt werden, innerhalb derer sich dann auch doppelte Anführungszeichen ohne voranstehenden backslash \lstinline!\\! befinden können (Abschn.\ \ref{sec:dataTypes}, Fußnote \ref{ftn:quote}).} Tabulatoren durch \lstinline!\t! und Zeilenumbrüche durch \lstinline!\n! (vgl.\ \lstinline!?Quotes!).

Für jedes durch ein Prozentzeichen definierte Feld muss nach \lstinline!fmt! ein passendes Objekt genannt werden, dessen Wert an der durch \lstinline!%! bezeichneten Stelle eingefügt wird. Die Entsprechung zwischen variablen Feldern und Objekten wird über deren Reihenfolge hergestellt, der Wert des ersten Objekts wird also an der Stelle des ersten variablen Elements eingefügt, etc.
\begin{lstlisting}
> N   <- 20
> grp <- "A"
> M   <- 14.2
> sprintf("For %d participants in group %s, mean was %f", N, grp, M)
[1] "For 20 participants in group A, mean was 14.200000"
\end{lstlisting}

Format strings erlauben eine weitergehende Formatierung der Ausgabe, indem zwischen dem \lstinline!%! und dem folgenden Buchstaben Angaben gemacht werden, die sich z.\,B.\ auf die Anzahl der auszugebenden Dezimalstellen beziehen können. Für detailliertere Informationen vgl.\ \lstinline!?sprintf!.
\begin{lstlisting}
> sprintf("%.3f", 1.23456)      # begrenze Ausgabe auf 3 Dezimalstellen
[1] "1.234"

# ganze Zahlen mit fester Breite und führender 0
> sprintf("%.4d", c(1, 52, 712))
[1] "0001" "0052" "0712"
\end{lstlisting}

In der Voreinstellung setzen die meisten Ausgabefunktionen von R Zeichenketten in Anführungszeichen. In \lstinline!print()! lässt sich dies mit dem Argument \lstinline!quote=FALSE! verhindern, allgemein hat \index[func]{noquote()@\lstinline{noquote()}} \lstinline!noquote("<<Zeichenkette>>")! denselben Effekt.
\begin{lstlisting}
> cVar <- "A string"
> print(cVar, quote=FALSE)
[1] A string

> noquote(cVar)
[1] A string
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Zeichenketten verbinden}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!verbinden}
\index[func]{cat()@\lstinline{cat()}}
Um mehrere Zeichenketten kombiniert als eine einzige Zeichenkette lediglich auf der R Konsole auszugeben und nicht in einem Vektor zu speichern, kann die Funktion \lstinline!cat()! (\emph{concatenate}) verwendet werden. Sie erlaubt auch eine gewisse Formatierung -- etwa in Form von\index{Zeichenketten!Zeilenumbruch} Zeilenumbrüchen durch die\index{Escape-Sequenz}\index[func]{\textbackslash@\texttt{\textbackslash}} Escape-Sequenz \lstinline!\n! oder \lstinline!\t! für Tabulatoren.
\begin{lstlisting}
cat("<<Zeichenkette 1>>", "<<Zeichenkette 2>>", ..., sep=" ")
\end{lstlisting}

\lstinline!cat()! kombiniert die übergebenen Zeichenketten durch Verkettung zunächst zu einer einzelnen, wobei zwischen den Zeichenketten das unter \lstinline!sep! genannte Trennzeichen eingefügt wird. Numerische Variablen werden hierbei automatisch in Zeichenketten konvertiert. Die Ausgabe von \lstinline!cat()! unterscheidet sich in zwei Punkten von der üblichen Ausgabe einer Zeichenkette: Zum einen wird sie nicht in Anführungszeichen gesetzt. Zum anderen wird am Anfang jeder Zeile auf die Ausgabe der Position des zu Zeilenbeginn stehenden Wertes, etwa \lstinline![1]!, verzichtet.
\begin{lstlisting}
> cat(cVar, "with\n", 4, "\nwords\n", sep="+")
A string+with
+4+
words
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenketten manipulieren}
\label{sec:stringMod}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Groß- / Kleinbuchstaben}
\index[func]{tolower()@\lstinline{tolower()}}
\index[func]{toupper()@\lstinline{toupper()}}
\index[func]{abbreviate()@\lstinline{abbreviate()}}
\index[func]{strrep()@\lstinline{strrep()}}
\index[func]{strtrim()@\lstinline{strtrim()}}
\index[func]{trimws()@\lstinline{trimws()}}
\index[func]{StrRev()@\lstinline{StrRev()}}
\index{Zeichenketten!umkehren}

Die folgenden Funktionen akzeptieren als Argument neben einer einzelnen Zeichenkette \lstinline!Z! auch Vektoren von Zeichenketten.
\begin{itemize}
\item \lstinline!tolower("<<Z>>")! und \lstinline!toupper("<<Z>>")! konvertieren die Buchstaben in \lstinline!Z! in Klein- bzw.\ Großbuchstaben.
\item \lstinline!strtrim("<<Z>>", width=<<Anzahl>>)! schneidet \lstinline!Z! hinter \lstinline!width! vielen Buchstaben ab.
\item Demgegenüber erstellt \lstinline!abbreviate("<<Z>>", minlength=<<Anzahl>>)! eine Kurzform von \lstinline!Z! mit \lstinline!minlength! vielen Buchstaben, wobei ursprünglich unterschiedliche Zeichenketten desselben Vektors unterscheidbar bleiben. Dies kann etwa beim Erstellen von übersichtlichen Variablen-Bezeichnungen für Diagrammachsen oder Tabellen sinnvoll sein.
\item Leerzeichen und anderen Leerraum zu Beginn oder Ende von \lstinline!Z! entfernt \lstinline!trimws("<<Z>>", which)! (\emph{trim whitespace}). Mit dem Argument \lstinline!which="left"! betrifft dies nur den Anfang, analog mit \lstinline!"right"! nur das Ende und mit \lstinline!"both"! sowohl Anfang als auch Ende von \lstinline!Z!.
\item Analog zur Wiederholung von Zahlen mit \lstinline!rep()! kann \lstinline!strrep("<<Z>>", times=<<Anzahl>>)! eine Zeichenkette \lstinline!x! durch Wiederholung verlängern. Ist \lstinline!x! ein Vektor von Zeichenketten, wird jedes Element verlängert. Dafür kann \lstinline!times! auch ein Vektor derselben Länge wie \lstinline!x! sein und bestimmt dann für jedes Element von \lstinline!x!, wie oft es aneinandergehängt werden soll.
\item Mit \lstinline!StrRev("<<Z>>")! (\emph{string reverse}) aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} wird die Reihenfolge der Zeichen in \lstinline!Z! umgekehrt.
\end{itemize}
\begin{lstlisting}
> tolower(c("A", "BC", "DEF"))
[1] "a" "bc" "def"

> strtrim("AfairlyLongString", width=6)
[1] "Afairl"

> abbreviate("AfairlyLongString", minlength=6)
AfairlyLongString
         "AfrlLS"

> trimws(c("  Quattuor ", "   quinque   "), which="both")
[1] "Quattuor" "quinque"

> strrep(c("A", "B", "C"), 1:3)
[1] "A"   "BB"  "CCC"

> library(DescTools)                      # für StrRev()
> StrRev(c("Lorem", "ipsum", "dolor", "sit"))
[1] "meroL" "muspi" "rolod" "tis"
\end{lstlisting}

\index{Zeichenketten!zerlegen}
\index[func]{strsplit()@\lstinline{strsplit()}}
Mit \lstinline!strsplit()! (\emph{string split}) ist es möglich, eine einzelne Zeichenkette in mehrere Teile zu zerlegen.
\begin{lstlisting}
strsplit(x="<<Zeichenkette>>", split="<<Zeichenkette>>", fixed=FALSE)
\end{lstlisting}

Die Elemente des für \lstinline!x! übergebenen Vektors werden dafür nach Vorkommen der unter \lstinline!split! genannten Zeichenkette durchsucht, die als Trennzeichen interpretiert wird. Die Zeichenfolgen links und rechts von \lstinline!split! machen die Komponenten der Ausgabe aus, die aus einer Liste von Vektoren von Zeichenketten besteht -- eine Komponente für jedes Element des Vektors von Zeichenketten \lstinline!x!. In der Voreinstellung \lstinline!split=NULL! werden die Elemente von \lstinline!x! in einzelne Zeichen zerlegt.\footnote{Die Ausgabe ist ggf.\ mit \lstinline!unlist()! (Abschn.\ \ref{sec:unlist}) in einen Vektor, oder mit \lstinline!do.call(cbind, <<Liste>>)! bzw.\ \lstinline!do.call(rbind, <<Liste>>)! in eine Matrix umzuwandeln, wenn die Listenkomponenten dieselbe Länge besitzen. Weitere Möglichkeiten der Weiterverarbeitung von Listen zeigt Abschn.\ \ref{sec:sapply}.} \lstinline!strsplit()! ist damit die Umkehrung von \lstinline!paste()!. Das Argument \lstinline!fixed! bestimmt, ob \lstinline!split! i.\,S.\ eines \emph{regulären Ausdrucks} interpretiert werden soll (Voreinstellung \lstinline!FALSE!, Abschn.\ \ref{sec:grep}) oder als exakt die übergebene Zeichenfolge selbst (\lstinline!TRUE!).
\begin{lstlisting}
> strsplit(c("abc_def_ghi", "jkl_mno"), split="_")
[[1]]
[1] "abc" "def" "ghi"

[[2]]
[1] "jkl" "mno"

> strsplit("Xylophon", split=NULL)
[[1]]
[1] "X" "y" "l" "o" "p" "h" "o" "n"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenfolgen finden}
\label{sec:grep}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Zeichenfolgen finden}
Die Suche nach bestimmten Zeichenfolgen innerhalb von Zeichenketten ist mit \lstinline!match()!, \lstinline!pmatch()! und \lstinline!grep()! möglich. Soll geprüft werden, ob die in einem Vektor \lstinline!x! enthaltenen Elemente jeweils eine exakte Übereinstimmung in den Elementen eines Vektors \lstinline!table! besitzen, ist \lstinline!match()! anzuwenden. Beide Objekte müssen nicht unbedingt Zeichenketten sein, werden aber intern zu solchen\index[func]{match()@\lstinline{match()}} konvertiert.\footnote{\label{ftn:adist}\lstinline!adist()!\index[func]{adist()@\lstinline{adist()}} berechnet die Levenshtein-Distanz zwischen zwei Zeichenketten als Maß für die Anzahl notwendiger elementarer Editiervorgänge, um eine Zeichenkette in die andere zu ändern. Über die Levenshtein-Distanz können mit \lstinline!agrep()!\index[func]{agrep()@\lstinline{agrep()}} auch ungefähr passende Zeichenketten gefunden werden. Weitere Ansätze hierfür sind im Paket \lstinline!stringdist!\index[pack]{stringdist@\lstinline{stringdist}} \cite{vanderLoo2014} vorhanden.}
\begin{lstlisting}
match(x=<<gesuchte Werte>>, table=<<Objekt>>)
\end{lstlisting}

Die Ausgabe gibt für jedes Element von \lstinline!x! die erste Position im Objekt \lstinline!table! an, an der es dort ebenfalls vorhanden ist. Enthält \lstinline!table! kein mit \lstinline!x! übereinstimmendes Element, ist die Ausgabe an dieser Stelle \lstinline!NA!\@.

\index[func]{pmatch()@\lstinline{pmatch()}}
Die fast identische Funktion \lstinline!pmatch()! unterscheidet sich darin, dass die Elemente von \lstinline!table! nicht nur auf exakte Übereinstimmung getestet werden: Findet sich für ein Element von \lstinline!x! ein identisches Element in \lstinline!table!, ist der Index das Ergebnis, an dem dieses Element zum ersten Mal vorkommt. Andernfalls wird in \lstinline!table! nach teilweisen Übereinstimmungen in dem Sinne gesucht, dass auch eine Zeichenkette zu einem Treffer führt, wenn sie mit jener aus \lstinline!x! beginnt, sofern es nur eine einzige solche Zeichenkette in \lstinline!table! gibt.
\begin{lstlisting}
> match(c("abc", "de", "f", "h"), c("abcde", "abc", "de", "fg", "ih"))
[1] 2 3 NA NA

> pmatch(c("abc", "de", "f", "h"), c("abcde", "abc", "de", "fg", "ih"))
[1] 2 3 4 NA
\end{lstlisting}

Speziell um zu prüfen, ob Zeichenketten in einem Vektor \lstinline!Z! mit einem bestimmten Muster beginnen bzw.\ enden, existieren die Funktionen \lstinline!startsWith("<<Z>>", prefix="<<Muster>>")!\index[func]{startsWith()@\lstinline{startsWith()}} und \lstinline!endsWith("<<Z>>", suffix="<<Muster>>")!\index[func]{endsWith()@\lstinline{endsWith()}}. \lstinline!prefix! bzw.\ \lstinline!suffix! müssen Zeichenketten sein, reguläre Ausdrücke sind hier nicht möglich.
\begin{lstlisting}
> startsWith(c("Train", "Station"), "T")
[1] TRUE FALSE

> endsWith(c("Train", "Station"), "n")
[1] TRUE TRUE
\end{lstlisting}

\lstinline!grep()!\index[func]{grep()@\lstinline{grep()}} ähnelt dem gleichlautenden POSIX-Befehl Unix-artiger Betriebssysteme und bietet stark erweiterte Suchmöglichkeiten.
\begin{lstlisting}
grep(pattern="<<Suchmuster>>", x="<<Zeichenkette>>", value=FALSE,
     ignore.case=FALSE)
\end{lstlisting}

Unter \lstinline!pattern! ist ein Muster anzugeben, das die zu suchende Zeichenfolge definiert. Obwohl hier auch einfach eine bestimmte Zeichenfolge übergeben werden kann, liegt die Besonderheit darin, dass \lstinline!pattern!\index{Zeichenketten!regulärer Ausdruck}\index{regularer Ausdruck@regulärer Ausdruck|see{Zeichenketten}} reguläre Ausdrücke akzeptiert. Ein regulärer Ausdruck definiert eine Menge möglicher Zeichenfolgen, die dasselbe Muster besitzen, etwa {\quotedblbase}ein A gefolgt von einem B oder C und einem Leerzeichen{\textquotedblleft}: \lstinline!"A[BC][[:blank:]]"! (vgl.\ \lstinline!?regex!, sowie \citeNP{Goyvaerts2012}). Der zu durchsuchende Vektor von Zeichenketten wird unter \lstinline!x! genannt. Die Option \lstinline!ignore.case! bestimmt, ob Groß- / Kleinschreibung beachtet werden soll.

Die Ausgabe ist in der Voreinstellung \lstinline!value=FALSE! ein Vektor von Indizes derjenigen Elemente von \lstinline!x!, die das gesuchte Muster enthalten. Mit \lstinline!value=TRUE! werden die zum Muster passenden Elemente von \lstinline!x! selbst ausgegeben. Hierfür existiert die Kurzform \lstinline!grepv()!\index[func]{grepv()@\lstinline{grepv()}} Weiter gibt die ansonsten genauso zu verwendende Funktion\index[func]{grepl()@\lstinline{grepl()}} \lstinline!grepl()! einen logischen Indexvektor aus, der für jedes Element von \lstinline!x! angibt, ob es \lstinline!pattern! enthält.
\begin{lstlisting}
# Indizes der passenden Elemente
> grep("A[BC][[:blank:]]", c("AB ", "AB", "AC ", "A "))
[1] 1 3

# passende Elemente selbst
> grep( "A[BC][[:blank:]]", c("AB ", "AB", "AC ", "A "),
+       value=TRUE)
[1] "AB " "AC "

# passendes Element vorhanden?
> grepl("A[BC][[:blank:]]", c("AB ", "AB", "AC ", "A "))
[1] TRUE FALSE TRUE FALSE
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenfolgen extrahieren}
\label{sec:substring}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Zeichenfolgen extrahieren}
\index[func]{substring()@\lstinline{substring()}}
Aus Zeichenketten lassen sich mit \lstinline!substring()! konsekutive Teilfolgen von Zeichen extrahieren.
\begin{lstlisting}
substring(text="<<Zeichenkette>>", first=<<Beginn>>, last=<<Ende>>)
\end{lstlisting}

Aus den Elementen des für \lstinline!text! angegebenen Vektors von Zeichenketten wird jeweils jene Zeichenfolge extrahiert, die beim Buchstaben an der Stelle \lstinline!first! beginnt und mit dem Buchstaben an der Stelle \lstinline!last! endet. Umfasst eine Zeichenkette weniger als \lstinline!first! oder \lstinline!last! Buchstaben, werden nur so viele ausgeben, wie tatsächlich vorhanden sind -- ggf.\ eine leere Zeichenkette.
\begin{lstlisting}
> substring(c("ABCDEF", "GHIJK", "LMNO", "PQR"), first=4, last=5)
[1] "DE" "JK" "O" ""
\end{lstlisting}

Um mit Hilfe von regulären Ausdrücken definierte Zeichenfolgen aus Zeichenketten extrahieren zu können, ist neben der Information, \emph{ob} eine Zeichenkette die gesuchte Zeichenfolge enthält, auch die Information notwendig, an welcher Stelle sie ggf.\ auftaucht. Dies lässt sich mit \index[func]{regexpr()@\lstinline{regexpr()}} \lstinline!regexpr()! ermitteln.
\begin{lstlisting}
regexpr(pattern="<<Suchmuster>>", text="<<Zeichenkette>>")
\end{lstlisting}

Die Argumente \lstinline!pattern! und \lstinline!text! haben jeweils dieselbe Bedeutung wie \lstinline!pattern! und \lstinline!x! von \lstinline!grep()!. Das Ergebnis ist ein numerischer Vektor mit so vielen Elementen wie jene von \lstinline!text!. Enthält ein Element von \lstinline!text! das Suchmuster nicht, ist das Ergebnis an dieser Stelle \lstinline!-1!. Andernfalls ist das Ergebnis die erste Stelle des zugehörigen Elements von \lstinline!text!, an der das gefundene Suchmuster dort beginnt. Der ausgegebene numerische Vektor besitzt weiterhin das Attribut \lstinline!match.length!, das seinerseits ein numerischer Vektor ist und codiert, wie viele Zeichen die Zeichenfolge umfasst, auf die das Suchmuster zutrifft. Auch hier steht die \lstinline!-1! für den Fall, dass sich das Suchmuster nicht in der Zeichenkette findet. Das Ergebnis eignet sich besonders, um mit der Funktion \index[func]{regmatches()@\lstinline{regmatches()}}\lstinline!regmatches()! weiterverarbeitet zu werden, die die Fundstellen extrahiert.
\begin{lstlisting}
> pat    <- "[[:upper:]]+"            # suche nach Großbuchstaben
> txt    <- c("abcDEFG", "ABCdefg", "abcdefg")
> (start <- regexpr(pat, txt))        # Start + Länge der Fundstellen
[1] 4 1 -1

attr(,"match.length")
[1] 4 3 -1

> regmatches(txt, start)              # extrahiere Fundstellen
[1] "DEFG" "ABC" ""
\end{lstlisting}

Im Unterschied zu \lstinline!regexpr()! berücksichtigt die ansonsten gleich zu verwendende Funktion\index[func]{gregexpr()@\lstinline{gregexpr()}} \lstinline!gregexpr()! nicht nur das erste Auftreten von \lstinline!pattern! in einem Element von \lstinline!text!, sondern auch ggf.\ spätere. Die Ausgabe ist eine Liste mit so vielen Komponenten, wie \lstinline!text! Elemente besitzt. Das Ergebnis kann wieder direkt an \lstinline!regmatches()! übergeben werden, um die Fundstellen zu extrahieren.
\begin{lstlisting}
> txt2   <- c("abcDEFGhijKL", "ABCdefgHIJ", "abcdefg")
> start2 <- gregexpr(pat, txt2)       # Start + Länge der Fundstellen
> regmatches(txt2, start2)            # extrahiere Fundstellen
[[1]]
[1] "DEFG" "KL"  

[[2]]
[1] "ABC" "HIJ"

[[3]]
character(0)
\end{lstlisting}

Eine Alternative zu \lstinline!regmatches()! bieten die in Abschn.\ \ref{sec:strSub} vorgestellten Funktionen \lstinline!sub()! bzw.\ \lstinline!gsub()!.

Da die Syntax regulärer Ausdrücke recht komplex ist, sorgt u.\,U.\ schon die Suche nach einfachen Mustern für Schwierigkeiten. Eine Vereinfachung bietet die Funktion\index[func]{glob2rx()@\lstinline{glob2rx()}} \lstinline!glob2rx()!, mit der Muster von Zeichenfolgen mit Hilfe gebräuchlicherer\index{Zeichenketten!Platzhalter}\index{Zeichenketten!wildcards}\index{Zeichenketten!Globbing-Muster} Platzhalter (\emph{wildcards}\index{Globbing-Muster|see{Zeichenketten}} bzw.\ \emph{Globbing}-Muster) beschrieben und in einen regulären Ausdruck umgewandelt werden können. So steht z.\,B.\ der Platzhalter \lstinline!?! für ein beliebiges einzelnes Zeichen, \lstinline!*! für eine beliebige Zeichenkette.
\begin{lstlisting}
glob2rx(pattern="<<Muster mit Platzhaltern>>")
\end{lstlisting}

Das Argument \lstinline!pattern! akzeptiert einen Vektor, dessen Elemente Zeichenfolgen aus Buchstaben und Platzhaltern sind. Die Ausgabe besteht aus einem Vektor mit regulären Ausdrücken, wie sie z.\,B.\ in \lstinline!grep()! angewendet werden können.
\begin{lstlisting}
> glob2rx("asdf*.txt")  # Namen, die mit asdf beginnen und .txt enden
[1] "^asdf.*\\.txt$"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenfolgen ersetzen}
\label{sec:strSub}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Zeichenfolgen ersetzen}
Wenn in Zeichenketten nach bestimmten Zeichenfolgen gesucht wird, dann häufig, um sie durch andere zu ersetzen. Dies ist etwa möglich, indem dem Ergebnis von \lstinline!substring()! ein passender Vektor von Zeichenketten zugewiesen wird -- dessen Elemente ersetzen dann die durch \lstinline!first! und \lstinline!last! begrenzten Zeichenfolgen in den Elementen von \lstinline!text!. Dabei ist es notwendig, dass für \lstinline!text! ein bereits bestehendes Objekt übergeben wird, das dann der Änderung unterliegt.
\begin{lstlisting}
> charVec <- c("ABCDEF", "GHIJK", "LMNO", "PQR")
> substring(charVec, 4, 5) <- c("..", "xx", "++", "**")
> charVec
[1] "ABC..F" "GHIxx" "LMN+" "PQR"
\end{lstlisting}

\index[func]{sub()@\lstinline{sub()}}
Auch \lstinline!sub()! (\emph{substitute}) und \lstinline!gsub()! dienen dem Zweck, durch ein Muster definierte Zeichenfolgen innerhalb von Zeichenketten auszutauschen.
\begin{lstlisting}
sub(pattern="<<Suchmuster>>", replacement="<<Ersatz>>", x="<<Zeichenkette>>")
\end{lstlisting}

Für \lstinline!pattern! kann ein regulärer Ausdruck übergeben werden, dessen Vorkommen in den Elementen von \lstinline!x! durch die unter \lstinline!replacement! genannte Zeichenfolge ersetzt werden. Wenn \lstinline!pattern! in einem Element von \lstinline!x! mehrfach vorkommt, wird es nur beim ersten Auftreten ersetzt.
\begin{lstlisting}
> sub("em", "XX", "Lorem ipsum dolor sit Lorem ipsum")
[1] "LorXX ipsum dolor sit Lorem ipsum"
\end{lstlisting}

\index[func]{gsub()@\lstinline{gsub()}}
Im Unterschied zu \lstinline!sub()! ersetzt die ansonsten gleich zu verwendende \lstinline!gsub()! Funktion \lstinline!pattern! nicht nur beim ersten Auftreten in \lstinline!x! durch \lstinline!replacement!, sondern überall.
\begin{lstlisting}
> gsub("em", "XX", "Lorem ipsum dolor sit Lorem ipsum")
[1] "LorXX ipsum dolor sit LorXX ipsum"
\end{lstlisting}

In \lstinline!pattern! können runde Klammern \lstinline!(<<Muster>>)! zur Definition von Gruppen innerhalb des regulären Ausdrucks verwendet werden. Die Gruppen sind intern numeriert. Zeichenketten, die das Muster einer Gruppe aufweisen, sind dann innerhalb von \lstinline!replacement! über die Angabe der Gruppen-Nummer in der Form \lstinline!"\\<<Nummer>>"! abrufbar (\emph{back referencing}). Alternativ zu \lstinline!regmatches()! (Abschn.\ \ref{sec:substring}) lassen sich auf diese Weise Zeichenfolgen extrahieren.

Im Beispiel definiert der reguläre Ausdruck eine Zeichenkette, die mit einem oder mehr Buchstaben beginnt, dann in \lstinline!-! eingeschlossen eine Gruppe von einer oder mehr Ziffern aufweist und mit einem oder mehr Buchstaben endet. Die Zifferngruppe wird durch back referencing extrahiert.
\begin{lstlisting}
> gsub("^[[:alpha:]]+-([[:digit:]]+)-[[:alpha:]]+$",
+      "\\1", "abc-412-def")
[1] "412"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenketten als Befehl ausführen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!ausführen}
\index[func]{parse()@\lstinline{parse()}}
Durch die Kombination von \lstinline!parse()! und \lstinline!eval()! lassen sich Zeichenketten als Befehle interpretieren und wie direkt eingegebene Befehle ausführen. Dieses Zusammenspiel ermöglicht es, in Abhängigkeit von vorherigen Auswertungen einen nachfolgend benötigten Befehl zunächst als Zeichenkette zu erstellen und dann auszuführen.
\begin{lstlisting}
parse(file="<<Pfad und Dateiname>>", text="<<Zeichenkette>>")
\end{lstlisting}

Hierfür ist zunächst mit \lstinline!parse()! eine für das Argument \lstinline!text! zu übergebende Zeichenkette in ein weiter interpretierbares Objekt umzuwandeln.\footnote{Solcherart erstellte Objekte können mit\index[func]{deparse()@\lstinline{deparse()}} \lstinline!deparse()! wieder in Zeichenketten umgewandelt werden.} Ist \lstinline!text! ein Vektor von Zeichenketten, wird jedes Element als ein Befehl verstanden. Alternativ kann mit \lstinline!file! eine Datei oder sonstige Quelle genannt werden, die eine solche Zeichenkette enthält (Abschn.\ \ref{sec:readTable}).
\begin{lstlisting}
> obj1 <- parse(text="3 + 4")
> obj2 <- parse(text=c("vec <- c(1, 2, 3)", "vec^2"))
\end{lstlisting}

\index[func]{eval()@\lstinline{eval()}}
Das Ausführen eines mit \lstinline!parse()! erstellten Objekts geschieht mit \lstinline!eval(<<expression>>)!.
\begin{lstlisting}
> eval(obj1)
[1] 7

> eval(obj2)
[1] 1 4 9
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Datum und Uhrzeit}
\label{sec:date}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Insbesondere bei der Analyse von Zeitreihen\footnote{Für die Auswertung von Zeitreihen vgl.\ \citeA{Shumway2006, Hyndman2019} sowie den Abschnitt \emph{Time Series Analysis} der CRAN Task Views \cite{CRANtvTimeSeries}.} ist es sinnvoll, Zeit- und Datumsangaben in einer Form zu speichern, die es erlaubt, solche Werte in natürlicher Art für Berechnungen zu nutzen -- etwa um über die Differenz zweier Uhrzeiten die zwischen ihnen verstrichene Zeit ebenso zu ermitteln wie die zwischen zwei Datumsangaben liegende Anzahl von Tagen. R bietet solche Möglichkeiten mit Hilfe besonderer Klassen.\footnote{Für eine einführende Behandlung der vielen für Zeitangaben existierenden Subtilitäten vgl.\ \citeA{Grothendieck2004} sowie \lstinline!?DateTimeClasses!. Der Umgang mit Zeit- und Datumsangaben wird durch Funktionen des Pakets \lstinline!lubridate!\index[pack]{lubridate@\lstinline{lubridate}} \cite{Grolemund2011} erleichtert, das \citeA[Kap.~17]{Wickham2016a} eingehend vorstellen: \url{http://r4ds.hadley.nz/datetimes}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datumsangaben erstellen und formatieren}
\label{sec:dateFormat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Objekte der Klasse\index[func]{Date@\lstinline{Date}} \lstinline!Date! codieren ein Datum mittels der seit einem Stichtag (meist der 1.\ Januar 1970) verstrichenen Anzahl von Tagen und können Tag, Monat und Jahr eines Zeitpunkts ausgeben. Das aktuelle Datum unter Beachtung der Zeitzone nennt\index[func]{Sys.Date()@\lstinline{Sys.Date()}} \lstinline!Sys.Date()! in Form eines \lstinline!Date! Objekts. Um selbst ein Datum zu erstellen, ist\index[func]{as.Date()@\lstinline{as.Date()}} \lstinline!as.Date()! zu verwenden.
\begin{lstlisting}
as.Date(x="<<Datumsangabe>>", format="<<format string>>")
\end{lstlisting}

Die Datumsangabe für \lstinline!x! ist eine Zeichenkette, die ein Datum in einem Format nennt, das unter \lstinline!format! als\index{format string} format string zu spezifizieren ist. In einer solchen Zeichenkette stehen \lstinline!%<<Buchstabe>>! Kombinationen als Platzhalter für den einzusetzenden Teil einer Datumsangabe, sonstige Zeichen i.\,d.\,R.\ für sich selbst. Voreinstellung ist \lstinline!"%Y-%m-%d"!, wobei \lstinline!%Y! für die vierstellige Jahreszahl, \lstinline!%m! für die zweistellige Zahl des Monats und \lstinline!%d! für die zweistellige Zahl der Tage steht.\footnote{\label{ftn:dateFormat}Siehe Abschn.\ \ref{sec:strings} für format strings allgemein sowie \lstinline!?strptime! für weitere mögliche Elemente bei Datumsangaben. Wenn das Betriebssystem es unterstützt, kann man mit\index[func]{Sys.setlocale()@\lstinline{Sys.setlocale()}} \lstinline!Sys.setlocale("LC_TIME", "<<Länderkennung>>")! temporär die Ländereinstellung ändern, um mit Namen für Wochentage und Monate in unterschiedlichen Sprachen umgehen zu können. Die aktive Einstellung gibt \index[func]{Sys.getlocale()@\lstinline{Sys.getlocale()}} \lstinline!Sys.getlocale()! aus.} In diesem Format erfolgt auch die Ausgabe, die sich jedoch mit\index[func]{format()@\lstinline{format()}} \lstinline!format(<<Date-Objekt>>, format="<<format string>>")! kontrollieren lässt.
\begin{lstlisting}
> Sys.Date()
[1] "2009-02-09"

> (myDate <- as.Date("01.11.1974", format="%d.%m.%Y"))
[1] "1974-11-01"

> format(myDate, format="%d.%m.%Y")
[1] "01.11.1974"
\end{lstlisting}

Ihre numerische Repräsentation lässt sich direkt zum Erstellen von \lstinline!Date! Objekten nutzen.
\begin{lstlisting}
as.Date(x=<<Vektor>>, origin=<<Stichtag>>)
\end{lstlisting}

Für \lstinline!x! ist ein numerischer Vektor mit der seit dem Stichtag \lstinline!origin! verstrichenen Anzahl von Tagen zu nennen. Negative Zahlen stehen dabei für die Anzahl der Tage vor dem Stichtag. Der Stichtag selbst muss in Form eines \lstinline!Date! Objekts angegeben werden.
\begin{lstlisting}
# Datum, das 374 Tage vor dem 16.12.1910 liegt
> (negDate <- as.Date(-374, origin="1910-12-16"))
[1] "1909-12-07"

> as.numeric(negDate)             # Anzahl Tage vor Standard-Stichtag
[1] -21940
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Uhrzeit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Uhrzeit}
\index{Zeit|see{Uhrzeit}}
Objekte der Klasse\index[func]{POSIXct@\lstinline{POSIXct}} \lstinline!POSIXct! (\emph{calendar time}) sind die gebräuchlichste Lösung, um neben dem Datum auch die Uhrzeit eines Zeitpunkts zu repräsentieren. Datum und Zeitpunkt sind als Anzahl der Sekunden codiert, die seit einem Stichtag (meist der 1.\ Januar 1970) verstrichen sind.\footnote{Durch Verwendung von Dezimalzahlen lassen sich Sekundenbruchteile, etwa Millisekunden, repräsentieren.} Negative Zahlen stehen dabei für die Anzahl der Sekunden vor dem Stichtag. \lstinline!POSIXct! Objekte berücksichtigen die Zeitzone sowie die Unterscheidung von Sommer- und Winterzeit.

\lstinline!Sys.time()!\index[func]{Sys.time()@\lstinline{Sys.time()}} gibt das aktuelle Datum nebst Uhrzeit in Form eines \lstinline!POSIXct! Objekts aus, allerdings für eine Standard-Zeitzone. Das Ergebnis muss deshalb mit den u.\,g.\ Funktionen in die aktuelle Zeitzone konvertiert werden. Alternativ gibt \index[func]{date()@\lstinline{date()}} \lstinline!date()! Datum und Uhrzeit mit englischen Abkürzungen für Wochentag und Monat als Zeichenkette aus, wobei die aktuelle Zeitzone berücksichtigt wird.
\begin{lstlisting}
> Sys.time()
[1] "2009-02-07 09:23:02 CEST"

> date()
[1] "Sat Feb 7 09:23:02 2009"
\end{lstlisting}

Objekte der Klasse\index[func]{POSIXlt@\lstinline{POSIXlt}} \lstinline!POSIXlt! (\emph{local time}) speichern dieselbe Information, allerdings nicht in Form der seit einem Stichtag verstrichenen Sekunden, sondern als Liste mit benannten Komponenten: Dies sind numerische Vektoren u.\,a.\ für die Sekunden (\lstinline!sec!), Minuten (\lstinline!min!) und Stunden (\lstinline!hour!) der Uhrzeit sowie für Tag der Woche (\lstinline!wday! beginnend mit 0 für Sonntag), Tag des Monats (\lstinline!mday!), Tag des Jahres (\lstinline!yday!, beginnend mit 0 für den 1.\ Januar), Monat (\lstinline!mon!, 0 für Januar, 11 für Dezember) und Jahr (\lstinline!year!, Jahre seit 1900) des Datums. Zeichenketten lassen sich analog zu \lstinline!as.Date()! mit\index[func]{as.POSIXct()@\lstinline{as.POSIXct()}} \lstinline!as.POSIXct()! bzw.\ mit\index[func]{as.POSIXlt()@\lstinline{as.POSIXlt()}} \lstinline!as.POSIXlt()! in entsprechende Objekte konvertieren, \lstinline!strptime()!\index[func]{strptime()@\lstinline{strptime()}} erzeugt ebenfalls ein \lstinline!POSIXlt! Objekt.
\begin{lstlisting}
as.POSIXct(x="<<Datum und Uhrzeit>>", format="<<format string>>")
as.POSIXlt(x="<<Datum und Uhrzeit>>", format="<<format string>>")
  strptime(x="<<Datum und Uhrzeit>>", format="<<format string>>")
\end{lstlisting}

Voreinstellung für den format string bei \lstinline!as.POSIXlt()! und bei \lstinline!as.POSIXct()! ist \lstinline!"%Y-%m-%d %H:%M:%S"!, wobei \lstinline!%H! für die zweistellige Zahl der Stunden im 24~h-Format, \lstinline!%M! für die zweistellige Zahl der Minuten und \lstinline!%S! für die zweistellige Zahl der Sekunden des Datums stehen (Fußnote \ref{ftn:dateFormat}). Als erstes Argument ist auch die Anzahl der Sekunden zulässig, die seit einem Stichtag verstrichen sind. Dieser muss dann für das Argument \lstinline!origin! as Datum genannt werden.
\begin{lstlisting}
> (myTime <- as.POSIXct("2009-02-07 09:23:02"))
[1] "2009-02-07 09:23:02 CET"

> charDates <- c("05.08.1972, 03:37", "31.03.1981, 12:44")
> (lDates   <- strptime(charDates, format="%d.%m.%Y, %H:%M"))
[1] "1972-08-05 03:37:00" "1981-03-31 12:44:00"

# Zeitpunkt als Anzahl Sekunden seit 1.1.1970 (mit 250 Millisekunden)
> as.POSIXct(678295.25, origin=as.Date("1970-01-01"))
[1] "1970-01-08 21:24:55 CET"

> lDates$mday                           # Tag isoliert
[1] 5 31

> lDates$hour                           # Stunde isoliert
[1] 3 12
\end{lstlisting}

\index[func]{ISOdate()@\lstinline{ISOdate()}}
\lstinline!POSIXct! Objekte können besonders einfach mit der Funktion \lstinline!ISOdate()! erstellt werden, die intern auf \lstinline!strptime()! basiert, aber keinen format string benötigt.
\begin{lstlisting}
ISOdate(year=<<Jahr>>, month=<<Monat>>, day=<<Tag>>, hour=<<Stunde>>,
        min=<<Minute>>, sec=<<Sekunde>>, tz="<<Zeitzone>>")
\end{lstlisting}

Für die sich auf Datum und Uhrzeit beziehenden Argumente können Zahlen im 24h-Format angegeben werden, wobei 12:00:00h Voreinstellung für die Uhrzeit ist. Mit \lstinline!tz! lässt sich die Zeitzone im Form der standardisierten Akronyme festlegen, Voreinstellung ist hier \lstinline!"GMT"!.
\begin{lstlisting}
# Zeitzone: Central European Time
> ISOdate(2010, 6, 30, 17, 32, 10, tz="CET")
[1] "2010-06-30 17:32:10 CEST"
\end{lstlisting}

Auch Objekte der Klassen \lstinline!POSIXct! und \lstinline!POSIXlt! können mit\index[func]{format()@\lstinline{format()}} \lstinline!format()! in der gewünschten Formatierung ausgegeben werden.
\begin{lstlisting}
> format(myTime, "%H:%M:%S")        # nur Stunden, Minuten, Sekunden
[1] "09:23:02"

> format(lDates, "%d.%m.%Y")        # nur Tag, Monat, Jahr
[1] "05.08.1972" "31.03.1981"
\end{lstlisting}

\index[func]{weekdays()@\lstinline{weekdays()}}
\index[func]{months()@\lstinline{months()}}
\index[func]{quarters()@\lstinline{quarters()}}
Aus Datumsangaben der Klasse \lstinline!Date!, \lstinline!POSIXct! und \lstinline!POSIXlt! lassen sich bestimmte weitere Informationen in Form von Zeichenketten extrahieren, etwa der Wochentag mit \lstinline!weekdays(<<Datum>>)!, der Monat mit \lstinline!months(<<Datum>>)! oder das Quartal mit \lstinline!quarters(<<Datum>>)!.
\begin{lstlisting}
> weekdays(lDates)
[1] "Samstag" "Dienstag"

> months(lDates)
[1] "August" "März"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mit Datum und Uhrzeit rechnen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Objekte der Klasse \lstinline!Date!, \lstinline!POSIXct! und \lstinline!POSIXlt! verhalten sich in vielen arithmetischen Kontexten in natürlicher Weise, da die sinnvoll für Datumsangaben interpretierbaren Rechenfunktionen besondere Methoden für sie besitzen (Abschn.\ \ref{sec:funcGeneric}): So werden zu \lstinline!Date! Objekten addierte Zahlen als Anzahl von Tagen interpretiert. Das Ergebnis ist ein Datum, das entsprechend viele Tage vom \lstinline!Date! Objekt abweicht. Die Differenz zweier \lstinline!Date! Objekte besitzt die Klasse \lstinline!difftime! und wird als Anzahl der Tage im Zeitintervall vom zweiten zum ersten Datum ausgegeben. Hierbei ergeben sich negative Zahlen, wenn das erste Datum zeitlich vor dem zweiten liegt.\footnote{Die Zeiteinheit der im \lstinline!difftime! Objekt gespeicherten Werte (etwa Tage oder Minuten), hängt davon ab, aus welchen Datumsangaben das Objekt entstanden ist. Alternativ bestimmt das Argument \lstinline!units! von\index[func]{difftime()@\lstinline{difftime()}} \lstinline!difftime()!, um welche Einheit es sich handeln soll.} Ebenso wie Zahlen lassen sich auch \lstinline!difftime! Objekte zu \lstinline!Date! Objekten addieren.
\begin{lstlisting}
> myDate + 365
[1] "1975-11-01"

> (diffDate <- as.Date("1976-06-19") - myDate)  # Zeitintervall
Time difference of 596 days

> as.numeric(diffDate)                          # Intervall als Zahl
[1] 596

> myDate + diffDate
[1] "1976-06-19"
\end{lstlisting}

Zu Objekten der Klasse \lstinline!POSIXlt! oder \lstinline!POSIXct! addierte Zahlen werden als Sekunden interpretiert. Aus der Differenz zweier solcher Objekte entsteht ebenfalls ein Objekt der Klasse \lstinline!difftime!. Die Addition von \lstinline!difftime! und \lstinline!POSIXlt! oder \lstinline!POSIXct! Objekten ist ebenfalls definiert.
\begin{lstlisting}
> lDates + c(60, 120)                           # 1, 2 Minuten später
[1] "1972-08-05 03:38:00 CET" "1981-03-31 12:46:00 CEST"

> (diff21 <- lDates[2] - lDates[1])
Time difference of 3160.338 days

> lDates[1] + diff21
[1] "1981-03-31 12:44:00 CEST"
\end{lstlisting}

Mit \lstinline!round()! bzw.\ \lstinline!trunc()! lassen sich Objekte der Klasse \lstinline!POSIXlt! oder \lstinline!POSIXct! auf ganze Sekunden, Minuten, Stunden, Tage, Monate oder Jahre runden bzw.\ tranchieren, indem das Argument \lstinline!units! auf \lstinline!"secs"!, \lstinline!"mins"!, \lstinline!"days"!, \lstinline!"months"! oder \lstinline!"years"! gesetzt wird.
\begin{lstlisting}
> round(lDates, units="days")                   # rund auf nächsten Tag
[1] "1972-08-05 CET"  "1981-04-01 CEST"

> trunc(lDates, units="years")                  # tranchiere auf Jahr
[1] "1972-01-01 CET" "1981-01-01 CET"
\end{lstlisting}

In \lstinline!seq()! (Abschn.\ \ref{sec:seq}) ändert sich die Bedeutung des Arguments \lstinline!by! hin zu Zeitangaben, wenn für \lstinline!from! und \lstinline!to! Datumsobjekte übergeben werden. Für die Schrittweite werden dann etwa die Werte \lstinline!"<<Anzahl>> years"! oder \lstinline!"<<Anzahl>> days"! akzeptiert (\lstinline!?seq.POSIXt!). Dies gilt analog auch für das Argument \lstinline!breaks! der \lstinline!cut()! Funktion (Abschn.\ \ref{sec:cut}). Sie teilt kontinuierliche Datumsangaben in Kategorien ein, die etwa durch Stunden (\lstinline!breaks="hour"!) oder Kalenderwochen (\lstinline!breaks="week"!) definiert sind (\lstinline!?cut.POSIXt!). Für weitere geeignete arithmetische Funktionen s.\ \lstinline!methods(class="POSIXt")! und \lstinline!methods(class="Date")!.
\begin{lstlisting}
# jährliche Schritte vom 01.05.2010 bis zum 01.05.2013
> seq(ISOdate(2010, 5, 1), ISOdate(2015, 5, 1), by="years")
[1] "2010-05-01 12:00:00 GMT" "2011-05-01 12:00:00 GMT"
[3] "2012-05-01 12:00:00 GMT" "2013-05-01 12:00:00 GMT"

# 4 zweiwöchentliche Schritte vom 22.10.1997
> seq(ISOdate(1997, 10, 22), by="2 weeks", length.out=4)
[1] "1997-10-22 12:00:00 GMT" "1997-11-05 12:00:00 GMT"
[3] "1997-11-19 12:00:00 GMT" "1997-12-03 12:00:00 GMT"

# 100 zufällige Daten zwischen 13.06.1995 und 4 Wochen später
> secsPerDay <- 60 * 60 * 24                # Sekunden pro Tag
> randDates  <- ISOdate(1995, 6, 13)
+               + sample(0:(28*secsPerDay), 100, replace=TRUE)

# runde Zufallsdaten Tag-genau
> head(round(randDates, units="days"), n=3)
[1] "1995-07-03 GMT" "1995-06-24 GMT" "1995-07-11 GMT"

# teile Daten in Kalenderwochen ein
> randWeeks <- cut(randDates, breaks="week")
> summary(randWeeks)                        # Häufigkeiten
1995-06-12  1995-06-19  1995-06-26  1995-07-03  1995-07-10
        15          26          20          37           2
\end{lstlisting}
