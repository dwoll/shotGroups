%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Elementare Dateneingabe und -verarbeitung}
\label{sec:basics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Die folgenden Abschnitte sollen gleichzeitig die grundlegenden Datenstrukturen in R sowie Möglichkeiten zur deskriptiven Datenauswertung erläutern. Die Reihenfolge der Themen ist dabei so gewählt, dass die abwechselnd vorgestellten Datenstrukturen und darauf aufbauenden deskriptiven Methoden nach und nach an Komplexität gewinnen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Vektoren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

R ist eine vektorbasierte Sprache, ist also auf die Verarbeitung von in Vektoren angeordneten Daten ausgerichtet. Ein\index{Vektor} Vektor ist dabei lediglich eine Datenstruktur für eine sequentiell geordnete Menge einzelner Werte und nicht mit dem mathematischen Konzept eines Vektors zu verwechseln. Da sich empirische Daten einer Variable meist als eine linear anzuordnende Wertemenge betrachten lassen, sind Vektoren als Organisationsform gut für die Datenanalyse geeignet. Vektoren sind in R die einfachste Datenstruktur für Werte, d.\,h.\ auch jeder Skalar oder andere Einzelwert ist ein Vektor der Länge $1$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vektoren erzeugen}
\label{sec:vector}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!erstellen}
Vektoren werden durch Funktionen erzeugt, die den Namen eines Datentyps tragen und als Argument die Anzahl der zu speichernden Elemente erwarten, also etwa\index[func]{numeric()@\lstinline{numeric()}} \lstinline!numeric(<<Anzahl>>)!.\footnote{\label{ftn:vecDetails}Ein leerer Vektor entsteht analog, z.\,B.\ durch \lstinline!numeric(0)!. Auf 32bit-Systemen kann ein Vektor höchstens\index[func]{.Machine@\lstinline{.Machine}} \lstinline!.Machine$integer.max! viele ($2^{31}-1$) Elemente enthalten, auf 64bit-Systemen jedoch gut $2^{50}$. Mit\index[func]{vector()@\lstinline{vector()}} \lstinline!vector(mode="<<Klasse>>", n=<<Länge>>)! lassen sich beliebige Objekte der für \lstinline!mode! genannten Klasse der Länge \lstinline!n! erzeugen.} Die Elemente des Vektors werden hierbei auf eine Voreinstellung gesetzt, die vom Datentyp abhängt -- \lstinline!0! für \lstinline!numeric()!, \lstinline!""! für \lstinline!character! und \lstinline!FALSE! für \lstinline!logical!.
\begin{lstlisting}
> numeric(4)
[1] 0 0 0 0

> character(2)
[1] "" ""
\end{lstlisting}

Als häufiger genutzte Alternative lassen sich Vektoren auch mit der Funktion \lstinline!c(<<Wert1>>, <<Wert2>>, ...)!\index[func]{c()@\lstinline{c()}|textbf} erstellen (\emph{concatenate}), die die Angabe der zu speichernden Werte benötigt. Ein das Alter von sechs Personen speichernder Vektor könnte damit so erstellt werden:
\begin{lstlisting}
> (age <- c(18, 20, 30, 24, 23, 21))
[1] 18 20 30 24 23 21
\end{lstlisting}

\index{Vektor!zusammenfügen}
Dabei werden die Werte in der angegebenen Reihenfolge gespeichert und intern mit fortlaufenden Indizes für ihre Position im Vektor versehen. Sollen bereits bestehende Vektoren zusammengefügt werden, ist ebenfalls \lstinline!c()! zu nutzen, wobei statt eines einzelnen Wertes auch der Name eines bereits bestehenden Vektors angegeben werden kann.
\begin{lstlisting}
> addAge  <- c(27, 21, 19)                # zusätzlicher Vektor
> (ageNew <- c(age, addAge))              # kombinierter Vektor
[1] 18 30 30 25 23 21 27 21 19
\end{lstlisting}

Mit \lstinline!length(<<Vektor>>)!\index[func]{length()@\lstinline{length()}|textbf}\index{Vektor!Anzahl Elemente}\index{Vektor!Länge} wird die Länge eines Vektors, d.\,h.\ die Anzahl der in ihm gespeicherten Elemente, erfragt.
\begin{lstlisting}
> length(age)
[1] 6
\end{lstlisting}

Auch Zeichenketten können die Elemente eines Vektors ausmachen. Dabei zählt die leere Zeichenkette \lstinline!""! ebenfalls als ein Element.
\begin{lstlisting}
> (chars <- c("lorem", "ipsum", "dolor", ""))
[1] "lorem" "ipsum" "dolor" ""

> length(chars)
[1] 4
\end{lstlisting}

Zwei aus Zeichen bestehende Vektoren sind in R bereits vordefiniert, \lstinline!LETTERS!\index[func]{LETTERS@\lstinline{LETTERS, letters}} und \lstinline!letters!, die jeweils alle Buchstaben A--Z bzw.\ a--z in alphabetischer Reihenfolge als Elemente besitzen.
\begin{lstlisting}
> LETTERS[c(1, 2, 3)]               # Alphabet in Großbuchstaben
[1] "A" "B" "C"

> letters[c(4, 5, 6)]               # Alphabet in Kleinbuchstaben
[1] "d" "e" "f"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elemente auswählen und verändern}
\label{sec:vecSel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Elemente auswählen}
\index{Vektor!indizieren}
Um ein einzelnes Element eines Vektors abzurufen, wird seine Position im Vektor (sein Index) in eckigen Klammern, dem \lstinline![<<Index>>]!\index[func]{[]@\lstinline{[]}} Operator, hinter dem Objektnamen angegeben.\footnote{Für Hilfe zu diesem Thema s.\ \lstinline!?Extract!. Auch der Index-Operator ist eine Funktion, kann also gleichermaßen in der Form \lstinline!\"[\"(<<Vektor>>, <<Index>>)! verwendet werden (Abschn.\ \ref{sec:funcParam}, Fußnote \ref{ftn:functional}).} Indizes beginnen bei $1$ für die erste Position\footnote{Dies mag selbstverständlich erscheinen, in anderen Sprachen wird jedoch oft der Index $0$ für die erste Position und allgemein der Index $i-1$ für die $i$\/-te Position verwendet. Für einen Vektor \lstinline!x! ist das Ergebnis von \lstinline!x[0]! immer ein leerer Vektor mit demselben Datentyp wie jener von \lstinline!x!.} und enden bei der Länge des Vektors. Werden größere Indizes verwendet, erfolgt als Ausgabe die für einen fehlenden Wert stehende Konstante \lstinline!NA! (Abschn.\ \ref{sec:na}).
\begin{lstlisting}
> age[4]                                    # 4. Element von age
[1] 24

> (ageLast <- age[length(age)])             # letztes Element von age
[1] 21

> age[length(age) + 1]
[1] NA
\end{lstlisting}

\index{Vektor!unbenannt}
Ein Vektor muss nicht unbedingt einem Objekt zugewiesen werden, um indiziert werden zu können, dies ist auch für unbenannte Vektoren möglich.
\begin{lstlisting}
> c(11, 12, 13, 14)[2]
[1] 12
\end{lstlisting}

\index{Vektor!Indexvektor!numerisch}
\index{Indexvektor|see{Vektor}}
\index{indizieren|see{Datensatz, Matrix, Vektor}}
Mehrere Elemente eines Vektors lassen sich gleichzeitig abrufen, indem ihre Indizes in Form eines Indexvektors in die eckigen Klammern eingeschlossen werden. Dazu kann man zunächst einen eigenen Vektor erstellen, dessen Name dann in die eckigen Klammern geschrieben wird. Ebenfalls kann der Befehl zum Erzeugen eines Vektors direkt in die eckigen Klammern verschachtelt werden. Der Indexvektor kann auch länger als der indizierte Vektor sein, wenn einzelne Elemente mehrfach ausgegeben werden sollen. Das Weglassen eines Index mit \lstinline!<<Vektor>>[]! führt dazu, dass alle Elemente des Vektors ausgegeben werden.
\begin{lstlisting}
> idx <- c(1, 2, 4)
> age[idx]
[1] 18 20 24

> age[c(3, 5, 6)]
[1] 30 23 21

> age[c(1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6)]
[1] 18 18 20 20 30 30 24 24 23 23 21 21
\end{lstlisting}

Beinhaltet der Indexvektor fehlende Werte (\lstinline!NA!), erzeugt dies in der Ausgabe ebenfalls einen fehlenden Wert an der entsprechenden Stelle.
\begin{lstlisting}
> age[c(4, NA, 1)]
[1] 25 NA 17
\end{lstlisting}

\index{Vektor!Elemente auslassen}
Wenn alle Elemente bis auf ein einzelnes abgerufen werden sollen, ist dies am einfachsten zu erreichen, indem der Index des nicht erwünschten Elements mit negativem Vorzeichen in die eckigen Klammern geschrieben wird.\footnote{Als Indizes dürfen in diesem Fall keine fehlenden Werte (\lstinline!NA!) oder Indizes mit positivem Vorzeichen vorkommen, ebenso darf der Indexvektor nicht leer sein.} Sollen mehrere Elemente nicht ausgegeben werden, verläuft der Aufruf analog zum Aufruf gewünschter Elemente, wobei mehrere Variationen mit dem negativen Vorzeichen möglich sind.
\begin{lstlisting}
> age[-3]             # alle Elemente bis auf das 3.
[1] 18 20 24 23 21

> age[c(-1, -2, -4)]  # alle Elemente bis auf das 1., 2. und 4.
[1] 30 23 21

> age[-c(1, 2, 4)]    # alle Elemente bis auf das 1., 2. und 4.
[1] 30 23 21

> age[-idx]           # alle Elemente bis auf die Indizes im Vektor idx
[1] 30 23 21
\end{lstlisting}

\index{Vektor!Elemente ändern}
Die in einem Vektor gespeicherten Werte können nachträglich verändert werden. Dazu muss der Position des zu ändernden Wertes der neue Wert zugewiesen werden.
\begin{lstlisting}
> age[4] <- 25
> age
[1] 18 20 30 25 23 21
\end{lstlisting}

Das Verändern von mehreren Elementen gleichzeitig geschieht analog. Dazu lassen sich die Möglichkeiten zur Auswahl mehrerer Elementen nutzen und diesen in einem Arbeitsschritt neue Werte zuweisen. Dabei müssen die zugewiesenen Werte ebenfalls durch einen Vektor repräsentiert sein. Fehlt bei Zuweisungen der Index \lstinline!<<Vektor>>[]!, werden alle Elemente des Vektors ersetzt. Wenn der zugewiesene Vektor dabei weniger Elemente als der veränderte Vektor besitzt, wird er automatisch passend verlängert (Abschn.\ \ref{sec:recycling}).
\begin{lstlisting}
> age[idx] <- c(17, 30, 25)
> age
[1] 17 30 30 25 23 21

# alle Elemente gleichzeitig ersetzen mit zyklischer Verlängerung
> age[] <- c(1, 2)
> age
[1] 1 2 1 2 1 2
\end{lstlisting}

\index{Vektor!verlängern}
Um Vektoren zu verlängern, also mit neuen Elementen zu ergänzen, kann zum einen der \lstinline![<<Index>>]! Operator benutzt werden, wobei als Index nicht belegte Positionen angegeben werden.\footnote{\label{ftn:vecAdd}Bei der Verarbeitung sehr großer Datenmengen ist zu bedenken, dass die schrittweise Vergrößerung von Objekten aufgrund der dafür notwendigen internen Kopiervorgänge ineffizient ist. Objekte sollten deshalb bevorzugt bereits mit der Größe und dem Datentyp angelegt werden, die sie später benötigen.} Zum anderen kann auch hier \lstinline!c(<<Wert1>>, <<Wert2>>, ...)! Verwendung finden. Als Alternative steht die \lstinline!append(<<Vektor>>, values=<<Vektor>>)!\index[func]{append()@\lstinline{append()}} Funktion zur Verfügung, die an einen Vektor die Werte eines unter \lstinline!values! genannten Vektors anhängt.
\begin{lstlisting}
> charVec1 <- c("Z", "Y", "X")
> charVec1[c(4, 5, 6)] <- c("W", "V", "U")
> charVec1
[1] "Z" "Y" "X" "W" "V" "U"

> (charVec2 <- c(charVec1, "T", "S", "R"))
[1] "Z" "Y" "X" "W" "V" "U" "T" "S" "R"

> (charVec3 <- append(charVec2, c("Q", "P", "O")))
[1] "Z" "Y" "X" "W" "V" "U" "T" "S" "R" "Q" "P" "O"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datentypen in Vektoren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Datentypen}
\index{Datentyp!mischen}
Vektoren können Werte unterschiedlicher Datentypen speichern, etwa \lstinline!numeric!, wenn sie Zahlen beinhalten, oder \lstinline!character! im Fall von Zeichenketten. Letztere müssen dabei immer in Anführungszeichen stehen. Jeder Vektor kann aber nur einen Datentyp besitzen, alle seine Elemente haben also denselben Datentyp. Fügt man einem numerischen Vektor eine Zeichenkette hinzu, so werden seine numerischen Elemente automatisch in Zeichenketten umgewandelt,\footnote{Allgemein gesprochen werden alle Elemente in den umfassendsten Datentyp umgewandelt, der notwendig ist, um alle Werte ohne Informationsverlust zu speichern (Abschn.\ \ref{sec:dataTypes}).} was man an den hinzugekommenen Anführungszeichen erkennt und mit \lstinline!mode(<<Vektor>>)! überprüfen kann.
\begin{lstlisting}
> charVec4 <- "word"
> numVec   <- c(10, 20, 30)
> (combVec <- c(charVec4, numVec))
[1] "word" "10" "20" "30"

> mode(combVec)
[1] "character"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elemente benennen}
\label{sec:valNames}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Elemente benennen}
Es ist möglich, die Elemente eines Vektors bei seiner Erstellung zu benennen. Die Elemente können dann nicht nur über ihren Index, sondern auch über ihren in Anführungszeichen gesetzten Namen angesprochen werden.\footnote{Namen werden als Attribut gespeichert und sind mit \lstinline!attributes(<<Vektor>>)! sichtbar (Abschn.\ \ref{sec:objects}). Elemente lassen sich über den Namen nur auswählen, nicht aber mittels \lstinline!<<Vektor>>[-"<<Name>>"]! ausschließen, hierfür bedarf es des numerischen Index.} In der Ausgabe wird der Name eines Elements in der über ihm stehenden Zeile mit aufgeführt.
\begin{lstlisting}
> (namedVec1 <- c(elem1="first", elem2="second"))
elem1    elem2
"first"  "second"

> namedVec1["elem1"]
elem1
"first"
\end{lstlisting}

Auch im nachhinein lassen sich Elemente benennen, bzw.\ vorhandene Benennungen ändern -- beides geschieht mit\index[func]{names()@\lstinline{names()}|textbf} \lstinline!names(<<Vektor>>)!. Ganz entfernt werden die Namen der Elemente mit \index[func]{unname()@\lstinline{unname()}} \lstinline!unname(<<Vektor>>)!.
\begin{lstlisting}
> (namedVec2 <- c(val1=10, val2=-12, val3=33))
val1  val2  val3
  10   -12    33

> names(namedVec2)                                  # vorhandene Namen
[1] "val1" "val2" "val3"

> names(namedVec2) <- c("A", "B", "C")              # verändere Namen
> namedVec2
 A    B   C
10  -12  33

> unname(namedVec2)
[1]  10 -12  33
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elemente löschen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Elemente löschen}
Elemente eines Vektors lassen sich nicht im eigentlichen Sinne löschen. Denselben Effekt kann man stattdessen über zwei mögliche Umwege erzielen. Zum einen kann ein bestehender Vektor mit einer Auswahl seiner eigenen Elemente überschrieben werden.
\begin{lstlisting}
> vec <- c(10, 20, 30, 40, 50)
> vec <- vec[-c(4, 5)]
> vec
[1] 10 20 30
\end{lstlisting}

\index{Vektor!verkürzen}
Zum anderen kann ein bestehender Vektor über \lstinline!length()! verkürzt werden, indem ihm eine Länge zugewiesen wird, die kleiner als seine bestehende ist. Gelöscht werden dabei die überzähligen Elemente am Ende des Vektors.
\begin{lstlisting}
> vec         <- c(1, 2, 3, 4, 5)
> length(vec) <- 3
> vec
[1] 1 2 3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Logische Operatoren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Verarbeitungsschritte mit logischen Vergleichen und Werten treten häufig bei der Auswahl von Teilmengen von Daten sowie bei der Recodierung von Datenwerten auf. Dies liegt vor allem an der Möglichkeit, in Vektoren und anderen Datenstrukturen gespeicherte Werte auch mit logischen Indexvektoren auszuwählen (Abschn.\ \ref{sec:which}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vektoren mit logischen Operatoren vergleichen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Vergleiche}
\index{Vektor!Bedingungen prüfen}
Vektoren werden oft mit Hilfe logischer Operatoren mit einem bestimmten Wert, oder auch mit anderen Vektoren verglichen um zu prüfen, ob die Elemente gewisse Bedingungen erfüllen. Als Ergebnis der Prüfung wird ein logischer Vektor mit Wahrheitswerten ausgegeben, der die Resultate der elementweisen Anwendung des Operators beinhaltet.

Als Beispiel seien im Vektor \lstinline!age! wieder die Daten von sechs Personen gespeichert. Zunächst sollen jene Personen identifiziert werden, die jünger als $24$ Jahre sind. Dazu wird der \lstinline!<! Operator verwendet, der als Ergebnis einen Vektor mit Wahrheitswerten liefert, der für jedes Element separat angibt, ob die Bedingung $< 24$ zutrifft. Andere Vergleichsoperatoren, wie gleich (\lstinline!==!), ungleich (\lstinline|!=|), etc.\ funktionieren analog.
\begin{lstlisting}
> age <- c(17, 30, 30, 24, 23, 21)
> age < 24
[1] TRUE FALSE FALSE FALSE TRUE TRUE
\end{lstlisting}

Wenn zwei Vektoren miteinander logisch verglichen werden, wird der Operator immer auf ein zueinander gehörendes Wertepaar angewendet, also auf Werte, die sich an derselben Position in ihrem jeweiligen Vektor befinden.
\begin{lstlisting}
> x <- c(2, 4, 8)
> y <- c(3, 4, 5)
> x == y
[1] FALSE TRUE FALSE

> x < y
[1] TRUE FALSE FALSE
\end{lstlisting}

Auch die Prüfung jedes Elements auf mehrere Kriterien ist möglich. Wenn zwei Kriterien gleichzeitig erfüllt sein sollen, wird \lstinline!&!\index[func]{&@\lstinline{&, &&}} als Symbol für das logische UND\index{UND} verwendet. Wenn nur eines von zwei Kriterien erfüllt sein muss, ist das\index[func]{\textbar@\texttt{\textbar, \textbar\textbar}} Symbol \lstinline!|! für das\index{ODER} logische, d.\,h.\ einschließende, ODER zu verwenden. Um sicherzustellen, dass R die zusammengehörenden Ausdrücke auch als Einheit erkennt, ist die Verwendung runder Klammern zu empfehlen.
\begin{lstlisting}
> (age <= 20) | (age >= 30)     # Werte im Bereich bis 20 ODER ab 30?
[1] TRUE TRUE TRUE FALSE FALSE FALSE

> (age > 20) & (age < 30)       # Werte im Bereich zwischen 20 und 30?
[1] FALSE FALSE FALSE TRUE TRUE TRUE
\end{lstlisting}

UND und ODER dürfen bei zusammengesetzten Prüfungen nicht weggelassen werden: Während man mathematisch also eine Bedingung etwa als $0 \leq x \leq 10$ formulieren würde, müsste sie in R in Form von mit UND verbundenen Einzelprüfungen geschrieben werden, also wie oben als \lstinline!(0 <= x) & (x <= 10)!.

Während die elementweise Prüfung von Vektoren den häufigsten Fall der Anwendung logischer Kriterien ausmacht, sind vor allem zur Fallunterscheidung (Abschn.\ \ref{sec:ifElseSwitch}) auch Prüfungen notwendig, die in Form eines einzelnen Wahrheitswertes eine summarische Auskunft darüber liefern, ob Kriterien erfüllt sind. Diese Prüfungen lassen sich mit \lstinline!&&!\index[func]{&@\lstinline{&, &&}} für das logische\index{UND} UND bzw.\ mit\index[func]{\textbar@\texttt{\textbar, \textbar\textbar}} \lstinline!||! für das logische\index{ODER} ODER formulieren. Beide Vergleiche werten nur das jeweils erste Element aus, wenn Vektoren beteiligt sind und geben auch in diesem Fall nur einen Wahrheitswert zurück.
\begin{lstlisting}
> c(TRUE, FALSE, FALSE) && c(TRUE, TRUE, FALSE)
[1] TRUE

> c(FALSE, FALSE, TRUE) || c(FALSE, TRUE, FALSE)
[1] FALSE
\end{lstlisting}

\lstinline!identical()! prüft zwei übergebene Vektoren summarisch auf Gleichheit und gibt nur dann das Ergebnis \lstinline!TRUE! aus, wenn diese auch bzgl.\ ihrer internen Repräsentation exakt identisch sind (Abschn.\ \ref{sec:isTRUE}).
\begin{lstlisting}
> c(1, 2) == c(1L, 2L)
[1] TRUE TRUE

> identical(c(1, 2), c(1L, 2L))
[1] FALSE
\end{lstlisting}

Sollen Werte nur auf ungefähre Übereinstimmung geprüft werden, kann dies mit \lstinline!all.equal()!\index[func]{all.equal()@\lstinline{all.equal()}} geschehen (Abschn.\ \ref{sec:isTRUE}). Dabei ist im Fall von zu vergleichenden Vektoren zu beachten, dass die Funktion keinen Vektor der Ergebnisse der elementweisen Einzelvergleiche ausgibt. Stattdessen liefert sie nur einen einzelnen Wert zurück, entweder \lstinline!TRUE! im Fall der paarweisen Übereinstimmung aller Elemente oder das mittlere Abweichungsmaß im Fall der Ungleichheit. Um auch in letzterem Fall einen Wahrheitswert als Ausgabe zu erhalten, sollte \lstinline!isTRUE()!\index[func]{isTRUE()@\lstinline{isTRUE()}} verwendet werden.
\begin{lstlisting}
> x <- c(4, 5, 6)
> y <- c(4, 5, 6)
> z <- c(1, 2, 3)
> all.equal(x, y)
[1] TRUE

> all.equal(y, z)
[1] "Mean relative difference: 0.6"

> isTRUE(all.equal(y, z))
[1] FALSE
\end{lstlisting}

Bei der Prüfung von Elementen auf Kriterien kann mit Hilfe spezialisierter Funktionen summarisch analysiert werden, ob diese Kriterien zutreffen. Ob mindestens ein Element eines logischen Vektors den Wert \lstinline!TRUE! besitzt, zeigt\index[func]{any()@\lstinline{any()}} \lstinline!any(<<Vektor>>)!, ob alle Elemente den Wert \lstinline!TRUE! haben, gibt\index[func]{all()@\lstinline{all()}} \lstinline!all(<<Vektor>>)! an.\footnote{Dabei erzeugt \lstinline!all(numeric(0))! das Ergebnis \lstinline!TRUE!, da die Aussage {\quotedblbase}alle Elemente des leeren Vektors sind WAHR{\textquotedblleft} logisch WAHR ist -- schließlich lässt sich kein Gegenbeispiel in Form eines Elements finden, das FALSCH wäre. Dagegen erzeugt \lstinline!any(numeric(0))! das Ergebnis \lstinline!FALSE!, da in einem leeren Vektor nicht mindestens ein Element existiert, das WAHR ist.}
\begin{lstlisting}
> res <- age > 30
> any(res)
[1] FALSE

> any(age < 18)
[1] TRUE

> all(x == y)
[1] TRUE
\end{lstlisting}

\index{Vektor!Fälle zählen}
Um zu zählen, auf wie viele Elemente eines Vektors ein Kriterium zutrifft, wird die Funktion \lstinline!sum(<<Vektor>>)! verwendet, die alle Werte eines Vektors aufaddiert (Abschn.\ \ref{sec:sum}).
\begin{lstlisting}
> res <- age < 24
> sum(res)
[1] 3
\end{lstlisting}

Alternativ kann verschachtelt in \lstinline!length()! die Funktion \lstinline!which(<<Vektor>>)! genutzt werden, die die Indizes der Elemente mit dem Wert \lstinline!TRUE! ausgibt (Abschn.\ \ref{sec:which}).
\begin{lstlisting}
> which(age < 24)
[1] 1 5 6

> length(which(age < 24))
[1] 3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Logische Indexvektoren}
\label{sec:which}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Indexvektor!logisch}
Vektoren von Wahrheitswerten können wie numerische Indexvektoren zur Indizierung anderer Vektoren benutzt werden. Diese Art zu indizieren kann z.\,B.\ zur Auswahl von Teilstichproben genutzt werden, die durch bestimmte Merkmale definiert sind. Hat ein Element des logischen Indexvektors den Wert \lstinline!TRUE!, so wird das sich an dieser Position befindliche Element des indizierten Vektors ausgegeben. Hat der logische Indexvektor an einer Stelle den Wert \lstinline!FALSE!, so wird das zugehörige Element des indizierten Vektors ausgelassen.
\begin{lstlisting}
> age[c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE)]
[1] 17 30 24 21
\end{lstlisting}

Wie numerische können auch logische Indizes zunächst in einem Vektor gespeichert werden, mit dem die Indizierung dann später geschieht. Statt der Erstellung eines separaten logischen Indexvektors, z.\,B.\ als Ergebnis einer Überprüfung von Bedingungen, kann der Schritt aber auch übersprungen und der logische Ausdruck direkt innerhalb des \lstinline![<<Index>>]! Operators benutzt werden. Dabei ist jedoch abzuwägen, ob der Übersichtlichkeit und Nachvollziehbarkeit der Befehle mit einer separaten Erstellung von Indexvektoren besser gedient ist.
\begin{lstlisting}
> (idx <- (age <= 20) | (age >= 30))  # Wertebereich bis 20 ODER ab 30?
[1] TRUE TRUE TRUE FALSE FALSE FALSE

> age[idx]
[1] 17 30 30

> age[(age >= 30) | (age <= 20)]
[1] 17 30 30
\end{lstlisting}

Bei logischen Indexvektoren kann anders als bei numerischen Indexvektoren die von R automatisch vorgenommene zyklische Verlängerung greifen (Abschn.\ \ref{sec:recycling}): Logische Indexvektoren mit weniger Elementen als jene des indizierten Vektors werden durch zyklische Wiederholung soweit verlängert, dass sie mindestens die Länge des indizierten Vektors erreichen.
\begin{lstlisting}
> age[c(TRUE, FALSE)]         # logischer Indexvektor kürzer als age
[1] 18 30 23

# durch zyklische Verlängerung von c(TRUE, FALSE) äquivalent zu
> age[c(TRUE,FALSE, TRUE,FALSE, TRUE,FALSE)]
[1] 18 30 23
\end{lstlisting}

\index{Daten!fehlende Werte!Indexvektor}
Logische Indexvektoren bergen den Nachteil, dass sie zu Problemen führen können, wenn der zu prüfende Vektor fehlende Werte enthält. Überall dort, wo dieser \lstinline!NA! ist, wird i.\,d.\,R.\ auch das Ergebnis eines logischen Vergleichs \lstinline!NA! sein, d.\,h.\ der resultierende logische Indexvektor enthält seinerseits fehlende Werte (Abschn.\ \ref{sec:treatNA}, Fußnote \ref{ftn:whenNA}).
\begin{lstlisting}
> vecNA <- c(-3, 2, 0, NA, -7, 5)       # Vektor mit fehlendem Wert
> (ok   <- vecNA > 0)                   # prüfe auf Werte größer 0
[1] FALSE TRUE FALSE NA FALSE TRUE
\end{lstlisting}

Enthält ein Indexvektor einen fehlenden Wert, erzeugt er beim Indizieren eines anderen Vektors an dieser Stelle ebenfalls ein \lstinline!NA! in der Ausgabe (Abschn.\ \ref{sec:vecSel}). Dies führt dazu, dass sich der Indexvektor nicht mehr dazu eignet, ausschließlich die Werte auszugeben, die eine bestimmte Bedingung erfüllen. Fehlende Werte im logischen Indexvektor können mit \lstinline!is.na()! (Abschn.\ \ref{sec:isna}) identifiziert und dann logisch ausgeschlossen werden.
\begin{lstlisting}
> vecNA[ok]                             # Auswahl mit ok erzeugt NA
[1] 2 NA 5

> vecNA[ok & !is.na(ok)])               # entferne NA im Indexvektor
[1] 2 5
\end{lstlisting}

\index{Vektor!Indexvektor!numerisch}
Logische Indizes in numerische Indizes wandelt die Funktion \lstinline!which(<<Vektor>>)!\index[func]{which()@\lstinline{which()}|textbf} um. Sie gibt also die Positionen der \lstinline!TRUE! Werte zurück.\footnote{Umgekehrt lassen sich auch die in \lstinline!<<Indexvektor>>! gespeicherten numerischen Indizes für \lstinline!<<Vektor>>! in logische verwandeln: \lstinline!seq(along=<<Vektor>>) \%in\% <<Indexvektor>>! (Abschn.\ \ref{sec:setOps}, \ref{sec:seq}).}
\begin{lstlisting}
> (numIdx <- which(ok))          # numerische Indizes der TRUE Werte
[1] 2 6
\end{lstlisting}

Numerische Indizes werden selten wirklich benötigt. Zu vermeiden sind sie immer dann, wenn Werte explizit ausgeschlossen werden sollen. Mit dem Vektor \lstinline!x! und einem logischen Indexvektor \lstinline!idx! kann anders als \lstinline|x[!idx]| die Variante \lstinline!x[-which(idx)]! unerwünschte Ergebnisse haben: Sind in \lstinline!idx! keine \lstinline!TRUE! Werte vorhanden, werden nicht alle Werte von \lstinline!x! ausgegeben, sondern gar keiner, weil dies dann gleichbedeutend zu \lstinline!x[integer(0)]! ist.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mengen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Mengen}
Werden Vektoren als Wertemengen im mathematischen Sinn betrachtet, ist zu beachten, dass die Elemente einer Menge nicht geordnet sind und mehrfach vorkommende Elemente wie ein einzelnes behandelt werden, so ist z.\,B.\ die Menge $\left\{1, 1, 2, 2\right\}$ gleich der Menge $\left\{2, 1\right\}$.\footnote{Das Paket \lstinline!sets!\index[pack]{sets@\lstinline{sets}} \cite{Meyer2009a} stellt eine eigene Klasse zur Repräsentation von Mengen zur Verfügung und implementiert auch einige hier nicht behandelte Mengenoperationen -- etwa das Bilden der Potenzmenge.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Doppelt auftretende Werte finden}
\label{sec:unique}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!doppelte Werte}
\lstinline!duplicated(<<Vektor>>)!\index[func]{duplicated()@\lstinline{duplicated()}} gibt für jedes Element eines Vektors an, ob der Wert bereits an einer früheren Stelle des Vektors aufgetaucht ist. Mit dem Argument \lstinline!fromLast=TRUE! beginnt die Suche nach wiederholt auftretenden Werten am Ende des Vektors.
\begin{lstlisting}
> x <- c(1, 2, 3, 1, 4, 5)
> duplicated(x)
[1] FALSE FALSE FALSE TRUE FALSE FALSE

> duplicated(x, fromLast=TRUE)            # umgekehrte Suchrichtung
[1] TRUE FALSE FALSE FALSE FALSE FALSE
\end{lstlisting}

Durch die Kombination beider Suchrichtungen lassen sich alle Duplikate identifizieren, insbesondere also auch das erste Auftreten eines mehrfach vorhandenen Wertes -- so umgesetzt in \index[func]{AllDuplicated()@\lstinline{AllDuplicated()}} \lstinline!AllDuplicated()! aus dem Paket\index[pack]{DescTools@\lstinline{DescTools}|textbf} \lstinline!DescTools! \cite{Signorell2014}.
\begin{lstlisting}
# markiere alle Stellen, an denen die 1 auftritt
> duplicated(x) | duplicated(x, fromLast=TRUE)
[1] TRUE FALSE FALSE TRUE FALSE FALSE
\end{lstlisting}

\lstinline!unique(<<Vektor>>)!\index[func]{unique()@\lstinline{unique()}} nennt alle voneinander verschiedenen Werte eines Vektors, mehrfach vorkommende Werte werden also nur einmal aufgeführt. Die Funktion eignet sich in Kombination mit \lstinline!length()! zum Zählen der tatsächlich vorkommenden unterschiedlichen Werte einer Variable.
\begin{lstlisting}
> unique(c(1, 1, 1, 3, 3, 4, 4))
[1] 1  3  4

> length(unique(c("A", "B", "C", "C", "B", "B", "A", "C", "C", "A")))
[1] 3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mengenoperationen}
\label{sec:setOps}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Mengen}
\lstinline!union(x=<<Vektor1>>, y=<<Vektor2>>)!\index[func]{union()@\lstinline{union()}} bildet die Vereinigungsmenge $x \cup y$. Das Ergebnis sind die Werte, die Element mindestens einer der beiden Mengen sind, wobei duplizierte Werte gelöscht werden. Wird das Ergebnis als Menge betrachtet, spielt es keine Rolle, in welcher Reihenfolge \lstinline!x! und \lstinline!y! genannt werden.
\begin{lstlisting}
> x <- c(2, 1, 3, 2, 1)
> y <- c(5, 3, 1, 3, 4, 4)
> union(x, y)
[1] 2 1 3 5 4

> union(y, x)
[1] 5 3 1 4 2
\end{lstlisting}

Die Schnittmenge $x \cap y$ zweier Mengen erzeugt\index[func]{intersect()@\lstinline{intersect()}} \lstinline!intersect(x=<<Vektor1>>, y=<<Vektor2>>)!. Das Ergebnis sind die Werte, die sowohl Element von \lstinline!x! als auch Element von \lstinline!y! sind, wobei duplizierte Werte gelöscht werden. Auch hier ist die Reihenfolge von \lstinline!x! und \lstinline!y! unerheblich, wenn das Ergebnis als Menge betrachtet wird.
\begin{lstlisting}
> intersect(x, y)
[1] 1 3

> intersect(y, x)
[1] 3 1
\end{lstlisting}

Mit\index[func]{setequal()@\lstinline{setequal()}} \lstinline!setequal(x=<<Vektor1>>, y=<<Vektor2>>)! lässt sich prüfen, ob als Mengen betrachtete Vektoren identisch sind.
\begin{lstlisting}
> setequal(c(1, 1, 2, 2), c(2, 1))
[1] TRUE
\end{lstlisting}

\lstinline!setdiff(x=<<Vektor1>>, y=<<Vektor2>>)!\index[func]{setdiff()@\lstinline{setdiff()}} liefert als Ergebnis all jene Elemente von \lstinline!x!, die nicht Element von \lstinline!y! sind. Im Unterschied zu den oben behandelten Mengenoperationen ist die Reihenfolge von \lstinline!x! und \lstinline!y! hier bedeutsam, auch wenn das Ergebnis als Menge betrachtet wird. Die symmetrische Differenz von \lstinline!x! und \lstinline!y! erhält man durch \lstinline!union(setdiff(x, y), setdiff(y, x))!.
\begin{lstlisting}
> setdiff(x, y)
[1] 2

> setdiff(y, x)
[1] 5 4
\end{lstlisting}

Soll jedes Element eines Vektors daraufhin geprüft werden, ob es Element einer Menge ist, kann\index[func]{is.element()@\lstinline{is.element()}} \lstinline!is.element(el=<<Vektor>>, set=<<Menge>>)! genutzt werden. Unter \lstinline!el! ist der Vektor mit den zu prüfenden Elementen einzutragen und unter \lstinline!set! die durch einen Vektor definierte Menge. Als Ergebnis wird ein logischer Vektor ausgegeben, der für jedes Element von \lstinline!el! angibt, ob es in \lstinline!set! enthalten ist. Die Kurzform in Operator-Schreibweise lautet\index[func]{\%in\%@\texttt{\%in\%}|textbf} \lstinline!<<Vektor>> %in% <<Menge>>!.
\begin{lstlisting}
> is.element(c(29, 23, 30, 17, 30, 10), c(30, 23))
[1] FALSE TRUE TRUE FALSE TRUE FALSE

> c("A", "Z", "B") %in% c("A", "B", "C", "D", "E")
[1] TRUE FALSE TRUE
\end{lstlisting}

Durch \lstinline!all(x %in% y)! lässt sich prüfen, ob \lstinline!x! eine Teilmenge von \lstinline!y! darstellt, ob also jedes Element von \lstinline!x! auch Element von \lstinline!y! ist. Dabei ist \lstinline!x! eine echte Teilmenge von \lstinline!y!, wenn sowohl \lstinline!all(x %in% y)! gleich \lstinline!TRUE! als auch \lstinline!all(y %in% x)! gleich \lstinline!FALSE! ist.
\begin{lstlisting}
> A <- c(4, 5, 6)
> B <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
> (AinB <- all(A %in% B))           # A Teilmenge von B?
[1] TRUE

> (BinA <- all(B %in% A))           # B Teilmenge von A?
[1] FALSE

> AinB & !BinA                      # A echte Teilmenge von B?
[1] TRUE
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kombinatorik}
\label{sec:combinatorics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Kombinatorik}
Aus dem Bereich der Kombinatorik sind bei der Datenauswertung drei Themen von Bedeutung: Zunächst ist dies die Bildung von Teilmengen aus Elementen einer Grundmenge. Dabei ist die Reihenfolge der Elemente innerhalb einer Teilmenge meist nicht bedeutsam, d.\,h.\ es handelt sich um eine \emph{Kombination}. Werden alle Elemente einer Grundmenge ohne Zurücklegen unter Beachtung der Reihenfolge gezogen, handelt es sich um eine vollständige\index{Permutation|see{Kombinatorik}} \emph{Permutation}. Schließlich kann die Zusammenstellung von Elementen aus verschiedenen Grundmengen notwendig sein, wobei jeweils ein Element aus jeder Grundmenge beteiligt sein soll.

Die Kombination entspricht dem Ziehen aus einer Grundmenge ohne Zurücklegen sowie ohne Berücksichtigung der Reihenfolge. Oft wird die Anzahl der Elemente der Grundmenge mit $n$, die Anzahl der gezogenen Elemente mit $k$ und die Kombination deshalb mit $k$-Kombination bezeichnet. Es gibt ${n \choose k} = \frac{n!}{k! (n-k)!}$ viele $k$-Kombinationen. Da eine $k$-Kombinationen die Anzahl der Möglichkeiten darstellt, aus einer Menge mit $n$ Elementen $k$ auszuwählen, spricht man im Englischen beim Binomialkoeffizienten ${n \choose k}$ von {\quotedblbase}$n$ choose $k${\textquotedblleft}, woraus sich der Name der \lstinline!choose(n=<<Zahl>>, k=<<Zahl>>)!\index[func]{choose()@\lstinline{choose()}} Funktion ableitet, die ${n \choose k}$ ermittelt. Die Fakultät einer Zahl wird mit \lstinline!factorial(<<Zahl>>)! berechnet (Abschn.\ \ref{sec:sum}).
\begin{lstlisting}
> myN <- 5
> myK <- 4
> choose(myN, myK)
[1] 5

> factorial(myN) / (factorial(myK)*factorial(myN-myK))    # Kontrolle
[1] 5
\end{lstlisting}

Möchte man alle $k$-Kombinationen einer gegebenen Grundmenge \lstinline!x! auch explizit anzeigen lassen, kann dies mit\index[func]{combn()@\lstinline{combn()}} \lstinline!combn()! geschehen.
\begin{lstlisting}
> combn(x=<<Vektor>>, m=<<Zahl>>, simplify=TRUE, FUN=<<Funktion>>, ...)
\end{lstlisting}

Die Zahl \lstinline!m! entspricht dabei dem $k$ der bisherigen Terminologie. Mit \lstinline!simplify=TRUE! erfolgt die Ausgabe auf möglichst einfache Weise, d.\,h.\ nicht als Liste (Abschn.\ \ref{sec:list}). Stattdessen wird hier eine Matrix ausgegeben, die in jeder Spalte eine der $k$-Kombinationen enthält (Abschn.\ \ref{sec:matrix}).
\begin{lstlisting}
> combn(c("a", "b", "c", "d", "e"), myK)
     [,1]  [,2]  [,3]  [,4]  [,5]
[1,]  "a"   "a"   "a"   "a"   "b"
[2,]  "b"   "b"   "b"   "c"   "c"
[3,]  "c"   "c"   "d"   "d"   "d"
[4,]  "d"   "e"   "e"   "e"   "e"
\end{lstlisting}

\lstinline!combn()! lässt sich darüber hinaus anwenden, um in einem Arbeitsschritt eine frei wählbare Funktion auf jede gebildete $k$-Kombination anzuwenden. Das Argument \lstinline!FUN! erwartet hierfür eine Funktion, die einen Kennwert jedes sich als Kombination ergebenden Vektors bestimmt. Benötigt \lstinline!FUN! ihrerseits weitere Argumente, so können diese unter \lstinline!...! durch Komma getrennt an \lstinline!combn()! übergeben werden.
\begin{lstlisting}
> combn(c(1, 2, 3, 4), 3)           # alle 3-Kombinationen
     [,1]  [,2]  [,3]  [,4]
[1,]    1     1     1     2
[2,]    2     2     3     3
[3,]    3     4     4     4

# jeweilige Summe jeder 3-Kombination
> combn(c(1, 2, 3, 4), 3, FUN=sum)
[1] 6 7 8 9

# gewichtetes Mittel jeder 3-Kombination mit Argument w für Gewichte
> combn(c(1, 2, 3, 4), 3, weighted.mean, w=c(0.5, 0.2, 0.3))
[1] 1.8 2.1 2.3 2.8
\end{lstlisting}

\lstinline!Permn(<<Vektor>>)!\index[func]{Permn()@\lstinline{Permn()}} aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} stellt alle $n!$ Permutationen des übergebenen Vektors der Länge $n$ als Zeilen einer Matrix zusammen (Abschn.\ \ref{sec:matrix}). Für eine einzelne zufällige Permutation Abschn.\ \ref{sec:sample}.
\begin{lstlisting}
> library(DescTools)                # für Permn()
> Permn(1:3)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    3    2
[3,]    3    1    2
[4,]    3    2    1
[5,]    2    3    1
[6,]    2    1    3
\end{lstlisting}

\lstinline!expand.grid(<<Vektor1>>, <<Vektor2>>, ...)!\index[func]{expand.grid()@\lstinline{expand.grid()}} bildet das kartesische Produkt der übergebenen Grundmengen. Dies sind alle Kombinationen der Elemente der Grundmengen, wobei jeweils ein Element aus jeder Grundmenge stammt und die Reihenfolge nicht berücksichtigt wird. Dies entspricht der Situation, dass aus den Stufen mehrerer Faktoren alle Kombinationen von Faktorstufen gebildet werden. Das Ergebnis von \lstinline!expand.grid()! ist ein Datensatz (Abschn.\ \ref{sec:dataframe}), bei dem jede Kombination in einer Zeile steht. Die zuerst genannte Variable variiert dabei am schnellsten über die Zeilen, die anderen entsprechend ihrer Position im Funktionsaufruf langsamer.
\begin{lstlisting}
> IV1 <- c("control", "treatment")
> IV2 <- c("f", "m")
> IV3 <- c(1, 2)
> expand.grid(IV1, IV2, IV3)
         Var1  Var2  Var3
1     control     f     1
2   treatment     f     1
3     control     m     1
4   treatment     m     1
5     control     f     2
6   treatment     f     2
7     control     m     2
8   treatment     m     2
\end{lstlisting}

Variablen mit Zeichenketten werden von \lstinline!expand.grid()! automatisch in Gruppierungsfaktoren (Klasse \lstinline!factor!) konvertiert. Sollen solche Variablen als \lstinline!character! Vektoren gespeichert werden, ist das Argument \lstinline!stringsAsFactors=FALSE! zu setzen. Sollen auch numerische Werte zu Faktorstufen im versuchsplanerischen Sinn werden (was hier für die dritte Spalte nicht der Fall ist), muss die zugehörige Variable vorher in ein Objekt der Klasse \lstinline!factor! umgewandelt werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Systematische und zufällige Wertefolgen erzeugen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ein häufig auftretender Arbeitsschritt in R ist die Erstellung von Zahlenfolgen nach vorgegebenen Gesetzmäßigkeiten, wie etwa sequentielle Abfolgen von Zahlen oder Wiederholungen bestimmter Wertemuster.

\index{Zufallszahlen}
Aber auch Zufallszahlen und zufällige Reihenfolgen sind ein unverzichtbares Hilfsmittel der Datenauswertung, wobei ihnen insbesondere in der Planung von Analysen anhand simulierter Daten eine große Bedeutung zukommt.\footnote{Wenn hier und im folgenden von Zufallszahlen die Rede ist, sind immer \emph{Pseudozufallszahlen} gemeint. Diese kommen nicht im eigentlichen Sinn zufällig zustande, sind aber von tatsächlich zufälligen Zahlenfolgen fast nicht zu unterscheiden. Pseudozufallszahlen hängen deterministisch vom Zustand des die Zahlen produzierenden\index{Zufallszahlen} Generators ab. Wird sein Zustand über\index[func]{set.seed()@\lstinline{set.seed()}} \lstinline!set.seed(<<Zahl>>)! festgelegt, kommt bei gleicher \lstinline!<<Zahl>>! bei späteren Aufrufen von Zufallsfunktionen immer dieselbe Folge von Werten zustande. Dies gewährleistet die Reproduzierbarkeit von Auswertungsschritten bei Simulationen. Nach welcher Methode Zufallszahlen generiert werden, ist konfigurierbar, s.\ \lstinline!?RNGkind!\index[func]{RNGkind()@\lstinline{RNGkind()}}.} Zufällige Datensätze können unter Einhaltung vorgegebener Wertebereiche und anderer Randbedingungen erstellt werden. So können sie empirische Gegebenheiten realistisch widerspiegeln und statistische Voraussetzungen der eingesetzten Verfahren berücksichtigen. Aber auch bei der zufälligen Auswahl von Teilstichproben eines Datensatzes oder beim Erstellen zufälliger Reihenfolgen zur Zuordnung von Beobachtungsobjekten auf experimentelle Bedingungen kommen Zufallszahlen zum Einsatz.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Numerische Sequenzen erstellen}
\label{sec:seq}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zahlen!Zahlenfolgen erstellen}
Zahlenfolgen mit Einerschritten, etwa für eine fortlaufende Numerierung, können mit Hilfe des Operators \lstinline!<<Startwert>>:<<Endwert>>!\index[func]{:@\lstinline{:}} erzeugt werden -- in aufsteigender wie auch in absteigender Reihenfolge.
\begin{lstlisting}
> 20:26
[1] 20 21 22 23 24 25 26

> 26:20
[1] 26 25 24 23 22 21 20
\end{lstlisting}

Bei Zahlenfolgen im negativen Bereich sollten Klammern Verwendung finden, um nicht versehentlich eine nicht gemeinte Sequenz zu produzieren.
\begin{lstlisting}
> -4:2          # negatives Vorzeichen bezieht sich nur auf die 4
[1] -4 -3 -2 -1 0 1 2

> -(4:2)        # negatives Vorzeichen bezieht sich auf Sequenz 4:2
[1] -4 -3 -2
\end{lstlisting}

\index[func]{seq()@\lstinline{seq()}}
Zahlenfolgen mit beliebiger Schrittweite lassen sich mit \lstinline!seq()! erzeugen.
\begin{lstlisting}
> seq(from=<<Zahl>>, to=<<Zahl>>, by=<<Schrittweite>>, length.out=<<Länge>>)
\end{lstlisting}

Dabei können Start- (\lstinline!from!) und Endwert (\lstinline!to!) des durch die Sequenz abzudeckenden Intervalls ebenso gewählt werden wie die gewünschte Schrittweite (\lstinline!by!) bzw.\ stattdessen die gewünschte Anzahl der Elemente der Zahlenfolge (\lstinline!length.out!). Die Sequenz endet vor \lstinline!to!, wenn die Schrittweite kein ganzzahliges Vielfaches der Differenz von Start- und Endwert ist.
\begin{lstlisting}
> seq(from=2, to=12, by=2)
[1] 2 4 6 8 10 12

> seq(from=2, to=11, by=2)          # Endpunkt 11 wird nicht erreicht
[1] 2 4 6 8 10

> seq(from=0, to=-1, length.out=5)
[1] 0.00 -0.25 -0.50 -0.75 -1.00
\end{lstlisting}

Eine Möglichkeit zum Erstellen einer bei $1$ beginnenden Sequenz in Einerschritten, die genauso lang ist wie ein bereits vorhandener Vektor, besteht mit \lstinline!seq(along=<<Vektor>>)!. Dabei muss \lstinline!along=<<Vektor>>! das einzige Argument von \lstinline!seq()! sein. Dies ist die bevorzugte Art, um für einen vorhandenen Vektor den passenden Vektor seiner Indizes zu erstellen. Vermieden werden sollte dagegen die \lstinline!1:length(<<Vektor>>)! Sequenz, deren Behandlung von Vektoren der Länge $0$ nicht sinnvoll ist.
\begin{lstlisting}
> age <- c(18, 20, 30, 24, 23, 21)
> seq(along=age)
[1] 1 2 3 4 5 6

> vec <- numeric(0)         # leeren Vektor (Länge 0) erzeugen
> 1:length(vec)             # hier unerwünschtes Ergebnis: Sequenz 1:0
[1] 1 0

> seq(along=vec)            # sinnvolleres Ergebnis: leerer Vektor
[1] integer(0)
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Wertefolgen wiederholen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!wiederholen}
\index[func]{rep()@\lstinline{rep()}}
Eine andere Art von Wertefolgen kann mit der \lstinline!rep()! Funktion (repeat) erzeugt werden, die Elemente wiederholt ausgibt.
\begin{lstlisting}
> rep(x=<<Vektor>>, times=<<Anzahl>>, each=<<Anzahl>>)
\end{lstlisting}

Für \lstinline!x! ist ein Vektor einzutragen, der auf zwei verschiedene Arten wiederholt werden kann. Mit dem Argument \lstinline!times! wird er als Ganzes so oft aneinander gehängt wie angegeben.
\begin{lstlisting}
> rep(1:3, times=5)
[1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
\end{lstlisting}

Wird für das Argument \lstinline!times! ein Vektor angegeben, so muss dieser dieselbe Länge wie \lstinline!x! besitzen -- hier wird ein kürzerer Vektor durch R nicht selbsttätig zyklisch wiederholt (Abschn.\ \ref{sec:recycling}). Jedes Element des Vektors \lstinline!times! gibt an, wie häufig das an gleicher Position stehende Element von \lstinline!x! wiederholt werden soll, ehe das nächste Element von \lstinline!x! wiederholt und angehängt wird.
\begin{lstlisting}
> rep(c("A", "B", "C"), times=c(2, 3, 4))
[1] "A" "A" "B" "B" "B" "C" "C" "C" "C"
\end{lstlisting}

Wird das Argument \lstinline!each! verwendet, wird jedes Element von \lstinline!x! einzeln mit der gewünschten Häufigkeit wiederholt, bevor das nächste Element von \lstinline!x! einzeln wiederholt und angehängt wird.
\begin{lstlisting}
> rep(age, each=2)
[1] 18 18 20 20 30 30 24 24 23 23 21 21
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zufällig aus einer Urne ziehen}
\label{sec:sample}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zufallszahlen}
\index[func]{sample()@\lstinline{sample()}}
Die Funktion \lstinline!sample()! erstellt einen aus zufälligen Werten bestehenden Vektor, indem sie das Ziehen aus einer Urne simuliert.
\begin{lstlisting}
> sample(x=<<Vektor>>, size=<<Anzahl>>, replace=FALSE, prob=NULL)
\end{lstlisting}

Für \lstinline!x! ist ein Vektor zu nennen, der die Elemente der Urne festlegt, aus der gezogen wird. Dies sind die Werte, aus denen sich die Zufallsfolge zusammensetzen soll. Es können Vektoren vom Datentyp \lstinline!numeric! (etwa \lstinline!1:50!), \lstinline!character! (\lstinline!c("Kopf", "Zahl")!) oder auch \lstinline!logical! (\lstinline!c(TRUE, FALSE)!) verwendet werden. Unter \lstinline!size! ist die gewünschte Anzahl der zu ziehenden Elemente einzutragen. Mit dem Argument \lstinline!replace! wird die Art des Ziehens festgelegt: Auf \lstinline!FALSE! gesetzt (Voreinstellung) wird ohne, andernfalls (\lstinline!TRUE!) mit Zurücklegen gezogen. Natürlich kann ohne Zurücklegen aus einem Vektor der Länge $n$ nicht häufiger als $n$ mal gezogen werden. Wenn \lstinline!replace=FALSE! und dennoch \lstinline!size! größer als \lstinline!length(x)! ist, erzeugt R deswegen eine Fehlermeldung. Für den Fall, dass nicht alle Elemente der Urne dieselbe Auftretenswahrscheinlichkeit besitzen sollen, existiert das Argument \lstinline!prob!. Es benötigt einen Vektor derselben Länge wie \lstinline!x!, dessen Elemente die Auftretenswahrscheinlichkeit für jedes Element von \lstinline!x! bestimmen.
\begin{lstlisting}
> sample(1:6, size=20, replace=TRUE)
[1] 4 1 2 5 6 5 3 6 6 5 1 6 1 5 1 4 5 4 4 2

> sample(c("rot", "grün", "blau"), size=8, replace=TRUE)
[1] "grün" "blau" "grün" "rot" "rot" "blau" "grün" "blau"
\end{lstlisting}

Für \lstinline!sample()! existieren zwei Kurzformen, auf die jedoch aufgrund der Gefahr von Verwechslungen besser verzichtet werden sollte: \lstinline!sample(<<Vektor>>)! ist gleichbedeutend mit \lstinline!sample(<<Vektor>>, size=length(<<Vektor>>), replace=FALSE)!, erstellt also eine zufällige Permutation der Elemente von \lstinline!<<Vektor>>! (Abschn.\ \ref{sec:combinatorics}). Darauf aufbauend steht \lstinline!sample(<<Zahl>>)! kurz für \lstinline!sample(1:<<Zahl>>)!, also für \lstinline!sample(1:<<Zahl>>, size=<<Zahl>>, replace=FALSE)!.

Wenn für \lstinline!sample(<<Vektor>>)! ein Objektname übergeben wird, steht oft vor der Ausführung nicht fest, wie viele Elemente er beinhalten wird. Enthält \lstinline!<<Vektor>>! z.\,B.\ durch die Auswahl einer Teilmenge unvorhergesehen als einziges Element eine Zahl, wird die Urne durch Elemente definiert, die womöglich nicht im ursprünglichen Vektor vorhanden waren.
\begin{lstlisting}
> x <- c(2, 4, 6, 8)
> sample(x[(x %% 4) == 0])  # äquivalent zu sample(c(4, 8))
[1] 8 4

# Urne mit Elementen, die nicht aus x stammen
> sample(x[(x %% 8) == 0])  # äquivalent zu sample(8), d.h. sample(1:8)
[1] 2 1 7 5 4 8 6 3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zufallszahlen aus bestimmten Verteilungen erzeugen}
\label{sec:randNum}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zufallszahlen}
Abgesehen vom zufälligen Ziehen aus einer vorgegebenen Menge endlich vieler Werte lassen sich auch Zufallszahlen mit bestimmten Eigenschaften generieren. Dazu können mit Funktionen, deren Name nach dem Muster \lstinline!r<<Funktionsfamilie>>! aufgebaut ist, Realisierungen von Zufallsvariablen mit verschiedenen Verteilungen erstellt werden (Abschn.\ \ref{sec:randVarFuncs}). Diese Möglichkeit ist insbesondere für die Simulation empirischer Daten nützlich.
\index[func]{runif()@\lstinline{runif()}}
\index[func]{rbinom()@\lstinline{rbinom()}}
\index[func]{rnorm()@\lstinline{rnorm()}}
\index[func]{rchisq()@\lstinline{rchisq()}}
\index[func]{rt()@\lstinline{rt()}}
\index[func]{rf()@\lstinline{rf()}}
\index{Gleichverteilung|see{Verteilung}}
\index{Binomialverteilung|see{Verteilung}}
\index{Normalverteilung|see{Verteilung}}
\index{t-Verteilung@$t$-Verteilung|see{Verteilung}}
\index{Chi2-Verteilung@$\chi^{2}$-Verteilung|see{Verteilung}}
\index{F-Verteilung@$F$-Verteilung|see{Verteilung}}
\index{Verteilung!Gleichverteilung}
\index{Verteilung!Binomialverteilung}
\index{Verteilung!Normalverteilung}
\index{Verteilung!$t$-Verteilung}
\index{Verteilung!$\chi^{2}$-Verteilung}
\index{Verteilung!$F$-Verteilung}
\begin{lstlisting}
>  runif(n=<<Anzahl>>, min=0, max=1)                # Gleichverteilung
> rbinom(n=<<Anzahl>>, size, prob)                  # Binomialverteilung
>  rnorm(n=<<Anzahl>>, mean=0, sd=1)                # Normalverteilung
> rchisq(n=<<Anzahl>>, df,       ncp=0)             # chi^2-Verteilung
>     rt(n=<<Anzahl>>, df,       ncp=0)             # t-Verteilung
>     rf(n=<<Anzahl>>, df1, df2, ncp=0)             # F-Verteilung
\end{lstlisting}

Als erstes Argument \lstinline!n! ist immer die gewünschte Anzahl an Zufallszahlen anzugeben. Bei \lstinline!runif()! definiert \lstinline!min! die untere und \lstinline!max! die obere Grenze des Zahlenbereichs, aus dem gezogen wird. Beide Argumente akzeptieren auch Vektoren der Länge $n$, die für jede einzelne Zufallszahl den zulässigen Wertebereich angeben.

Bei \lstinline!rbinom()! entsteht jede der $n$ Zufallszahlen als Anzahl der Treffer in einer simulierten Serie von gleichen Bernoulli-Experimenten, die ihrerseits durch die Argumente \lstinline!size! und \lstinline!prob! charakterisiert ist. \lstinline!size! gibt an, wie häufig ein einzelnes Bernoulli-Experiment wiederholt werden soll, \lstinline!prob! legt die Trefferwahrscheinlichkeit in jedem dieser Experimente fest. Sowohl \lstinline!size! als auch \lstinline!prob! können Vektoren der Länge $n$ sein, die dann die Bernoulli-Experimente charakterisieren, deren Simulation zu jeweils einer Zufallszahl führt.

Bei \lstinline!rnorm()! sind der Erwartungswert \lstinline!mean! und die theoretische Streuung \lstinline!sd! der normalverteilten Variable anzugeben, die simuliert werden soll.\footnote{Der die Breite (Dispersion) einer Normalverteilung charakterisierende Parameter ist hier die Streuung $\sigma$, in der Literatur dagegen häufig die Varianz $\sigma^{2}$.} Auch diese Argumente können Vektoren der Länge $n$ sein und für jede Zufallszahl andere Parameter vorgeben.

Sind Verteilungen über Freiheitsgrade und Nonzentralitätsparameter charakterisiert, werden diese mit den Argumenten \lstinline!df! (degrees of freedom) respektive \lstinline!ncp! (non-centrality parameter) ggf.\ in Form von Vektoren übergeben.
\begin{lstlisting}
> runif(5, min=1, max=6)
[1] 4.411716 3.893652 2.412720 5.676668 2.446302

> rbinom(20, size=5, prob=0.3)
[1] 2 0 3 0 2 2 1 0 1 0 2 1 1 4 2 2 1 1 3 3

> rnorm(6, mean=100, sd=15)
[1] 101.13170 102.25592 88.31622 101.22469 93.12013 100.52888
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Daten transformieren}
\label{sec:varTransform}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Häufig sind für spätere Auswertungen neue Variablen auf Basis der erhobenen Daten zu bilden. Im Rahmen solcher Datentransformationen können etwa Werte sortiert, umskaliert, ersetzt, ausgewählt, oder verschiedene Variablen zu einer neuen verrechnet werden. Genauso ist es möglich, kontinuierliche Variablen in Kategorien einzuteilen, oder in Rangwerte umzuwandeln.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Werte sortieren}
\label{sec:revSortOrder}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Reihenfolge}
Um die Reihenfolge eines Vektors umzukehren, kann \lstinline!rev(<<Vektor>>)!\index[func]{rev()@\lstinline{rev()}} (reverse) benutzt werden.
\begin{lstlisting}
> vec <- c(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
> rev(vec)
[1] 20 19 18 17 16 15 14 13 12 11 10
\end{lstlisting}

\index{Vektor!sortieren}
\index{sortieren|see{Datensatz, Matrix, Vektor}}
Die Elemente eines Vektors lassen sich auch entsprechend ihrer Reihenfolge sortieren, die wiederum vom Datentyp des Vektors abhängt: Bei numerischen Vektoren bestimmt die Größe der gespeicherten Zahlen, bei Vektoren aus Zeichenketten die alphabetische Reihenfolge der Elemente die Ausgabe (Abschn.\ \ref{sec:isTRUE}, Fußnote \ref{ftn:locale}). Zum Sortieren stehen die Funktionen \lstinline!sort()!\index[func]{sort()@\lstinline{sort()}} und \lstinline!order()!\index[func]{order()@\lstinline{order()}|textbf} zur Verfügung.
\begin{lstlisting}
> sort(<<Vektor>>,  decreasing=FALSE)
> order(<<Vektor>>, decreasing=FALSE)
\end{lstlisting}

\lstinline!sort()! gibt eine sortierte Version des Vektor aus, ohne den übergebenen Vektor selbst zu verändern. Dagegen ist das Ergebnis von \lstinline!order()! ein Indexvektor, der die Indizes des zu ordnenden Vektors in der Reihenfolge seiner Elemente enthält. Im Gegensatz zu \lstinline!sort()! gibt \lstinline!order()! also nicht schon die sortierten Datenwerte, sondern nur die zugehörigen Indizes aus, die anschließend zum Indizieren des Vektors verwendet werden können. Für einen Vektor \lstinline!x! ist daher \lstinline!sort(x)! äquivalent zu \lstinline!x[order(x)]!.\footnote{Sofern keine fehlenden Werte \lstinline!NA! im Vektor vorhanden sind (Abschn.\ \ref{sec:sortNA}).} Der Vorteil von \lstinline!order()! erweist sich beim Umgang mit Matrizen und Datensätzen (Abschn.\ \ref{sec:sortMat}). Die Sortierreihenfolge wird über das Argument \lstinline!decreasing! kontrolliert. In der Voreinstellung \lstinline!FALSE! wird aufsteigend sortiert. Mit \lstinline!decreasing=TRUE! ist die Reihenfolge absteigend.
\begin{lstlisting}
> vec <- c(10, 12, 1, 12, 7, 16, 6, 19, 10, 19)
> sort(vec)
[1] 1 6 7 10 10 12 12 16 19 19

> (idxDec <- order(vec, decreasing=TRUE))
[1] 8 10 6 2 4 1 9 5 7 3

> vec[idxDec]
[1] 19 19 16 12 12 10 10 7 6 1
\end{lstlisting}

Wenn Vektoren vom Datentyp \lstinline!character! sortiert werden, so geschieht dies in alphabetischer Reihenfolge. Auch als Zeichenkette gespeicherte Zahlen werden hierbei alphabetisch sortiert, d.\,h.\ die Zeichenkette \lstinline!"10"! käme vor \lstinline!"4"!.
\begin{lstlisting}
> sort(c("D", "E", "10", "A", "F", "E", "D", "4", "E", "A"))
[1] "10" "4" "A" "A" "D" "D" "E" "E" "E" "F"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Werte in zufällige Reihenfolge bringen}
\label{sec:randOrder}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Reihenfolge}
\index{zufällige Reihenfolge}
Zufällige Reihenfolgen können mit Kombinationen von \lstinline!rep()! und \lstinline!sample()! erstellt werden und entsprechen der zufälligen Permutation einer Menge (Abschn.\ \ref{sec:combinatorics}). Sie sind z.\,B.\ bei der randomisierten Zuteilung von Beobachtungsobjekten zu Gruppen, beim Randomisieren der Reihenfolge von Bedingungen oder beim Ziehen einer Zufallsstichprobe aus einer Datenmenge nützlich.
\begin{lstlisting}
# randomisiere Reihenfolge von 5 Farben
> myColors  <- c("red", "green", "blue", "yellow", "black")
> (randCols <- sample(myColors, length(myColors), replace=FALSE))
[1] "yellow" "green" "red" "blue" "black"

# teile 12 Personen auf 3 unterschiedlich große Gruppen auf
> P   <- 3                                    # Anzahl Gruppen
> Nj  <- c(4, 3, 5)                           # Gruppengrößen
> (IV <- rep(1:P, Nj))                        # Gruppenzugehörigkeiten
[1] 1 1 1 1 2 2 2 3 3 3 3 3

# zufällige Permutation
> (IVrand <- sample(IV, length(IV), replace=FALSE))
[1] 2 1 1 3 3 1 3 1 2 2 3 3
\end{lstlisting}

Um allgemein $n$ Beobachtungsobjekte auf $p$ möglichst ähnlich große Gruppen aufzuteilen, können zunächst mit \lstinline!sample()! die Indizes $1, \ldots, n$ permutiert werden, um dann mit \lstinline!%%! den Rest der ganzzahligen Division jedes Index mit $p$ zu bilden, der die $p$ Werte $0, \ldots, p-1$ annehmen kann.
\begin{lstlisting}
> P <- 3
> N <- 20
> (sample(1:N, N, replace=FALSE) %% P) + 1
[1] 2 2 2 3 3 3 1 3 1 2 3 2 1 1 2 3 2 1 3 1
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Teilmengen von Daten auswählen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!auswählen}
\index{Daten!Zufallsauswahl}
\index{Zufallsauswahl|see{Daten}}
\index{Auswahl|see{Daten}}
Soll aus einer vorhandenen Datenmenge eine Teilstichprobe gezogen werden, hängt das Vorgehen von der genau intendierten Art der Ziehung ab. Grundsätzlich können zur Auswahl von Werten logische wie numerische Indexvektoren zum Einsatz kommen, die sich systematisch oder zufällig erzeugen lassen.

Eine rein zufällige Unterauswahl eines bestimmten Umfangs ohne weitere Nebenbedingungen kann mit \lstinline!sample()! erstellt werden.\footnote{Das Paket \lstinline!car!\index[pack]{car@\lstinline{car}} bietet hierfür die Funktion \lstinline!some()!\index[func]{some()@\lstinline{some()}}, die sich auch für Matrizen (Abschn.\ \ref{sec:matrix}) oder Datensätze (Abschn.\ \ref{sec:dataframe}) eignet.} Dazu betrachtet man den Datenvektor als Urne, aus der ohne Zurücklegen die gewünschte Anzahl von Beobachtungen gezogen wird.
\begin{lstlisting}
> vec <- rep(c("rot", "grün", "blau"), 10)
> sample(vec, 5, replace=FALSE)
[1] "blau" "grün" "blau" "grün" "rot"
\end{lstlisting}

Ein anderes Ziel könnte darin bestehen, z.\,B.\ jedes zehnte Element einer Datenreihe auszugeben. Hier bietet sich \lstinline!seq()! an, um die passenden Indizes zu erzeugen.
\begin{lstlisting}
> selIdx1 <- seq(1, length(vec), by=10)
> vec[selIdx1]
[1] "rot"  "grün" "blau"
\end{lstlisting}

Soll nicht genau, sondern nur im Mittel jedes zehnte Element ausgegeben werden, eignet sich \lstinline!rbinom()! zum Erstellen eines geeigneten Indexvektors. Dazu kann der Vektor der Trefferanzahlen aus einer Serie von jeweils nur einmal durchgeführten Bernoulli-Experimenten mit Trefferwahrscheinlichkeit $\frac{1}{10}$ in einen logischen Indexvektor umgewandelt werden:
\begin{lstlisting}
> selIdx2 <- rbinom(length(vec), size=1, prob=0.1) == 1
> vec[selIdx2]
[1] "blau" "grün" "blau" "grün" "grün"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Daten umrechnen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!elementweise Berechnung}
Auf Vektoren lassen sich alle elementaren Rechenoperationen anwenden, die in Abschn.\ \ref{sec:arithmetic} für Skalare aufgeführt wurden. Vektoren können also in den meisten Rechnungen wie Einzelwerte verwendet werden, wodurch sich Variablen leicht umskalieren lassen. Die Berechnungen einer Funktion werden dafür elementweise durchgeführt: Die Funktion wird zunächst auf das erste Element des Vektors angewendet, dann auf das zweite, usw., bis zum letzten Element. Das Ergebnis ist ein Vektor, der als Elemente die Einzelergebnisse besitzt. In der Konsequenz ähnelt die Schreibweise zur Transformation von in Vektoren gespeicherten Werten in R sehr der aus mathematischen Formeln gewohnten.
\begin{lstlisting}
> age <- c(18, 20, 30, 24, 23, 21)
> age/10
[1] 1.8 2.0 3.0 2.4 2.3 2.1

> (age/2) + 5
[1] 14.0 15.0 20.0 17.0 16.5 15.5
\end{lstlisting}

Auch in Situationen, in denen mehrere Vektoren in einer Rechnung auftauchen, können diese wie Einzelwerte verwendet werden. Die Vektoren werden dann elementweise entsprechend der gewählten Rechenoperation miteinander verrechnet. Dabei wird das erste Element des ersten Vektors mit dem ersten Element des zweiten Vektors z.\,B.\ multipliziert, ebenso das zweite Element des ersten Vektors mit dem zweiten Element des zweiten Vektors, usw.
\begin{lstlisting}
> vec1 <- c(3, 4, 5, 6)
> vec2 <- c(-2, 2, -2, 2)
> vec1*vec2
[1] -6 8 -10 12

> vec3 <- c(10, 100, 1000, 10000)
> (vec1 + vec2) / vec3
[1] 1e-01 6e-02 3e-03 8e-04
\end{lstlisting}

Die Zahlen der letzten Ausgabe sind in verkürzter Exponentialschreibweise dargestellt (Abschn.\ \ref{sec:arithmetic}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Zyklische Verlängerung von Vektoren (recycling)}
\label{sec:recycling}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!zyklische Verlängerung}
\index{Vektor!recycling}
\index{recycling|see{Vektor}}
\index{zyklische Verlangerung@zyklische Verlängerung|see{Vektor}}
Die Verrechnung mehrerer Vektoren scheint aufgrund der elementweisen Zuordnung zunächst vorauszusetzen, dass die Vektoren dieselbe Länge haben. Tatsächlich ist dies nicht unbedingt notwendig, weil R in den meisten Fällen diesen Zustand ggf.\ selbsttätig herstellt. Dabei wird der kürzere Vektor intern von R zyklisch wiederholt (also sich selbst angefügt, sog.\ \emph{recycling}), bis er mindestens die Länge des längeren Vektors besitzt. Eine Warnmeldung wird in einem solchen Fall nur dann ausgegeben, wenn die Länge des längeren Vektors kein ganzzahliges Vielfaches der Länge des kürzeren Vektors ist. Dies ist gefährlich, weil meist Vektoren gleicher Länge miteinander verrechnet werden sollen und die Verwendung von Vektoren ungleicher Länge ein Hinweis auf fehlerhafte Berechnungen sein kann.
\begin{lstlisting}
> vec1 <- c(2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24)
> vec2 <- c(2, 4, 6, 8, 10)

> c(length(age), length(vec1), length(vec2))
[1] 6  12  5

> vec1*age
[1] 36 80 180 192 230 252 252 320 540 480 506 504

> vec2*age
[1] 36 80 180 192 230 42

Warning message:
Länge des längeren Objektes ist kein Vielfaches der Länge des kürzeren
Objektes in: vec2 * age
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection[\texorpdfstring{$z$}{z}-Transformation]{$\bm{z}$-Transformation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!z-transformieren@$z$-transformieren}
Durch eine $z$-Transformation wird eine quantitative Variable $X$ so normiert, dass sie den Mittelwert $\bar{x}=0$ und die Standardabweichung $s=1$ besitzt. Dies geschieht für jeden Einzelwert $x_{i}$ durch $\frac{x_{i}-\bar{x}}{s}$. \lstinline!mean(<<Vektor>>)! berechnet den Mittelwert (Abschn.\ \ref{sec:mean}), \lstinline!sd(<<Vektor>>)! ermittelt die korrigierte Streuung (Abschn.\ \ref{sec:varSd}).
\begin{lstlisting}
> (zAge <- (age - mean(age)) / sd(age))
[1] -1.1166106 -0.6380632 1.7546739 0.3190316 0.0797579 -0.3987895
\end{lstlisting}

\index{Daten!zentrieren}
Eine andere Möglichkeit bietet die Funktion \lstinline!scale(x=<<Vektor>>, center=TRUE, scale=TRUE)!\index[func]{scale()@\lstinline{scale()}}. Sie berechnet die $z$-Werte mit Hilfe der korrigierten Streuung, gibt sie jedoch nicht in Form eines Vektors, sondern als Matrix mit einer Spalte aus.\footnote{Für \lstinline!x! kann auch eine Matrix übergeben werden, deren $z$-transformierte Spalten dann die Spalten der ausgegebenen Matrix ausmachen (Abschn.\ \ref{sec:matrix}).} Weiterhin werden Mittelwert und korrigierte Streuung von \lstinline!x! in Form von Attributen mit angegeben. Standardisierung und Zentrierung können unabhängig voneinander ausgewählt werden: Für die zentrierten, nicht aber standardisierten Werte von \lstinline!x! ist etwa \lstinline!scale=FALSE! zu setzen und \lstinline!center=TRUE! zu belassen.
\begin{lstlisting}
> (zAge <- scale(age))
           [,1]
[1,] -1.1166106
[2,] -0.6380632
[3,]  1.7546739
[4,]  0.3190316
[5,]  0.0797579
[6,] -0.3987895

attr(,"scaled:center")
[1] 22.66667

attr(,"scaled:scale")
[1] 4.179314
\end{lstlisting}

Um die ausgegebene Matrix wieder in einen Vektor zu verwandeln, muss sie wie in Abschn.\ \ref{sec:asVecMat} dargestellt mit \lstinline!as.vector(<<Matrix>>)! konvertiert werden.
\begin{lstlisting}
> as.vector(zAge)
[1] -1.1166106 -0.6380632 1.7546739 0.3190316 0.0797579 -0.3987895
\end{lstlisting}

\index{Daten!skalieren}
Durch Umkehrung des Prinzips der $z$-Transformation lassen sich empirische Datenreihen so skalieren, dass sie einen beliebigen Mittelwert $\bar{x}_{\text{neu}}$ und eine beliebige Streuung $s_{\text{neu}}$ besitzen. Dies geschieht für eine $z$-transformierte Variable $Z$ mit $Z \cdot s_{\text{neu}} + \bar{x}_{\text{neu}}$.
\begin{lstlisting}
> newSd   <- 15
> newMean <- 100
> (newAge <- as.vector(zAge)*newSd + newMean)
[1] 83.25084 90.42905 126.32011 104.78547 101.19637 94.01816

> mean(newAge)                              # Kontrolle: Mittelwert
[1] 100

> sd(newAge)                                # Kontrolle: Streuung
[1] 15
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Rangtransformation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!Rangtransformation}
\index{Rangplatz|see{Daten}}
\lstinline!rank(<<Vektor>>)!\index[func]{rank()@\lstinline{rank()}} gibt für jedes Element eines Vektors seinen Rangplatz an, der sich an der Position des Wertes im sortierten Vektor orientiert und damit der Ausgabe von \lstinline!order()! ähnelt. Anders als bei \lstinline!order()! erhalten identische Werte in der Voreinstellung jedoch denselben Rang. Das Verhalten, mit dem bei solchen \emph{Bindungen} Ränge ermittelt werden, kontrolliert das Argument \lstinline!ties.method! -- Voreinstellung sind mittlere Ränge.
\begin{lstlisting}
> rank(c(3, 1, 2, 3))
[1] 3.5 1.0 2.0 3.5
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Neue aus bestehenden Variablen bilden}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Variable!neue aus bestehenden bilden}
Das elementweise Verrechnen mehrerer Vektoren kann, analog zur $z$-Transformation, allgemein zur flexiblen Neubildung von Variablen aus bereits bestehenden Daten genutzt werden.

Ein Beispiel sei die Berechnung des Body-Mass-Index (BMI) einer Person, für den ihr Körpergewicht in kg durch das Quadrat ihrer Körpergröße in m geteilt wird.
\begin{lstlisting}
> height <- c(1.78, 1.91, 1.89, 1.83, 1.64)
> weight <- c(65, 89, 91, 75, 73)
> (bmi   <- weight / (height^2))
[1] 20.51509 24.39626 25.47521 22.39541 27.14158
\end{lstlisting}

In einem zweiten Beispiel soll die Summenvariable aus drei dichotomen Items ({\quotedblbase}trifft zu{\textquotedblleft}: \lstinline!TRUE!, {\quotedblbase}trifft nicht zu{\textquotedblleft}: \lstinline!FALSE!) eines an $8$ Personen erhobenen Fragebogens gebildet werden. Dies ist die Variable, die jeder Person den\index{Summenscore} Summenscore aus ihren Antworten zuordnet, also angibt, wie viele Items von der Person als zutreffend angekreuzt wurden. Logische Werte verhalten sich bei numerischen Rechnungen wie $1$ (\lstinline!TRUE!) bzw.\ $0$ (\lstinline!FALSE!).
\begin{lstlisting}
> quest1  <- c(FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE, FALSE, TRUE)
> quest2  <- c(TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE, TRUE,  FALSE)
> quest3  <- c(TRUE,  TRUE,  TRUE,  TRUE,  FALSE, TRUE, FALSE, FALSE)
> (sumVar <- quest1 + quest2 + quest3)
[1] 2 1 1 2 1 3 1 1
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Werte ersetzen oder recodieren}
\label{sec:recode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Vektor!Elemente ersetzen}
\index{Daten!ersetzen}
\index{Daten!recodieren}
\index{recodieren|see{Daten}}
Mitunter werden Variablen zunächst auf eine bestimmte Art codiert, die sich später für manche Auswertungen als nicht zweckmäßig erweist und deswegen geändert werden soll. Dann müssen bestimmte Werte gesucht und ersetzt werden, was sich auf verschiedenen Wegen erreichen lässt. Dabei sollte die Variable mit recodierten Werten stets als neues Objekt erstellt werden, statt die Werte des alten Objekts zu überschreiben.

Logische Indexvektoren bieten eine von mehreren Methoden, um systematisch bestimmte Werte durch andere zu ersetzen. In einem Vektor seien dazu die Lieblingsfarben von sieben englischsprachigen Personen erhoben worden. Später soll die Variable auf deutsche Farbnamen recodiert werden.
\begin{lstlisting}
> myColors <- c("red", "purple", "blue", "blue",
+               "orange", "red", "orange")

> farben   <- character(length(myColors))     # neuen Vektor erstellen
> farben[myColors == "red"]    <- "rot"
> farben[myColors == "purple"] <- "violett"
> farben[myColors == "blue"]   <- "blau"
> farben[myColors == "orange"] <- "orange"
> farben
[1] "rot" "violett" "blau" "blau" "orange" "rot" "orange"
\end{lstlisting}

Mit \lstinline!replace()!\index[func]{replace()@\lstinline{replace()}} können Werte eines Vektors ebenfalls über Indexvektoren ausgetauscht werden.
\begin{lstlisting}
> replace(x=<<Vektor>>, list=<<Indexvektor>>, values=<<neue Werte>>)
\end{lstlisting}

Der Vektor mit den auszutauschenden Elementen ist unter \lstinline!x! zu nennen. Welche Werte geändert werden sollen, gibt der Indexvektor \lstinline!list! über numerische oder logische Indizes an. Der Vektor \lstinline!values! definiert für jeden in \lstinline!list! genannten Index mit je einem Element, welcher Wert an dieser Stelle neu einzufügen ist. Da \lstinline!replace()! den unter \lstinline!x! angegebenen Vektor nicht verändert, muss das Ergebnis ggf.\ einem neuen Objekt zugewiesen werden.
\begin{lstlisting}
> replace(c(1, 2, 3, 4, 5), list=c(2, 4), values=c(200, 400))
[1] 1 200 3 400 5
\end{lstlisting}

\lstinline!recode()!\index[func]{recode()@\lstinline{recode()}|textbf} aus dem Paket \lstinline!car!\index[pack]{car@\lstinline{car}} ermöglicht es auf bequemere Weise, gleichzeitig viele Werte nach einem Muster zu ändern, ohne dabei selbst logische Indexvektoren bilden zu müssen.
\begin{lstlisting}
> recode(var=<<Vektor>>, recodes="<<Muster>>")
\end{lstlisting}

Der Vektor mit zu ändernden Werten ist für \lstinline!var! anzugeben. Die Recodierung erfolgt anhand eines Musters, das das Argument \lstinline!recodes! bestimmt. Hierbei handelt es sich um eine besonders aufgebaute Zeichenkette: Sie besteht aus durch Semikolon getrennten Elementen, von denen jedes eine Zuordnung von alten und neuen Werten in der Form \lstinline!<<alt>>=<<neu>>! definiert. \lstinline!<<alt>>! nennt in Form eines Vektors Werte in \lstinline!var!, die durch denselben neuen Wert zu ersetzen sind. Sie müssen in \lstinline!var! nicht unbedingt auch tatsächlich vorkommen, wodurch sich auch potentielle Wertebereiche austauschen lassen. \lstinline!<<neu>>! ist der gemeinsame neue Wert für die unter \lstinline!<<alt>>! genannten.

Bei alten und neuen Werten sind Zeichenketten jeweils in einfache Anführungszeichen \lstinline!'<<Zeichen>>'! zu setzen, wenn \lstinline!recodes! insgesamt in doppelten Anführungszeichen \lstinline!"<<Zeichen>>"! steht. Statt einem konkreten alten Wert kann auch dem Schlüsselwort \lstinline!else! ein neuer zugewiesen werden, der dann für alle nicht anderweitig umcodierten Werte gilt. Tauchen Werte von \lstinline!var! nicht im Muster \lstinline!recodes! auf, bleiben sie unverändert. Auch \lstinline!recode()! verändert den Vektor mit auszutauschenden Werten selbst nicht, weshalb das Ergebnis ggf.\ einem neuen Objekt zugewiesen werden muss.
\begin{lstlisting}
> library(car)                                      # für recode()
> recode(myColors, "'red'='rot'; 'blue'='blau'; 'purple'='violett'")
[1] "rot" "violett" "blau" "blau" "orange" "rot" "orange"

# Einteilung der Farben in Basisfarben und andere
> recode(myColors, "c('red', 'blue')='basic'; else='complex'")
[1] "basic" "complex" "basic" "basic" "complex" "basic" "complex"
\end{lstlisting}

Gilt es, Werte entsprechend einer dichotomen Entscheidung durch andere zu ersetzen, kann dies mit \index[func]{ifelse()@\lstinline{ifelse()}}\lstinline!ifelse()! geschehen.
\begin{lstlisting}
> ifelse(test=<<logischer Ausdruck>>, yes=<<Wert>>, no=<<Wert>>)
\end{lstlisting}

Für das Argument \lstinline!test! muss ein Ausdruck angegeben werden, der sich zu einem logischen Wert auswerten lässt, der also WAHR (\lstinline!TRUE!) oder FALSCH (\lstinline!FALSE!) ist. Ist \lstinline!test! WAHR, wird der unter \lstinline!yes! eingetragene Wert zurückgegeben, andernfalls der unter \lstinline!no! genannte. Ist \lstinline!test! ein Vektor, wird jedes seiner Elemente daraufhin geprüft, ob es \lstinline!TRUE! oder \lstinline!FALSE! ist und ein Vektor mit den passenden, unter \lstinline!yes! und \lstinline!no! genannten Werten als Elementen zurückgegeben. Die Ausgabe hat also immer dieselbe Länge wie die von \lstinline!test!.

Die Argumente \lstinline!yes! und \lstinline!no! können selbst Vektoren derselben Länge wie \lstinline!test! sein -- ist dann etwa das dritte Element von \lstinline!test! gleich \lstinline!TRUE!, wird als drittes Element des Ergebnisses das dritte Element von \lstinline!yes! zurückgegeben, andernfalls das dritte Element von \lstinline!no!. Indem für \lstinline!yes! ebenfalls der in \lstinline!test! zu prüfende Vektor eingesetzt wird, können so bestimmte Werte eines Vektors ausgetauscht, andere dagegen unverändert gelassen werden. Dies erlaubt es etwa, alle Werte größer einem Cutoff-Wert auf denselben Maximalwert zu setzen und die übrigen Werte beizubehalten.
\begin{lstlisting}
> orgVec <- c(5, 9, 11, 8, 9, 3, 1, 13, 9, 12, 5, 12, 6, 3, 17, 5, 8, 7)
> cutoff <- 10
> (reVec <- ifelse(orgVec <= cutoff, orgVec, cutoff))
[1] 5 9 10 8 9 3 1 10 9 10 5 10 6 3 10 5 8 7
\end{lstlisting}

In Kombination mit \lstinline!%in%! kann \lstinline!ifelse()! auch genutzt werden, um eine kategoriale Variable so umzucodieren, dass alle nicht in einer bestimmten Menge auftauchenden Werte in einer Kategorie {\quotedblbase}Sonstiges{\textquotedblleft} zusammengefasst werden. Dabei sollte die Variable ein einfacher Vektor sein, da \lstinline!ifelse()! die Klasse des übergebenen Objekts nicht respektiert -- insbesondere Faktoren (Abschn.\ \ref{sec:factor}) sind deshalb für \lstinline!ifelse()! ungeeignet. Als Beispiel sollen nur die ersten $15$ Buchstaben des Alphabets als solche beibehalten, alle anderen Werte zu \lstinline!"other"! recodiert werden.
\begin{lstlisting}
> targetSet <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K")
> response  <- c("Z", "E", "O", "W", "H", "C", "I", "G", "A", "O", "B")
> (respRec  <- ifelse(response %in% targetSet, response, "other"))
[1] "other" "E" "other" "other" "H" "C" "I" "G" "A" "other" "B"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kontinuierliche Variablen in Kategorien einteilen}
\label{sec:discretize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!diskretisieren}
Als Spezialfall des Recodierens können neue Variablen dadurch entstehen, dass der Wertebereich von ursprünglich kontinuierlichen Variablen in Klassen eingeteilt wird. Auf diese Weise lässt sich eine quantitative in eine kategoriale Variable umwandeln. Hier soll der IQ-Wert mehrerer Personen zu einer Klasseneinteilung genutzt werden.
\begin{lstlisting}
> IQ    <- c(112, 103, 87, 86, 90, 101, 90, 89, 122, 103)
> IQcls <- numeric(length(IQ))              # neuen Vektor erstellen
> IQcls[IQ <= 100]                <- 1      # Intervall bis inkl. 100
> IQcls[(IQ > 100) & (IQ <= 115)] <- 2      # Intervall (100, 115]
> IQcls[IQ > 115]                 <- 3      # Intervall größer 115
> IQcls
[1] 2 2 1 1 1 2 1 1 3 2

# Klasseneinteilung der IQ-Werte mit recode()
> library(car)                                    # für recode()
> recode(IQ, "0:100=1; 101:115=2; else=3")
[1] 2 2 1 1 1 2 1 1 3 2

# Dichotomisierung mit ifelse()
> ifelse(IQ >= 100, "hi", "lo")
[1] "hi" "hi" "lo" "lo" "lo" "hi" "lo" "lo" "hi" "hi"
\end{lstlisting}

Besonders leicht lassen sich quantitative Variablen zudem mit \lstinline!cut()! diskretisieren (Abschn.\ \ref{sec:cut}). Hierdurch werden sie zu Faktoren, dem Gegenstand des folgenden Abschnitts.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Gruppierungsfaktoren}
\label{sec:factor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Faktor}
\index{Variable!kategoriale|see{Faktor}}
Die Klasse \lstinline!factor! existiert, um die Eigenschaften kategorialer Variablen abzubilden. Sie eignet sich insbesondere für Gruppierungsfaktoren im versuchsplanerischen Sinn. Ein Objekt dieser Klasse nimmt die jeweilige Gruppenzugehörigkeit von Beobachtungsobjekten auf und enthält Informationen darüber, welche Stufen die Variable prinzipiell umfasst. Für den Gebrauch in inferenzstatistischen Analysefunktionen ist es wichtig, dass Gruppierungsvariablen auch tatsächlich die Klasse \lstinline!factor! besitzen. Insbesondere bei numerisch codierter Gruppenzugehörigkeit besteht sonst die Gefahr der Verwechslung mit echten quantitativen Variablen, was etwa bei linearen Modellen (z.\,B.\ Regression oder Varianzanalyse) für falsche Ergebnisse sorgen kann.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ungeordnete Faktoren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Als Beispiel für eine Gruppenzugehörigkeit soll das qualitative Merkmal Geschlecht dienen, dessen Ausprägungen in einer Stichprobe zunächst als \lstinline!character! Werte eingegeben und in einem Vektor gespeichert werden.
\begin{lstlisting}
> sex <- c("m", "f", "f", "m", "m", "m", "f", "f")
\end{lstlisting}

\index[func]{factor()@\lstinline{factor()}}
Um den aus Zeichen bestehenden Vektor zu einem Gruppierungsfaktor mit zwei Ausprägungen zu machen, dient der Befehl \lstinline!factor()!.
\begin{lstlisting}
> factor(x=<<Vektor>>, levels=<<Stufen>>, labels=levels)
\end{lstlisting}

Unter \lstinline!x! ist der umzuwandelnde Vektor einzutragen. Welche Stufen der Faktor prinzipiell annehmen kann, bestimmt das Argument \lstinline!levels!. In der Voreinstellung werden die Faktorstufen automatisch anhand der in \lstinline!x! tatsächlich vorkommenden Werte mit \lstinline!sort(unique(x))! bestimmt.
\begin{lstlisting}
> (sexFac <- factor(sex))
[1] m f f m m m f f
Levels: f m
\end{lstlisting}

Da die in \lstinline!x! gespeicherten empirischen Ausprägungen nicht notwendigerweise auch alle theoretisch möglichen Kategorien umfassen müssen, kann an \lstinline!levels! auch ein Vektor mit allen möglichen Stufen übergeben werden.
\begin{lstlisting}
# 2 und 5 kommen nicht vor, sollen aber mögliche Ausprägungen sein
> factor(c(1, 1, 3, 3, 4, 4), levels=1:5)
[1] 1 1 3 3 4 4
Levels: 1 2 3 4 5
\end{lstlisting}

Die Stufenbezeichnungen stimmen in der Voreinstellung mit den \lstinline!levels! überein, sie können aber auch durch einen für das Argument \lstinline!labels! übergebenen Vektor umbenannt werden. Dies könnte etwa sinnvoll sein, wenn die Faktorstufen in einem Vektor numerisch codiert sind, im Faktor aber inhaltlich aussagekräftigere Namen erhalten sollen.
\begin{lstlisting}
> (sexNum <- rbinom(10, size=1, prob=0.5))      # 0=Mann, 1=Frau
[1] 0 1 1 0 1 0 0 0 1 1

> factor(sexNum, labels=c("man", "woman"))
[1] man woman woman man woman man man man woman woman
Levels: man woman
\end{lstlisting}

Die Anzahl der Stufen eines Faktors wird mit\index[func]{nlevels()@\lstinline{nlevels()}} \lstinline!nlevels(<<Faktor>>)! ausgegeben; wie häufig jede Stufe vorkommt, erfährt man durch\index[func]{summary()@\lstinline{summary()}} \lstinline!summary(<<Faktor>>)!.
\begin{lstlisting}
> nlevels(sexFac)
[1] 2

> summary(sexFac)
f  m
4  4
\end{lstlisting}

Die im Faktor gespeicherten Werte werden intern auf zwei Arten repräsentiert -- zum einen mit den Namen der Faktorstufen in einem \lstinline!character! Vektor im Attribut \lstinline!levels!, zum anderen mit einer internen Codierung der Stufen über fortlaufende natürliche Zahlen, die der (ggf.\ alphabetischen) Reihenfolge der Ausprägungen entspricht. Dies wird in der Ausgabe der internen Struktur eines Faktors mit \lstinline!str(<<Faktor>>)! deutlich. Die Namen der Faktorstufen werden mit \lstinline!levels(<<Faktor>>)! ausgegeben, die interne numerische Repräsentation mit\index[func]{unclass()@\lstinline{unclass()}} \lstinline!unclass(<<Faktor>>)!.\footnote{Trotz dieser Codierung können Faktoren keinen mathematischen Transformationen unterzogen werden. Wenn die Namen der Faktorstufen aus Zahlen gebildet werden, kann es zu Diskrepanzen zwischen den Stufen und der internen Codierung kommen: \lstinline!unclass(factor(10:15))! ergibt \lstinline!1 2 3 4 5 6!. Dies ist bei der üblichen Verwendung von Faktoren aber irrelevant.}
\begin{lstlisting}
> levels(sexFac)
[1] "f" "m"

> str(sexFac)
Factor w/ 2 levels "f","m": 2 1 1 2 2 2 1 1

> unclass(sexFac)
[1] 2 1 1 2 2 2 1 1

attr(,"levels")
[1] "f" "m"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Faktoren kombinieren}
\label{sec:combFac}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Faktoren lassen sich nicht wie Vektoren mit \lstinline!c()! aneinanderhängen, da\index[func]{c()@\lstinline{c()}} \lstinline!c()! die Attribute der übergebenen Argumente (bis auf die Elementnamen) entfernt. Im Fall von Faktoren wären deren Klasse \lstinline!factor! und die Stufen \lstinline!levels! davon betroffen. Stattdessen muss ein komplizierterer Weg gewählt werden: Zunächst sind aus den zu kombinierenden Faktoren alle Ausprägungen in Form von \lstinline!character! Vektoren zu extrahieren und diese dann mit \lstinline!c()! zu verbinden, bevor aus dem kombinierten Vektor wieder ein Faktor erstellt wird. Dabei gehen allerdings mögliche Faktorstufen verloren, die nicht auch als Ausprägung tatsächlich vorkommen.
\begin{lstlisting}
> (fac1 <- factor(sample(LETTERS, 5)))  # Faktor 1
[1] Q A P U J
Levels: A J P Q U

> (fac2 <- factor(sample(letters, 3)))  # Faktor 2
[1] z g t
Levels: g t z

> (charVec1 <- levels(fac1)[fac1])      # character Vektor zu Faktor 1
[1] "Q" "A" "P" "U" "J"

> (charVec2 <- levels(fac2)[fac2])      # character Vektor zu Faktor 2
[1] "z" "g" "t"

# Faktor der aneinandergehängten character Vektoren
> factor(c(charVec1, charVec2))
[1] Q A P U J z g t
Levels: A g J P Q t U z
\end{lstlisting}

Gilt es, lediglich einen bereits bestehenden Faktor zu vervielfachen, eignet sich dagegen wie bei Vektoren \lstinline!rep()!.
\begin{lstlisting}
> rep(fac1, times=2)                    # Faktor 1 wiederholen
[1] Q A P U J Q A P U J
Levels: A J P Q U
\end{lstlisting}

In Situationen, in denen sich experimentelle Bedingungen aus der Kombination von zwei oder mehr Faktoren ergeben, ist es bisweilen nützlich, die mehrfaktorielle in eine geeignete einfaktorielle Struktur zu überführen. Dabei werden alle Kombinationen von Faktorstufen als Stufen eines neuen einzelnen Faktors betrachtet -- etwa im Kontext einer assoziierten einfaktoriellen Varianzanalyse bei einem eigentlich zweifaktoriellen Design (Abschn.\ \ref{sec:CRFpq}). Dies ist mit\index[func]{interaction()@\lstinline{interaction()}|textbf} \lstinline!interaction()! möglich.
\begin{lstlisting}
> interaction(<<Faktor1>>, <<Faktor2>>, ..., drop=FALSE)
\end{lstlisting}

Als Argument sind zunächst mehrere Faktoren gleicher Länge zu übergeben, die die Gruppenzugehörigkeit derselben Beobachtungsobjekte bzgl.\ verschiedener Gruppierungsfaktoren codieren. Auf ihren Stufenkombinationen basieren die Ausprägungen des neuen Faktors. Dabei kann es vorkommen, dass nicht für jede Stufenkombination Beobachtungen vorhanden sind, da einige Zellen im Versuchsdesign leer sind, oder kein vollständig gekreuztes Design vorliegt. In der Voreinstellung \lstinline!drop=FALSE! erhält der neue Faktor auch für leere Zellen eine passende Faktorstufe. Mit \lstinline!drop=TRUE! werden zu leeren Zellen gehörende Stufen dagegen weggelassen.
\begin{lstlisting}
> (IV1 <- factor(rep(c("lo", "hi"), each=6)))   # Faktor 1
[1] lo lo lo lo lo lo hi hi hi hi hi hi
Levels: hi lo

> (IV2 <- factor(rep(1:3, times=4)))            # Faktor 2
[1] 1 2 3 1 2 3 1 2 3 1 2 3
Levels: 1 2 3

> interaction(IV1, IV2)         # assoziiertes einfaktorielles Design
[1] lo.1 lo.2 lo.3 lo.1 lo.2 lo.3 hi.1 hi.2 hi.3 hi.1 hi.2 hi.3
Levels: hi.1 lo.1 hi.2 lo.2 hi.3 lo.3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Faktorstufen nachträglich ändern}
\label{sec:facChangeLevels}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Wenn die Stufenbezeichnungen eines Faktors im nachhinein geändert werden sollen, so kann dem von\index[func]{levels()@\lstinline{levels()}} \lstinline!levels(<<Faktor>>)! ausgegebenen Vektor ein Vektor mit passend vielen neuen Namen zugewiesen werden.
\begin{lstlisting}
> levels(sexFac) <- c("female", "male")       # vorherige Stufen: f, m
> sexFac
[1] male female female male male male female female
Levels: female male
\end{lstlisting}

Einem bestehenden Faktor können nicht beliebige Werte als Element hinzugefügt werden, sondern lediglich solche, die einer bereits existierenden Faktorstufe entsprechen. Bei Versuchen, einem Faktorelement einen anderen Wert zuzuweisen, wird das Element auf \lstinline!NA! gesetzt und eine Warnung ausgegeben. Die Menge möglicher Faktorstufen kann jedoch über\index[func]{levels()@\lstinline{levels()}} \lstinline!levels()! erweitert werden, ohne dass es bereits zugehörige Beobachtungen gäbe.
\begin{lstlisting}
> (status <- factor(c("hi", "lo", "hi")))
[1] hi lo hi
Levels: hi lo

# bisher nicht existierende Faktorstufe "mid"
> status[4] <- "mid"
> status
Warning message:
In `[<-.factor`(`*tmp*`, 4, value = "mid") :
invalid factor level, NAs generated

[1] hi lo hi <NA>
Levels: hi lo

> levels(status) <- c(levels(status), "mid")  # Stufe "mid" hinzufügen
> status[4] <- "mid"                          # neue Beobachtung "mid"
> status
[1] hi lo hi mid
Levels: hi lo mid
\end{lstlisting}

\index{Daten!recodieren}
Stufen eines bestehenden Faktors lassen sich nicht ohne weiteres löschen. Die erste Möglichkeit, um einen gegebenen Faktor in einen Faktor mit weniger möglichen Stufen umzuwandeln, besteht im Zusammenfassen mehrerer ursprünglicher Stufen zu einer gemeinsamen neuen Stufe. Hierzu muss dem von\index[func]{levels()@\lstinline{levels()}} \lstinline!levels()! ausgegebenen Objekt eine Liste zugewiesen werden, die nach dem Muster \lstinline!list(<<neueStufe>>=c("<<alteStufe1>>", "<<alteStufe2>>", ...))! aufgebaut ist (Abschn.\ \ref{sec:list}). Alternativ eignet sich die in Abschn.\ \ref{sec:recode} vorgestellte\index[func]{recode()@\lstinline{recode()}} \lstinline!recode()! Funktion aus dem Paket\index[pack]{car@\lstinline{car}} \lstinline!car!, mit der sich auch Faktoren umcodieren lassen.
\begin{lstlisting}
# kombiniere Stufen "mid" und "lo" zu "notHi", "hi" bleibt unverändert
> hiNotHi <- status                           # Kopie des Faktors
> levels(hiNotHi) <- list(hi="hi", notHi=c("mid", "lo"))
> hiNotHi
[1] hi notHi hi notHi
Levels: hi notHi

> library(car)                                # für recode()
> (statNew <- recode(status, "'hi'='high'; c('mid', 'lo')='notHigh'"))
[1] high notHigh high notHigh
Levels: high notHigh
\end{lstlisting}

Sollen dagegen Beobachtungen samt ihrer Stufen gelöscht werden, muss eine Teilmenge der Elemente des Faktors ausgegeben werden, die nicht alle Faktorstufen enthält. Zunächst umfasst diese Teilmenge jedoch nach wie vor alle ursprünglichen Stufen, wie in der Ausgabe unter \lstinline!Levels! deutlich wird. Sollen nur die in der gewählten Teilmenge tatsächlich auftretenden Ausprägungen auch mögliche \lstinline!Levels! sein, kann dies mit\index[func]{droplevels()@\lstinline{droplevels()}} \lstinline!droplevels()! erreicht werden.
\begin{lstlisting}
> status[1:2]
[1] hi lo
Levels: hi lo mid

> (newStatus <- droplevels(status[1:2]))
[1] hi lo
Levels: hi lo
\end{lstlisting}

Fehlende Werte (Abschn.\ \ref{sec:na}) im ursprünglichen Vektor bleiben in der Voreinstellung fehlende Werte im aus dem Vektor erstellten Faktor. Beim Erstellen eines Faktors lassen sich jedoch fehlende Werte mit dem Argument \lstinline!exclude=NULL! als eigene Kategorie werten. Im Nachhinein lässt sich derselbe Effekt mit\index[func]{addNA()@\lstinline{addNA()}} \lstinline!addNA()! erzielen. Dies ist etwa in Häufigkeitstabellen nützlich, um fehlende Werte mit zu zählen.
\begin{lstlisting}
# fehlende Werte bilden keine eigene Stufe
> (fac <- factor(c("A", "B", NA, "A", NA)))
[1] A  B  <NA>  A  <NA>
Levels: A B

# fehlende Werte bilden eigene Stufe
> (facNA <- factor(c("A", "B", NA, "A", NA), exclude=NULL))
[1] A  B  <NA>  A  <NA>
Levels: A B <NA>

> table(fac)           # fehlende Werte werden nicht gezählt
fac
A B 
2 1 

> table(addNA(fac))    # fehlende Werte werden gezählt
A  B  <NA> 
2  1     2 
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Geordnete Faktoren}
\label{sec:facOrder}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Besteht eine Reihenfolge in den Stufen eines Gruppierungsfaktors i.\,S.\ einer ordinalen Variable, so lässt sich dieser Umstand mit der Funktion\index[func]{ordered()@\lstinline{ordered()}} \lstinline!ordered(<<Vektor>>, levels)! abbilden, die einen geordneten Gruppierungsfaktor erstellt. Dabei muss die inhaltliche Reihenfolge im Argument \lstinline!levels! explizit angegeben werden, weil R sonst die Reihenfolge selbst bestimmt und ggf.\ die alphabetische heranzieht. Für die Elemente geordneter Faktoren sind die üblichen Ordnungsrelationen $<, \leq, >, \geq$ definiert.
\begin{lstlisting}
> (ordStat <- ordered(status, levels=c("lo", "mid", "hi")))
[1] hi lo hi mid
Levels: lo < mid < hi

> ordStat[1] > ordStat[2]                       # hi > lo?
[1] TRUE
\end{lstlisting}

Manche Funktionen zur inferenzstatistischen Analyse nehmen bei geordneten Faktoren Gleichabständigkeit in dem Sinne an, dass die inhaltliche Unterschiedlichkeit zwischen zwei benachbarten Stufen immer dieselbe ist. Trifft dies nicht zu, sollte im Zweifel auf ungeordnete Faktoren zurückgegriffen werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reihenfolge von Faktorstufen bestimmen}
\label{sec:facLabelOrder}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Beim Sortieren von Faktoren wie auch in manchen statistischen Analysefunktionen ist die Reihenfolge der Faktorstufen bedeutsam. Werden die Faktorstufen beim Erstellen eines Faktors explizit mit \lstinline!levels! oder \lstinline!labels! angegeben, bestimmt die Reihenfolge dieser Elemente die Reihenfolge der Stufen. Ohne Verwendung von \lstinline!levels! oder \lstinline!labels! ergibt sich die Reihenfolge aus den sortierten Elementen des Vektors, der zum Erstellen des Faktors verwendet wird.\footnote{Sind dessen Elemente Zeichenketten mit numerischer Bedeutung, so ist zu beachten, dass die Reihenfolge dennoch alphabetisch bestimmt wird -- die Stufe \lstinline!\"10\"! käme demnach vor der Stufe \lstinline!\"4\"!.}
\begin{lstlisting}
> vec <- c(3, 4, 3, 2, 1, 4, 1, 1)

# ohne levels/labels -> Reihenfolge aus sortierten Elemente des Vektors
> factor(vec)
[1] 3 4 3 2 1 4 1 1
Levels: 1 2 3 4

# nur levels angegeben -> levels bestimmt Reihenfolge der Stufen
> factor(vec, levels=c(4, 3, 2, 1))
[1] 3 4 3 2 1 4 1 1
Levels: 4 3 2 1

# levels und labels angegeben -> labels bestimmt Reihenfolge der Stufen
> factor(vec, levels=1:4, labels=c("one", "two", "three", "four"))
[1] three four three two one four one one
Levels: one two three four
\end{lstlisting}

Um die Reihenfolge der Stufen nachträglich zu ändern, kann ein Faktor in einen geordneten Faktor unter Verwendung des \lstinline!levels! Arguments umgewandelt werden (s.\,o.). Als weitere Möglichkeit wird mit\index[func]{relevel()@\lstinline{relevel()}} \lstinline!relevel(<<Faktor>>, ref="<<Referenzstufe>>")! die für \lstinline!ref! übergebene Faktorstufe zur ersten Stufe des Faktors. \lstinline!reorder()!\index[func]{reorder()@\lstinline{reorder()}} ändert die Reihenfolge der Faktorstufen ebenfalls nachträglich. Die Stufen werden so geordnet, dass ihre Reihenfolge durch die gruppenweise gebildeten empirischen Kennwerte einer Variable bestimmt ist.\footnote{Das Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} stellt zudem die Funktion \index[func]{reorder.factor()@\lstinline{reorder.factor()}} \lstinline!reorder.factor()! bereit, mit der Faktorstufen beliebig geordnet werden können.}
\begin{lstlisting}
> reorder(x=<<Faktor>>, X=<<Vektor>>, FUN=<<Funktion>>)
\end{lstlisting}

Als erstes Argument \lstinline!x! wird der Faktor mit den zu ordnenden Stufen erwartet. Für das Argument \lstinline!X! ist ein numerischer Vektor derselben Länge wie \lstinline!x! zu übergeben, der auf Basis von \lstinline!x! in Gruppen eingeteilt wird. Pro Gruppe wird die mit \lstinline!FUN! bezeichnete Funktion angewendet, die einen Vektor zu einem skalaren Kennwert verarbeiten muss. Als Ergebnis werden die Stufen von \lstinline!x! entsprechend der Kennwerte geordnet, die sich aus der gruppenweisen Anwendung von \lstinline!FUN! ergeben (Abschn.\ \ref{sec:tapply} für \lstinline!tapply()!).
\begin{lstlisting}
> fac1 <- factor(rep(LETTERS[1:3], each=10))
> vec  <- rnorm(30, rep(c(10, 5, 15), each=10), 3)
> reorder(fac1, vec, FUN=mean)
 [1] A A A A A A A A A A B B B B B B B B B B C C
[23] C C C C C C C C
Levels: B < A < C

# Kontrolle: Mittelwerte pro Gruppe
> tapply(vec, fac1, FUN=mean)
       A        B         C
10.18135  6.47932  13.50108
\end{lstlisting}

Beim Sortieren von Faktoren wird die Reihenfolge der Elemente durch die Reihenfolge der Faktorstufen bestimmt, die nicht mit der numerischen oder alphabetischen Reihenfolge der Stufenbezeichnungen übereinstimmen muss. Damit kann das Sortieren eines Faktors zu einem anderen Ergebnis führen als das Sortieren eines Vektors, auch wenn diese oberflächlich dieselben Elemente enthalten.
\begin{lstlisting}
> (fac2 <- factor(sample(1:2, 10, replace=TRUE), labels=c("B", "A")))
[1] A A A B B A B B B B
Levels: B A

> sort(fac2)
[1] B B B B B B A A A A

> sort(as.character(fac2))
[1] "A" "A" "A" "A" "B" "B" "B" "B" "B" "B"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Faktoren nach Muster erstellen}
\label{sec:glExpandGrid}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Da Faktoren im Zuge der Einteilung von Beobachtungsobjekten in Gruppen oft nach festem Muster erstellt werden müssen, lassen sich Faktoren als Alternative zur manuellen Anwendung von \lstinline!rep()! und \lstinline!factor()! mit\index[func]{gl()@\lstinline{gl()}} \lstinline!gl()! automatisiert erzeugen.
\begin{lstlisting}
> gl(n=<<Stufen>>, k=<<Zellbesetzung>>, labels=1:n, ordered=FALSE)
\end{lstlisting}

Das Argument \lstinline!n! gibt die Anzahl der Stufen an, die der Faktor besitzen soll. Mit \lstinline!k! wird festgelegt, wie häufig jede Faktorstufe realisiert werden soll, wie viele Beobachtungen also jede Bedingung umfasst. Für \lstinline!labels! kann ein Vektor mit so vielen Gruppenbezeichnungen angegeben werden, wie Stufen vorhanden sind. In der Voreinstellung werden die Gruppen numeriert. Um einen geordneten Faktor zu erstellen, ist \lstinline!ordered=TRUE! zu setzen.
\begin{lstlisting}
> (fac1 <- factor(rep(c("A", "B"), c(5, 5))))               # manuell
[1] A A A A A B B B B B
Levels: A B

> (fac2 <- gl(2, 5, labels=c("less", "more"), ordered=TRUE))
[1] less less less less less more more more more more
Levels: less < more
\end{lstlisting}

Sollen die Elemente des Faktors in eine zufällige Reihenfolge gebracht werden, um die Zuordnung von Beobachtungsobjekten zu Gruppen zu randomisieren, kann dies wie in Abschn.\ \ref{sec:randOrder} beschrieben geschehen.
\begin{lstlisting}
> sample(fac2, length(fac2), replace=FALSE)
[1] more more less more less less less more more less
Levels: less < more
\end{lstlisting}

Bei mehreren Faktoren mit vollständig gekreuzten Faktorstufen kann \lstinline!expand.grid()!\index[func]{expand.grid()@\lstinline{expand.grid()}} verwendet werden, um alle Stufenkombinationen zu erstellen (Abschn.\ \ref{sec:combinatorics}). Dabei ist die angestrebte Gruppenbesetzung pro Zelle nur bei einem der hier im Aufruf durch \lstinline!gl()! erstellten Faktoren anzugeben, beim anderen ist sie auf $1$ zu setzen. Das Ergebnis ist ein Datensatz (Abschn.\ \ref{sec:dataframe}).
\begin{lstlisting}
> expand.grid(IV1=gl(2, 2, labels=c("a", "b")), IV2=gl(3, 1))
   IV1  IV2
1    a    1
2    a    1
3    b    1
4    b    1
5    a    2
6    a    2
7    b    2
8    b    2
9    a    3
10   a    3
11   b    3
12   b    3
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantitative in kategoriale Variablen umwandeln}
\label{sec:cut}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!diskretisieren}
\index[func]{cut()@\lstinline{cut()}}
Aus den in einem Vektor gespeicherten Werten einer quantitativen Variable lässt sich mit \lstinline!cut()! ein Gruppierungsfaktor erstellen -- die quantitative Variable wird so in eine kategoriale umgewandelt (s.\ auch Abschn.\ \ref{sec:discretize}). Dazu muss zunächst der Wertebereich des Vektors in disjunkte Intervalle eingeteilt werden. Die einzelnen Werte werden dann entsprechend ihrer Zugehörigkeit zu diesen Intervallen Kategorien zugeordnet und erhalten als Wert die zugehörige Faktorstufe.
\begin{lstlisting}
> cut(x=<<Vektor>>, breaks=<<Intervalle>>, labels=<<Bezeichnungen>>,
+     ordered=FALSE)
\end{lstlisting}

Die Intervalle werden über das Argument \lstinline!breaks! festgelegt. Hier ist entweder die Anzahl der (dann gleich breiten) Intervalle anzugeben, oder die Intervallgrenzen selbst als Vektor. Die Intervalle werden in der Form $(a, b\,]$ gebildet, sind also nach unten offen und nach oben geschlossen. Anders gesagt ist die untere Grenze nicht Teil des Intervalls, die obere schon. Die Unter- und Obergrenze des insgesamt möglichen Wertebereichs müssen bei der Angabe von \lstinline!breaks! berücksichtigt werden, ggf.\ sind dies \lstinline!-Inf! und \lstinline!Inf! für negativ und positiv unendliche Werte.

Wenn die Faktorstufen andere Namen als die zugehörigen Intervallgrenzen tragen sollen, können sie über das Argument \lstinline!labels! explizit angegeben werden. Dabei ist darauf zu achten, dass die Reihenfolge der neuen Benennungen der Reihenfolge der gebildeten Intervalle entspricht. Soll es sich im Ergebnis um einen geordneten Faktor handeln, ist \lstinline!ordered=TRUE! zu setzen.
\begin{lstlisting}
> IQ    <- rnorm(100, mean=100, sd=15)
> IQfac <- cut(IQ, breaks=c(0, 85, 115, Inf),
+              labels=c("lo", "mid", "hi"))

> IQfac[1:5]
[1] hi lo mid mid mid lo
Levels: lo mid hi
\end{lstlisting}

\index{Daten!Median-Split}
Um annähernd gleich große Gruppen zu erhalten, können für die Intervallgrenzen bestimmte Quantile der Daten gewählt werden, etwa der Median für den Median-Split (Abschn.\ \ref{sec:mean}).
\begin{lstlisting}
> medSplit <- cut(IQ, breaks=c(-Inf, median(IQ), Inf))
> summary(medSplit)           # Kontrolle: Häufigkeiten der Kategorien
medSplit
(-Inf,97.6]  (97.6,Inf]
         50          50
\end{lstlisting}

Für mehr als zwei etwa gleich große Gruppen lässt sich die Ausgabe von \lstinline!quantile()! (Abschn.\ \ref{sec:quantile}) direkt an das Argument \lstinline!breaks! übergeben. Dies ist möglich, da \lstinline!quantile()! neben den Quantilen auch das Minimum und Maximum der Werte ausgibt. Damit das unterste Intervall auch das Minimum einschließt -- und nicht wie alle übrigen Intervalle nach unten offen ist, muss das Argument \lstinline!include.lowest=TRUE! gesetzt werden.
\begin{lstlisting}
# 4 ähnliche große Gruppen, unterstes Intervall dabei unten geschlossen
> IQdiscr <- cut(IQ, quantile(IQ), include.lowest=TRUE)
> summary(IQdiscr)            # Kontrolle: Häufigkeiten der Kategorien
IQdiscr
[62.1,87.1]  (87.1,97.6]  (97.6,107]  (107,154]
         25           25          25         25
\end{lstlisting}

Anstelle von \lstinline!cut()! kann auch \index[func]{CutQ()@\lstinline{CutQ()}} \lstinline!CutQ()! aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} verwendet werden, um eine Variable in Intervalle mit etwa gleichen Häufigkeiten zu unterteilen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Deskriptive Kennwerte numerischer Daten}
\label{sec:descriptive}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{deskriptive Kennwerte|see{Daten}}
\index{Daten!Kennwerte}
Die deskriptive Beschreibung von Variablen ist ein wichtiger Teil der Analyse empirischer Daten, die gemeinsam mit der grafischen Darstellung (Abschn.\ \ref{sec:distDiag}) hilft, ihre Struktur besser zu verstehen. Die hier umgesetzten statistischen Konzepte und Techniken werden als bekannt vorausgesetzt und finden sich in vielen Lehrbüchern der Statistik \cite{Eid2010}.

R stellt für die Berechnung aller gängigen Kennwerte separate Funktionen bereit, die meist erwarten, dass die Daten in Vektoren gespeichert sind.\footnote{Viele von ihnen werden in \index[func]{Desc()@\lstinline{Desc()}} \lstinline!Desc()! aus dem Paket\index[pack]{DescTools@\lstinline{DescTools}} \lstinline!DescTools! integriert.} Es sei an dieser Stelle daran erinnert, dass sich logische Wahrheitswerte ebenfalls in einem numerischen Kontext verwenden lassen, wobei der Wert \lstinline!TRUE! wie eine $1$, der Wert \lstinline!FALSE! wie eine $0$ behandelt wird.

Mit \lstinline!summary(<<Vektor>>)!\index[func]{summary()@\lstinline{summary()}} können die wichtigsten deskriptiven Kennwerte einer Datenreihe abgerufen werden -- dies sind Minimum, erstes Quartil, Median, Mittelwert, drittes Quartil und Maximum. Die Ausgabe ist ein Vektor mit benannten Elementen.
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> summary(age)
 Min.  1st Qu.  Median   Mean  3rd Qu.   Max.
17.00    21.50   24.00  24.33    28.75  30.00
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Summen, Differenzen und Produkte}
\label{sec:sum}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Summe}
\index{kumulierte Summe|see{Summe}}
\index[func]{sum()@\lstinline{sum()}}
\index[func]{cumsum()@\lstinline{cumsum()}}
Mit \lstinline!sum(<<Vektor>>)! wird die Summe aller Elemente eines Vektors berechnet. Die kumulierte Summe erhält man mit \lstinline!cumsum(<<Vektor>>)!.
\begin{lstlisting}
> sum(age)
[1] 146

> cumsum(age)
[1] 17 47 77 102 125 146
\end{lstlisting}

\index{Differenzen}
\index[func]{diff()@\lstinline{diff()}}
Um die Differenzen aufeinander folgender Elemente eines Vektors (also eines Wertes zu einem Vorgänger) zu berechnen, kann die Funktion \lstinline!diff(<<Vektor>>, lag=1)! verwendet werden. Mit ihrem Argument \lstinline!lag! wird kontrolliert, über welchen Abstand die Differenz gebildet wird. Die Voreinstellung \lstinline!1! bewirkt, dass die Differenz eines Wertes zum unmittelbar vorhergehenden berechnet wird. Die Ausgabe umfasst \lstinline!lag! Werte weniger, als der Vektor Elemente besitzt.
\begin{lstlisting}
> diff(age)
[1] 13 0 -5 -2 -2

> diff(age, lag=2)
[1] 13 -5 -7 -4
\end{lstlisting}

\index{Produkt}
\index{kumuliertes Produkt|see{Produkt}}
\index{Fakultat@Fakultät}
\index[func]{prod()@\lstinline{prod()}}
\index[func]{cumprod()@\lstinline{cumprod()}}
Das Produkt aller Elemente eines Vektors wird mit \lstinline!prod(<<Vektor>>)! berechnet, das kumulierte Produkt mit \lstinline!cumprod(<<Vektor>>)!.\footnote{\label{ftn:cumProd}Bei Gleitkommazahlen kumulieren sich bei wiederholter Multiplikation Rundungsfehler, die durch die interne Darstellungsart solcher Zahlen unvermeidlich sind (Abschn.\ \ref{sec:isTRUE}). Numerisch stabiler als \lstinline!prod(<<Vektor>>)! ist deswegen u.\,U.\ die Rücktransformation der Summe der logarithmierten Werte mit \lstinline!exp(sum(log(<<Vektor>>)))! als Umsetzung von $\exp\left(\sum_{i}{\ln x_{i}}\right)$ -- vorausgesetzt $x$ ist echt positiv. \lstinline!prod(numeric(0))! ist gleich \lstinline!1!.} \lstinline!factorial(<<Zahl>>)!\index[func]{factorial()@\lstinline{factorial()}} ermittelt die Fakultät $n!$ einer Zahl $n$.\footnote{Für natürliche Zahlen gilt\index{Gamma-Funktion@$\Gamma$-Funktion} $n! = \Gamma(n+1)$, in R als \lstinline!gamma(<<Zahl>> + 1)!\index[func]{gamma()@\lstinline{gamma()}} berechenbar.}
\begin{lstlisting}
> prod(age)
[1] 184747500

> cumprod(age)
[1] 17 510 15300 382500 8797500 184747500

> factorial(5)
[1] 120
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Extremwerte}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Extremwerte}
\index{Minimum}
\index{Maximum}
\index[func]{min()@\lstinline{min()}}
\index[func]{max()@\lstinline{max()}}
Mit \lstinline!min(<<Vektor>>)! und \lstinline!max(<<Vektor>>)! können die Extremwerte eines Vektors erfragt werden. \lstinline!range(<<Vektor>>)!\index[func]{range()@\lstinline{range()}} gibt den größten und kleinsten Wert zusammengefasst als Vektor aus.
\begin{lstlisting}
> max(age)                      # Maximum
[1] 30

> range(c(17, 30, 30, 25, 23, 21))
[1] 17 30
\end{lstlisting}

Den Index des größten bzw.\ kleinsten Wertes liefern\index[func]{which.max()@\lstinline{which.max()}} \lstinline!which.max(<<Vektor>>)!\index[func]{which.min()@\lstinline{which.min()}} bzw.\ \lstinline!which.min(<<Vektor>>)!. Kommt der größte bzw.\ kleinste Wert mehrfach vor, ist das Ergebnis seine früheste Position. \lstinline!which.min()! lässt sich etwa nutzen, um herauszufinden, welches Element eines Vektors am nächsten an einem vorgegebenen Wert liegt.
\begin{lstlisting}
> which.min(age)              # Position des Minimums
[1] 1

> vec <- c(-5, -8, -2, 10, 9) # Vektor
> which.max(vec > 0)          # Index erstes Element größer 0
[1] 4

# Index des ersten Elements, das nicht in Zielmenge ist
> which.min(vec %in% c(-5, 10))
[1] 2

> val <- 0                    # Referenzwert
> which.min(abs(vec-val))     # welches Element liegt am nächsten an 0?
[1] 3
\end{lstlisting}

\index{range}
\index{Spannweite|see{range}}
Um die Spannweite (\emph{range}) von Werten eines Vektors, also die Differenz von kleinstem und größtem Wert zu ermitteln, ist \lstinline!diff()! nützlich.
\begin{lstlisting}
> diff(range(c(17, 30, 30, 25, 23, 21)))
[1] 13
\end{lstlisting}

Die Funktionen\index[func]{pmin()@\lstinline{pmin()}} \lstinline!pmin(<<Vektor1>>, <<Vektor2>>, ...)! und\index[func]{pmax()@\lstinline{pmax()}} \lstinline!pmax(<<Vektor1>>, <<Vektor2>>, ...)! vergleichen zwei oder mehr Vektoren elementweise hinsichtlich der Größe der in ihnen gespeicherten Werte. Sie liefern einen Vektor aus den pro Position größten bzw.\ kleinsten Werten zurück.
\begin{lstlisting}
> vec1 <- c(5, 2, 0, 7)
> vec2 <- c(3, 3, 9, 2)
> pmax(vec1, vec2)
[1] 5 3 9 7

> pmin(vec1, vec2)
[1] 3 2 0 2
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mittelwert, Median und Modalwert}
\label{sec:mean}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Mittelwert}
\index[func]{mean()@\lstinline{mean()}}
Mit \lstinline!mean(x=<<Vektor>>)! wird das arithmetische Mittel $\frac{1}{n} \sum_{i}{x_{i}}$ eines Vektors $\bm{x}$ der Länge $n$ berechnet.\footnote{Hier ist zu beachten, dass \lstinline!x! tatsächlich ein etwa mit \lstinline!c(...)! gebildeter Vektor ist: Der Aufruf \lstinline!mean(1, 7, 3)! gibt anders als \lstinline!mean(c(1, 7, 3))! nicht den Mittelwert der Daten $1, 7, 3$ aus. Stattdessen ist die Ausgabe gleich dem ersten übergebenen Argument.}
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> mean(age)
[1] 24.33333
\end{lstlisting}

Für die Berechnung eines gewichteten Mittels, bei dem die Gewichte nicht wie bei \lstinline!mean()! für alle Werte identisch sind ($\frac{1}{n}$), eignet sich die Funktion\index[func]{weighted.mean()@\lstinline{weighted.mean()}} \lstinline!weighted.mean(x=<<Vektor>>, w=<<Gewichte>>)!. Ihr zweites Argument \lstinline!w! muss ein Vektor derselben Länge wie \lstinline!x! sein und die Gewichte benennen. Der Einfluss jedes Wertes auf den Mittelwert ist gleich dem Verhältnis seines Gewichts zur Summe aller Gewichte.
\begin{lstlisting}
> weights <- c(0.6, 0.6, 0.3, 0.2, 0.4, 0.6)
> weighted.mean(age, weights)
[1] 23.70370
\end{lstlisting}

\index{Mittelwert!geometrischer}
\index{Mittelwert!harmonischer}
Um beim geometrischen Mittel $\frac{1}{n} \prod_{i}{x_{i}}$ sich fortsetzende Rundungsfehler zu vermeiden, eignet sich für positive $x_{i}$ \lstinline!exp(mean(log(x)))! als Umsetzung von $\euler^{\frac{1}{n} \sum_{i}{\ln x_{i}}}$ (Fußnote \ref{ftn:cumProd}). Das harmonische Mittel $n / \sum_{i}{\frac{1}{x_{i}}}$ berechnet sich als Kehrwert des Mittelwertes der Kehrwerte (für $x_{i} \neq 0$), also mit \lstinline!1 / mean(1/x)!. Alternativ stellt das Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} die Funktionen \lstinline!Gmean()!\index[func]{Gmean()@\lstinline{Gmean()}} und \lstinline!Hmean()!\index[func]{Hmean()@\lstinline{Hmean()}} bereit.

\index{Median}
\index[func]{median()@\lstinline{median()}}
\lstinline!median(x=<<Vektor>>)! gibt den Median, also das $50\%$-Quantil einer empirischen Verteilung aus. Dies ist der Wert, für den die empirische kumulative Häufigkeitsverteilung von \lstinline!x! erstmalig mindestens den Wert $0.5$ erreicht (Abschn.\ \ref{sec:stepfun}), der also $\geq 50\%$ (und $\leq 50\%$) der Werte ist. Im Fall einer geraden Anzahl von Elementen in \lstinline!x! wird zwischen den beiden mittleren Werten von \lstinline!sort(<<Vektor>>)! gemittelt, andernfalls das mittlere Element von \lstinline!sort(<<Vektor>>)! ausgegeben.
\begin{lstlisting}
> sort(age)
[1] 17 21 23 25 30 30

> median(age)
[1] 24

> ageNew <- c(age, 22)
> sort(ageNew)
[1] 17 21 22 23 25 30 30

> median(ageNew)
[1] 23
\end{lstlisting}

\index{Modalwert}
Für die Berechnung des Modalwertes, also des am häufigsten vorkommenden Wertes eines Vektors, stellt der Basisumfang von R keine separate Funktion bereit. Es kann aber auf die Funktion \lstinline!mlv(<<Vektor>>, method="mfv")!\index[func]{mlv()@\lstinline{mlv()}} aus dem Paket  \lstinline!modeest!\index[pack]{modeest@\lstinline{modeest}} \cite{Poncet2012} ausgewichen werden. Bei mehreren Werten gleicher Häufigkeit interpoliert sie zwischen diesen.
\begin{lstlisting}
> vec <- c(11, 22, 22, 33, 33, 33, 33)      # häufigster Wert: 33
> library(modeest)                          # für mlv()
> mlv(vec, method="mfv")
Mode (most likely value): 33
Bickel's modal skewness: -0.4285714
\end{lstlisting}

Eine manuelle Alternative bietet \lstinline!table()! zur Erstellung von Häufigkeitstabellen (Abschn.\ \ref{sec:table}). Die folgende Methode gibt zunächst den Index des Maximums der Häufigkeitstabelle aus. Den Modalwert erhält man zusammen mit seiner Auftretenshäufigkeit durch Indizieren der mit \lstinline!unique()! gebildeten Einzelwerte des Vektors mit diesem Index.
\begin{lstlisting}
> (tab <- table(vec))                       # Häufigkeitstabelle
vec
11  22  33
 1   2   4

> (modIdx <- which.max(tab))                # Index des Modalwerts
33
 3

> unique(vec)[modIdx]                       # Modalwert selbst
[1] 33
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Robuste Maße der zentralen Tendenz}
\label{sec:meanRob}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{robuste Verfahren!zentrale Tendenz}
Wenn Daten Ausreißer aufweisen, kann dies den Mittelwert stark verzerren, so dass er den Lageparameter der zugrundeliegenden Variable nicht mehr gut repräsentiert. Aus diesem Grund existieren Maße der zentralen Tendenz von Daten, die weniger stark durch einzelne extreme Werte beeinflusst werden.

\index{Mittelwert!gestutzter}
Der gestutzte Mittelwert wird ohne einen bestimmten Anteil an Extremwerten berechnet. Mit dem Argument \lstinline!mean(x, trim=<<Zahl>>)! wird der gewünschte Anteil an Extremwerten aus der Berechnung des Mittelwerts ausgeschlossen. \lstinline!<<Zahl>>! gibt dabei den Anteil der Werte an, der auf jeder der beiden Seiten der empirischen Verteilung verworfen werden soll. Um etwa den Mittelwert ohne die extremen $5\%$ der Daten zu berechnen, ist \lstinline!trim=0.025! zu setzen.
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> mean(age)                                 # Vergleich: Mittelwert
[1] 24.33333

> mean(age, trim=0.2)                       # gestutzter Mittelwert
[1] 24.75
\end{lstlisting}

\index{Mittelwert!winsorisierter}
\index{Daten!winsorisieren}
Bei der Winsorisierung von Daten mit \lstinline!Winsorize()!\index[func]{Winsorize()@\lstinline{Winsorize()}} aus dem Paket \lstinline!DescTools! wird ein bestimmter Anteil an Extremwerten auf beiden Seiten der Verteilung durch jeweils den letzten Wert ersetzt, der noch nicht als Extremwert gilt. Dafür legt das Argument \lstinline!probs! in Form eines Vektors die beiden Quantile als Grenzen fest. Der übliche Mittelwert dieser Daten ist dann der winsorisierte Mittelwert.
\begin{lstlisting}
> library(DescTools)                              # für Winsorize()
> (ageWins <- Winsorize(age, probs=c(0.2, 0.8)))  # winsorisierte Daten
[1] 21 30 30 25 23 21

> mean(ageWins)                                   # winsor. Mittelwert
[1] 25
\end{lstlisting}

\index{Hodges-Lehmann-Schatzer@Hodges-Lehmann-Schätzer}
Der Hodges-Lehmann-Schätzer des Lageparameters einer Variable berechnet sich als Median der $n (n+1) / 2$ vielen Walsh-Mittel -- der Mittelwerte aller Wertepaare $(x_{i}, x_{j})$ der Daten mit sich selbst (mit $j \geq i$). Vergleiche hierfür \index[func]{HodgesLehmann()@\lstinline{HodgesLehmann()}} \lstinline!HodgesLehmann()! aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} sowie \lstinline!wilcox.test()! in Abschn.\ \ref{sec:wilcoxSignRank}.
\begin{lstlisting}
> library(DescTools)                              # für HodgesLehmann()
> HodgesLehmann(age, conf.level=0.95)
est.(pseudo)median    lwr.ci    upr.ci
          23.99998  20.99997  27.50005

# manuelle Kontrolle -> Mittelwert aller Wertepaare
> pairM <- outer(age, age, FUN="+") / 2
> median(pairM[lower.tri(pairM, diag=TRUE)])      # deren Median
[1] 24
\end{lstlisting}

\index{Huber-M-Schatzer@Huber-M-Schätzer}
Für Huber $M$-Schätzer der Lage von Verteilungen existiert \lstinline!huberM()!\index[func]{huberM()@\lstinline{huberM()}} aus dem Paket \lstinline!robustbase!\index[pack]{robustbase@\lstinline{robustbase}|textbf} \cite{Rousseeuw2009}. Als Schätzer für die Differenz der Lageparameter von zwei Variablen wird der Hodges-Lehmann-Schätzer als Median aller $n_{1} \cdot n_{2}$ paarweisen Differenzen der Werte aus beiden Datenreihen gebildet (Abschn.\ \ref{sec:wilcoxRankSum}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Prozentrang, Quartile und Quantile}
\label{sec:quantile}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Prozentrang}
Angewendet auf Vektoren mit logischen Werten lassen sich mit \lstinline!sum()! Elemente zählen, die eine bestimmte Bedingung erfüllen. So kann der Prozentrang eines Wertes als prozentualer Anteil derjenigen Werte ermittelt werden, die nicht größer als er sind (vgl.\ auch Abschn.\ \ref{sec:stepfun}).
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> sum(age <= 25)                          # wie viele Elemente <= 25?
[1] 4

> 100 * (sum(age <= 25) / length(age))    # Prozentrang von 25
[1] 66.66667
\end{lstlisting}

\index{Quartil}
\index{Quantil}
\index[func]{quantile()@\lstinline{quantile()}}
Mit \lstinline!quantile(x=<<Vektor>>, probs=seq(0, to=1, by=0.25))! werden in der Voreinstellung die Quartile eines Vektors bestimmt. Dies sind jene Werte, die größer oder gleich einem ganzzahligen Vielfachen von $25\%$ der Datenwerte und kleiner oder gleich den Werten des verbleibenden Anteils der Daten sind. Das erste Quartil ist etwa $\geq 25\%$ (und $\leq 75\%$) der Daten. Das Ergebnis von \lstinline!quantile()! ist ein Vektor mit benannten Elementen.
\begin{lstlisting}
> (quant <- quantile(age))
   0%     25%   50%    75%   100%
17.00  21.50  24.00  28.75  30.00

> quant[c("25%", "50%")]
 25%   50%
21.5  24.0
\end{lstlisting}

Über das \lstinline!probs=<<Vektor>>! Argument können statt der Quartile auch andere Anteile eingegeben werden, deren Wertegrenzen gewünscht sind. Zur Berechnung der Werte, die einen bestimmten Anteil der Daten abschneiden, wird ggf.\ zwischen den in \lstinline!x! tatsächlich vorkommenden Werten interpoliert.\footnote{Zur Berechnung von Quantilen stehen verschiedene Rechenwege zur Verfügung, vgl.\ \lstinline!?quantile!.}
\begin{lstlisting}
> vec <- sample(seq(0, to=1, by=0.01), 1000, replace=TRUE)
> quantile(vec, probs=c(0, 0.2, 0.4, 0.6, 0.8, 1))
   0%    20%    40%    60%    80%   100%
0.000  0.190  0.400  0.604  0.832  1.000
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Varianz, Streuung, Schiefe und Wölbung}
\label{sec:varSd}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Varianz}
\index[func]{var()@\lstinline{var()}}
Mit \lstinline!var(x=<<Vektor>>)! wird die korrigierte Varianz $s^{2} = \frac{1}{n-1} \sum_{i}{(x_{i}-\bar{x})^{2}}$ zur erwartungstreuen Schätzung der Populationsvarianz auf Basis einer Variable $X$ der Länge $n$ mit Mittelwert $\bar{x}$ ermittelt.\footnote{Für ein Diversitätsmaß kategorialer Daten s.\ Abschn.\ \ref{sec:divIdx} und für robuste Varianzschätzer Abschn.\ \ref{sec:varRob}.} Die Umrechnungsformel zur Berechnung der\index{Varianz!unkorrigierte} unkorrigierten Varianz $S^{2} = \frac{1}{n} \sum_{i}{(x_{i}-\bar{x})^{2}}$ aus der korrigierten lautet $S^{2} = \frac{n-1}{n} s^{2}$.\footnote{\label{ftn:covWT}Als Alternative lässt sich \lstinline!cov.wt()! verwenden (Abschn.\ \ref{sec:covMat}).}
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)          # Daten
> N   <- length(age)                        # Anzahl Beobachtungen
> M   <- mean(age)                          # Mittelwert

> var(age)                                  # korrigierte Varianz
[1] 26.26667

> sum((age-M)^2) / (N-1)                    # manuelle Berechnung
[1] 26.26667

> ((N-1) / N) * var(age)                    # unkorrigierte Varianz
[1] 21.88889

> sum((age-M)^2) / N                        # manuelle Berechnung
[1] 21.88889
\end{lstlisting}

\index{Streuung}
\index[func]{sd()@\lstinline{sd()}}
Die korrigierte Streuung $s$ kann durch Ziehen der Wurzel aus der korrigierten Varianz oder mit \lstinline!sd(x=<<Vektor>>)! berechnet werden. Auch hier basiert das Ergebnis auf der bei der Varianz erläuterten Korrektur zur Schätzung der Populationsstreuung auf Basis einer empirischen Stichprobe. Die Umrechnungsformel zur Berechnung der unkorrigierten Streuung $S = \sqrt{\frac{1}{n} \sum_{i}{(x_{i}-\bar{x})^{2}}}$ aus der korrigierten lautet $S = \sqrt{\frac{n-1}{n}} s$.
\begin{lstlisting}
> sqrt(var(age))                            # Wurzel aus Varianz
[1] 5.125102

> sd(age)                                   # korrigierte Streuung
[1] 5.125102

> sqrt((N-1) / N) * sd(age)                 # unkorrigierte Streuung
[1] 4.678556

> sqrt(sum((age-M)^2) / N)                  # manuelle Berechnung
[1] 4.678556
\end{lstlisting}

\index{Schiefe}
\index{Wolbung@Wölbung}
\index{Kurtosis|see{Wölbung}}
\index[func]{Skew()@\lstinline{Skew()}}
\index[func]{Kurt()@\lstinline{Kurt()}}
Schiefe und Wölbung (Kurtosis) als höhere zentrale Momente empirischer Verteilungen lassen sich mit \lstinline!Skew()! und \lstinline!Kurt()! aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} ermitteln.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Diversität kategorialer Daten}
\label{sec:divIdx}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Diversitätsindex}
\index{Shannon-Index}
Der Diversitätsindex $H$ ist ein Streuungsmaß für kategoriale Daten, der mit Werten im Intervall $[0, 1]$ angibt, wie sehr sich die Daten auf die Kategorien verteilen. Sind $f_{j}$ die relativen Häufigkeiten der $p$ Kategorien (Abschn.\ \ref{sec:table}), ist $H = -\frac{1}{\ln p} \sum{(f_{j} \cdot \ln{f_{j}})}$. Für $f_{j} = 0$ ist $f_{j} \cdot \ln{f_{j}}$ dabei als $0$ definiert. $H$ ist genau dann $0$, wenn die Daten konstant sind, also nur eine von mehreren Kategorien auftritt. Für eine Gleichverteilung, in der alle Kategorien dieselbe Häufigkeit besitzen, die Daten also maximal verteilt sind, ist $H = 1$. R verfügt über keine spezialisierte Funktion für die Berechnung von $H$. Es lässt sich aber der Umstand nutzen, dass $H$ bis auf den Faktor $\frac{1}{\ln p}$ mit dem Shannon-Index aus der Informationstheorie übereinstimmt, der sich mit der aus dem Paket\index[pack]{DescTools@\lstinline{DescTools}} \lstinline!DescTools! stammenden Funktion\index[func]{Entropy()@\lstinline{Entropy()}} \lstinline!Entropy()! berechnen lässt. Dafür ist das Argument \lstinline!base! auf die Eulersche Zahl e zu setzen.\footnote{Zudem gilt folgende Beziehung zur diskreten Kullback-Leibler-Divergenz $\text{KL}_{\text{eq}}$ der beobachteten Häufigkeiten zur Gleichverteilung: $H = -\frac{1}{\ln p} \text{KL}_{\text{eq}} + 1$.} Die Funktion erwartet als Argument den Vektor der absoluten oder relativen Häufigkeiten der Kategorien.
\begin{lstlisting}
# Faktor inkl. einer nicht besetzten Stufe "Q"
> fac <- factor(c("C","D","A","D","E","D","C","E","E","B","E"),
+               levels=c(LETTERS[1:5], "Q"))

> P   <- nlevels(fac)                         # Anzahl Kategorien
> (Fj <- prop.table(table(fac)))              # relative Häufigkeiten
         A          B          C          D          E          Q
0.09090909 0.09090909 0.18181818 0.27272727 0.36363636 0.00000000

> library(DescTools)                          # für Entropy()
> shannonIdx <- Entropy(Fj, base=exp(1))      # Shannon Index
> (H <- (1/log(P)) * shannonIdx)              # Diversität
[1] 0.8193845

> keep <- Fj > 0                              # Indizes Häufigk. > 0
> -(1/log(P)) * sum(Fj[keep] * log(Fj[keep])) # Kontrolle ...
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kovarianz und Korrelation}
\label{sec:covCor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Kovarianz}
\index[func]{cov()@\lstinline{cov()}|textbf}
Mit \lstinline!cov(x=<<Vektor1>>, y=<<Vektor2>>)! wird die korrigierte Kovarianz $\frac{1}{n-1} \sum_{i} \left((x_{i}-\bar{x}) \cdot (y_{i}-\bar{y})\right)$ zweier Variablen $X$ und $Y$ derselben Länge $n$ berechnet. Die\index{Kovarianz!unkorrigierte} unkorrigierte Kovarianz muss nach der bereits für die Varianz genannten Umrechnungsformel ermittelt werden (Abschn.\ \ref{sec:varSd}, Fußnote \ref{ftn:covWT}).
\begin{lstlisting}
> x <- c(17, 30, 30, 25, 23, 21)            # Daten Variable 1
> y <- c(1, 12, 8, 10, 5, 3)                # Daten Variable 2
> cov(x, y)                                 # korrigierte Kovarianz
[1] 19.2

> N  <- length(x)                           # Anzahl Objekte
> Mx <- mean(x)                             # Mittelwert Var 1
> My <- mean(y)                             # Mittelwert Var 2
> sum((x-Mx) * (y-My)) / (N-1)  # korrigierte Kovarianz manuell
[1] 19.2

> ((N-1) / N) * cov(x, y)       # unkorrig. Kovarianz aus korrigierter
[1] 16

> sum((x-Mx) * (y-My)) / N      # unkorrigierte Kovarianz manuell
[1] 16
\end{lstlisting}

Neben der voreingestellten Berechnungsmethode für die Kovarianz nach Pearson kann auch die Rang-Kovarianz nach Spearman oder Kendall berechnet werden (Abschn.\ \ref{sec:rhoTau}).

\index{Korrelation}
\index{Zusammenhangsmasse@Zusammenhangsmaße!Korrelation}
\index{Rangkorrelation|see{Korrelation}}
\index[func]{cor()@\lstinline{cor()}|textbf}
Analog zur Kovarianz kann mit \lstinline!cor(x=<<Vektor1>>, y=<<Vektor2>>)! die herkömmliche Produkt-Moment-Korrelation $r_{XY} = \frac{\text{Kov}_{XY}}{s_{X} \cdot s_{Y}}$ oder die Rangkorrelation berechnet werden.\footnote{\label{ftn:polycor}Das Paket \lstinline!polycor!\index[pack]{polycor@\lstinline{polycor}} \cite{Fox2010} beinhaltet Funktionen für die polychorische\index{Korrelation!polychorische} und polyseriale\index{Korrelation!polyseriale} Korrelation zur Schätzung der latenten Korrelation von künstlich in Kategorien eingeteilten Variablen, die eigentlich stetig sind. Für die multiple Korrelation i.\,S.\ der Wurzel aus dem Determinationskoeffizienten $R^{2}$ in der multiplen linearen Regression s.\ Abschn.\ \ref{sec:regrAnalysis}. Die\index{Korrelation!kanonische} kanonische Korrelation zweier Gruppen von Variablen, die an denselben Beobachtungsobjekten erhoben wurden, ermittelt\index[func]{cancor()@\lstinline{cancor()}} \lstinline!cancor()!.} Für die Korrelation gibt es keinen Unterschied beim Gebrauch von korrigierten und unkorrigierten Streuungen, so dass sich nur ein Kennwert ergibt.
\begin{lstlisting}
> cor(x, y)                     # Korrelation
[1] 0.8854667

> cov(x, y) / (sd(x) * sd(y))   # manuelle Berechnung
[1] 0.8854667
\end{lstlisting}

\index{Korrelation!Partialkorrelation}
\index{Partialkorrelation|see{Korrelation}}
Für die Berechnung der Partialkorrelation zweier Variablen $X$ und $Y$ ohne eine dritte Variable $Z$ kann die Formel $r_{(XY).Z} = \frac{r_{XY} - (r_{XZ} \cdot r_{YZ})}{\sqrt{(1-r_{XZ}^{2}) \cdot (1-r_{YZ}^{2})}}$ umgesetzt werden, da die Basisinstallation von R hierfür keine eigene Funktion bereitstellt.\footnote{Wohl aber das Paket\index[pack]{DescTools@\lstinline{DescTools}} \lstinline!DescTools! mit\index[func]{PartCor()@\lstinline{PartCor()}} \lstinline!PartCor()!.} Für eine alternative Berechnungsmethode, die sich die Eigenschaft der Partialkorrelation als Korrelation der Residuen der Regressionen von $X$ auf $Z$ und $Y$ auf $Z$ zunutze macht, s.\ Abschn.\ \ref{sec:partCorReg}.
\begin{lstlisting}
> NN <- 100
> zz <- runif(NN)
> xx <- zz + rnorm(NN, 0, 0.5)
> yy <- zz + rnorm(NN, 0, 0.5)
> (cor(xx, yy) - (cor(xx, zz)*cor(yy, zz))) /
+      sqrt((1-cor(xx, zz)^2) * (1-cor(yy, zz)^2))
[1] 0.0753442
\end{lstlisting}

\index{Korrelation!Semipartialkorrelation}
\index{Semipartialkorrelation|see{Korrelation}}
Die Semipartialkorrelation einer Variable $Y$ mit einer Variable $X$ ohne eine dritte Variable $Z$ unterscheidet sich von der Partialkorrelation dadurch, dass nur von $X$ der i.\,S.\ der linearen Regression durch $Z$ aufklärbare Varianzanteil auspartialisiert wird, nicht aber von $Y$. Die Semipartialkorrelation berechnet sich durch $r_{(X.Z)Y} = \frac{r_{XY} - (r_{XZ} \cdot r_{YZ})}{\sqrt{1-r_{XZ}^{2}}}$, oder als Korrelation von $Y$ mit den Residuen der Regression von $X$ auf $Z$ (Abschn.\ \ref{sec:partCorReg}).
\begin{lstlisting}
> (cor(xx, yy) - (cor(xx, zz) * cor(yy, zz))) / sqrt(1-cor(xx, zz)^2)
[1] 0.06275869
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Robuste Streuungsmaße und Kovarianzschätzer}
\label{sec:varRob}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{robuste Verfahren!Streuungsmaße}
Ausreißer können gewöhnliche Streuungen und Kovarianzen in dem Sinne stark verzerren, dass sie nicht mehr gut die Eigenschaften der zugrundeliegenden Verteilung der beteiligten Variablen repräsentieren. Aus diesem Grund existieren Streuungsmaße und Kovarianzschätzer, die weniger stark durch einzelne extreme Werte beeinflusst werden.

\index{Interquartilabstand}
\index[func]{IQR()@\lstinline{IQR()}}
Mit \lstinline!IQR(<<Vektor>>)! wird der Interquartilabstand erfragt, also die Differenz von drittem und erstem Quartil.
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> sd(age)                     # Vergleich: gewöhnliche Streuung
[1] 5.125102

> quantile(age)               # Quartile
   0%     25%   50%    75%   100%
17.00  21.50  24.00  28.75  30.00

> IQR(age)                    # Interquartilabstand
[1] 7.25
\end{lstlisting}

\index[func]{mad()@\lstinline{mad()}}
Die mittlere absolute Abweichung vom Mittelwert oder Median ist manuell oder über\index[func]{MeanAD()@\lstinline{MeanAD()}} \lstinline!MeanAD()! aus dem Paket\index[pack]{DescTools@\lstinline{DescTools}} \lstinline!DescTools! zu berechnen. Dagegen steht für den Median der absoluten Abweichungen vom Median \lstinline!mad(<<Vektor>>)! bereit.\footnote{Die Funktion multipliziert den eigentlichen Median der absoluten Abweichungen mit dem Faktor $1.4826$, der über das Argument \lstinline!constant! auf einen anderen Wert gesetzt werden kann. Der Faktor ist so gewählt, dass der Kennwert bei normalverteilten Variablen asymptotisch mit der Streuung übereinstimmt, da für standardnormalverteilte Variablen $X$ gilt: $E(\text{MAD}(X)) = 0.6745 = \frac{1}{1.4826}$.}
\begin{lstlisting}
> mean(abs(age - mean(age)))  # mittlere abs. Abweichung vom Mittelwert
[1] 4

> mean(abs(age-median(age)))  # mittlere absolute Abweichung vom Median
[1] 4

> mad(age)                    # Median der abs. Abweichungen vom Median
[1] 6.6717
\end{lstlisting}

\index{Varianz!winsorisierte}
Bei der Winsorisierung von Daten mit \lstinline!Winsorize()!\index[func]{Winsorize()@\lstinline{Winsorize()}} aus dem Paket \lstinline!DescTools!wird ein bestimmter Anteil an Extremwerten auf beiden Seiten der Verteilung durch jeweils den letzten Wert ersetzt, der noch nicht als Extremwert gilt. Dafür legt das Argument \lstinline!probs! in Form eines Vektors die beiden Quantile als Grenzen fest. Die übliche Varianz dieser Daten ist dann die winsorisierte Varianz.
\begin{lstlisting}
> library(DescTools)                            # für Winsorize()
> ageWins <- Winsorize(age, probs=c(0.2, 0.8)   # winsorisierte Daten
> var(ageWins)                                  # winsorisierte Varianz
[1] 17.2
\end{lstlisting}

\index{Kovarianz!robuste Schätzer}
\index{robuste Verfahren!Kovarianzschätzer}
Weitere robuste Streuungsschätzer stellt das Paket \lstinline!robustbase!\index[pack]{robustbase@\lstinline{robustbase}} mit \index[func]{Sn()@\lstinline{Sn()}} \lstinline!Sn()!, \index[func]{Qn()@\lstinline{Qn()}} \lstinline!Qn()! und \index[func]{scaleTau2()@\lstinline{scaleTau2()}} \lstinline!scaleTau2()! bereit. Für robuste Schätzer einer theoretischen Kovarianzmatrix vgl.\ \lstinline!covOGK()!\index[func]{covOGK()@\lstinline{covOGK()}} und\index[func]{covMcd()@\lstinline{covMcd()}} \lstinline!covMcd()! aus demselben Paket. Die mittlere absolute Differenz nach Gini kann mit \index[func]{GiniMd()@\lstinline{GiniMd()}} \lstinline!GiniMd()! aus dem Paket \lstinline!rms!\index[pack]{rms@\lstinline{rms}|textbf} \cite{HarrellJr2009} ermittelt werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kennwerte getrennt nach Gruppen berechnen}
\label{sec:tapply}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Funktion!getrennt nach Gruppen anwenden}
\index{Daten!getrennt nach Gruppen auswerten}
Oft sind die Werte einer in verschiedenen Bedingungen erhobenen Variable in einem Vektor \lstinline!x! gespeichert, wobei sich die zu jedem Wert gehörende Beobachtungsbedingung aus einem Faktor oder der Kombination mehrerer Faktoren ergibt. Jeder Faktor besitzt dabei dieselbe Länge wie \lstinline!x! und codiert die Zugehörigkeit der Beobachtungen in \lstinline!x! zu den Stufen einer Gruppierungsvariable. Dabei müssen nicht für jede Bedingung auch gleich viele Beobachtungen vorliegen.

Sollen Kennwerte von \lstinline!x! jeweils getrennt für jede Bedingung bzw.\ Kombination von Bedingungen berechnet werden, können\index[func]{ave()@\lstinline{ave()}} \lstinline!ave()! und\index[func]{tapply()@\lstinline{tapply()}} \lstinline!tapply()! herangezogen werden.
\begin{lstlisting}
> ave(x=<<Vektor>>, <<Faktor1>>, <<Faktor2>>, ...,
+     FUN=<<Funktion>>)

> tapply(X=<<Vektor>>, INDEX=<<Liste mit Faktoren>>,
+        FUN=<<Funktion>>, ...)
\end{lstlisting}

Als Argumente werden neben dem zuerst zu nennenden Datenvektor die Faktoren übergeben. Bei \lstinline!ave()! geschieht dies einfach in Form mehrerer durch Komma getrennter Gruppierungsfaktoren. Bei \lstinline!tapply()! müssen die Faktoren in einer Liste zusammengefasst werden, deren Komponenten die einzelnen Faktoren sind (Abschn.\ \ref{sec:list}). Mit dem Argument \lstinline!FUN! wird schließlich die pro Gruppe auf die Daten anzuwendende Funktion angegeben. Der Argumentname \lstinline!FUN! ist bei \lstinline!ave()! immer zu nennen, andernfalls wäre nicht ersichtlich, dass kein weiterer Faktor gemeint ist. In der Voreinstellung von \lstinline!ave()! wird \lstinline!mean()! angewendet.

In der Ausgabe von \lstinline!ave()! wird jeder Einzelwert von \lstinline!x! durch den für die entsprechende Gruppe berechneten Kennwert ersetzt, was etwa in der Berechnung von Quadratsummen linearer Modelle Anwendung finden kann (Abschn.\ \ref{sec:contrCRp}).

Im Beispiel sei ein IQ-Test mit Personen durchgeführt worden, die aus einer Treatment- (\lstinline!T!), Wartelisten- (\lstinline!WL!) oder Kontrollgruppe (\lstinline!CG!) stammen. Weiterhin sei das Geschlecht als Faktor berücksichtigt worden.
\begin{lstlisting}
> Njk   <- 2                            # Zellbesetzung
> P     <- 2                            # Anzahl Stufen Geschlecht
> Q     <- 3                            # Anzahl Stufen Treatment
> sex   <- factor(rep(c("f", "m"), times=Q*Njk))
> group <- factor(rep(c("T", "WL", "CG"), each=P*Njk))
> table(sex, group)                     # Zellbesetzungen
       group
sex  CG  T  WL
  f   2  2   2
  m   2  2   2

> IQ <- round(rnorm(Njk*P*Q, mean=100, sd=15))
> ave(IQ, sex, FUN=mean)                # Mittelwerte nach Geschlecht
[1] 96.83333 100.33333 96.83333 100.33333 96.83333 100.33333 96.83333
[8] 100.33333 96.83333 100.33333 96.83333 100.33333
\end{lstlisting}

\index{Mittelwertstabelle}
Die Ausgabe von \lstinline!tapply()! dient der Übersicht über die gruppenweise berechneten Kennwerte, wobei das Ergebnis ein Objekt der Klasse \lstinline!array! ist (Abschn.\ \ref{sec:array}). Bei einem einzelnen Gruppierungsfaktor ist dies einem benannten Vektor ähnlich und bei zweien einer zweidimensionalen Kreuztabelle (Abschn.\ \ref{sec:table}).
\begin{lstlisting}
> (tapRes <- tapply(IQ, group, FUN=mean))     # Mittelwert pro Gruppe
   CG      T      WL
94.25  99.75  101.75

# Mittelwert pro Bedingungskombination
> tapply(IQ, list(sex, group), FUN=mean)
     CG      T     WL
f  98.0   91.0  101.5
m  90.5  108.5  102.0
\end{lstlisting}

Wenn das Ergebnis ein eindimensionales array ist, lässt sich auch \lstinline!tapply()! dazu verwenden, um jeden Wert durch einen für seine Gruppe berechneten Kennwert zu ersetzen: Die Elemente der Ausgabe tragen dann als Namen die zugehörigen Gruppenbezeichnungen und lassen sich über diese Namen indizieren. Die als Indizes verwendbaren Gruppenbezeichnungen finden sich im Faktor, wobei jeder Index entsprechend der zugehörigen Gruppengröße mehrfach auftaucht.
\begin{lstlisting}
> tapRes[group]
    T     T     T     T     WL     WL     WL     WL    CG    CG    CG    CG
99.75 99.75 99.75 99.75 101.75 101.75 101.75 101.75 94.25 94.25 94.25 94.25
\end{lstlisting}

Da für \lstinline!FUN! beliebige Funktionen an \lstinline!tapply()! übergeben werden können, muss man sich nicht darauf beschränken, für Gruppen getrennt einzelne Kennwerte zu berechnen. Genauso sind Funktionen zugelassen, die pro Gruppe mehr als einen einzelnen Wert ausgeben, wobei das Ergebnis von \lstinline!tapply()! dann eine Liste ist (Abschn.\ \ref{sec:list}): Jede Komponente der Liste beinhaltet die Ausgabe von \lstinline!FUN! für eine Gruppe.

So ist es etwa auch möglich, sich die Werte jeder Gruppe selbst ausgeben zu lassen, indem man die Funktion\index[func]{identity()@\lstinline{identity()}} \lstinline!identity()! verwendet, die ihr Argument unverändert ausgibt (Abschn.\ \ref{sec:split} für \lstinline!split()!).
\begin{lstlisting}
> tapply(IQ, sex, FUN=identity)         # IQ-Werte pro Geschlecht
$f
[1] 100 82 88 115 86 110

$m
[1] 120 97 97 107 80 101

> split(IQ, sex)                        # Kontrolle ...
> IQ[sex == "f"]                        # Kontrolle ...
> IQ[sex == "m"]                        # Kontrolle ...
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktionen auf geordnete Paare von Werten anwenden}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{geordnete Paare}
\index[func]{outer()@\lstinline{outer()}}
Eine Verallgemeinerung der Anwendung einer Funktion auf jeden Wert eines Vektors stellt die Anwendung einer Funktion auf alle geordneten Paare aus den Werten zweier Vektoren dar.
\begin{lstlisting}
> outer(X=<<Vektor1>>, Y=<<Vektor2>>, FUN="*", ...)
\end{lstlisting}

Für die Argumente \lstinline!X! und \lstinline!Y! ist dabei jeweils ein Vektor einzutragen, unter \lstinline!FUN! eine Funktion, die zwei Argumente in Form von Vektoren verarbeiten kann.\footnote{Vor dem Aufruf von \lstinline!FUN! verlängert \lstinline!outer()! \lstinline!X! und \lstinline!Y! so, dass beide die Länge \lstinline!length(X)*length(Y)! besitzen und sich aus der Kombination der Elemente mit gleichem Index alle geordneten Paare ergeben.} Da Operatoren nur Funktionen mit besonderer Schreibweise sind, können sie hier ebenfalls eingesetzt werden, müssen dabei aber in Anführungszeichen stehen (Abschn.\ \ref{sec:funcParam}, Fußnote \ref{ftn:functional}). Voreinstellung ist die\index{ausseres Produkt@äußeres Produkt} Multiplikation, für diesen Fall existiert auch die Kurzform in Operatorschreibweise\index[func]{\%o\%@\texttt{\%o\%}} \lstinline!X %o% Y!\@. Sollen an \lstinline!FUN! weitere Argumente übergeben werden, kann dies an Stelle der \lstinline!...! geschehen, wobei mehrere Argumente durch Komma zu trennen sind. Die Ausgabe erfolgt in Form einer Matrix (Abschn.\ \ref{sec:matrix}).

Als Beispiel sollen alle Produkte der Zahlen 1--5 als Teil des kleinen $1 \times 1$ ausgegeben werden.
\begin{lstlisting}
> outer(1:5, 1:5, FUN="*")
     [,1]  [,2]  [,3]  [,4]  [,5]
[1,]    1     2     3     4     5
[2,]    2     4     6     8    10
[3,]    3     6     9    12    15
[4,]    4     8    12    16    20
[5,]    5    10    15    20    25
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Matrizen}
\label{sec:matrix}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!erstellen}
\index[func]{matrix()@\lstinline{matrix()}}
Wenn für jedes Beobachtungsobjekt Daten von mehreren Variablen vorliegen, könnten die Werte jeder Variable in einem separaten Vektor gespeichert werden. Eine andere Möglichkeit zur gemeinsamen Repräsentation aller Variablen bieten Objekte der Klasse \lstinline!matrix! als Spezialfall von arrays (Abschn.\ \ref{sec:array}).\footnote{Eine Matrix ist in R zunächst nur eine rechteckige Anordnung von Werten und nicht mit dem gleichnamigen mathematischen Konzept zu verwechseln. Wie \lstinline!attributes(<<Matrix>>)! zeigt, sind Matrizen intern lediglich Vektoren mit einem Attribut (Abschn.\ \ref{sec:objects}), das Auskunft über die Dimensionierung der Matrix, also die Anzahl ihrer Zeilen und Spalten liefert. Eine Matrix kann deshalb maximal so viele Werte speichern, wie ein Vektor Elemente besitzen kann (Abschn.\ \ref{sec:vector}, Fußnote \ref{ftn:vecDetails}). Für Rechenoperationen mit Matrizen im Kontext der linearen Algebra s.\ Abschn.\ \ref{sec:linAlg}.}
\begin{lstlisting}
> matrix(data=<<Vektor>>, nrow=<<Anzahl>>, ncol=<<Anzahl>>, byrow=FALSE)
\end{lstlisting}

Unter \lstinline!data! ist der Vektor einzutragen, der alle Werte der zu bildenden Matrix enthält. Mit \lstinline!nrow! wird die Anzahl der Zeilen dieser Matrix festgelegt, mit \lstinline!ncol! die der Spalten. Die Länge des Vektors muss gleich dem Produkt von \lstinline!nrow! und \lstinline!ncol! sein, das gleich der Zahl der Zellen ist. Mit dem auf \lstinline!FALSE! voreingestellten Argument \lstinline!byrow! wird die Art des Einlesens der Daten aus dem Vektor in die Matrix bestimmt -- es werden zunächst die Spalten nacheinander gefüllt. Mit \lstinline!byrow=TRUE! werden die Werte über die Zeilen eingelesen.
\begin{lstlisting}
> age <- c(17, 30, 30, 25, 23, 21)
> matrix(age, nrow=3, ncol=2, byrow=FALSE)
     [,1]  [,2]
[1,]   17    25
[2,]   30    23
[3,]   30    21

> (ageMat <- matrix(age, nrow=2, ncol=3, byrow=TRUE))
     [,1]  [,2]  [,3]
[1,]   17    30    30
[2,]   25    23    21
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datentypen in Matrizen}
\label{sec:matDataTypes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Datentypen}
\index{Datentyp!mischen}
Wie Vektoren können Matrizen verschiedene Datentypen besitzen, etwa \lstinline!numeric!, wenn sie Zahlen beinhalten, oder \lstinline!character! im Fall von Zeichenketten. Jede einzelne Matrix kann dabei aber ebenso wie ein Vektor nur einen einzigen Datentyp haben, alle Matrixelemente müssen also vom selben Datentyp sein. Fügt man einer numerischen Matrix eine Zeichenkette als Element hinzu, so werden die numerischen Matrixelemente automatisch in Zeichenketten umgewandelt, was an den hinzugekommenen Anführungszeichen zu erkennen ist.\footnote{Allgemein gesprochen werden alle Elemente in den umfassendsten Datentyp umgewandelt, der notwendig ist, um alle Werte ohne Informationsverlust zu speichern (Abschn.\ \ref{sec:dataTypes}).} Auf die ehemals numerischen Werte können dann keine Rechenoperationen mehr angewendet werden. Dieser Umstand macht Matrizen letztlich weniger geeignet für empirische Datensätze, für die stattdessen Objekte der Klasse \lstinline!data.frame! bevorzugt werden sollten (Abschn.\ \ref{sec:dataframe}).\footnote{Da Matrizen numerisch effizienter als Objekte der Klasse \lstinline!data.frame! verarbeitet werden können, sind sie dagegen bei der Analyse sehr großer Datenmengen vorzuziehen.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dimensionierung, Zeilen und Spalten}
\label{sec:asVecMat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Dimensionierung}
\index{Dimensionierung|see{Datensatz, Matrix}}
\index[func]{dim()@\lstinline{dim()}}
Die Dimensionierung einer Matrix (die Anzahl ihrer Zeilen und Spalten) liefert die Funktion \lstinline!dim(<<Matrix>>)!, die auch auf arrays (Abschn.\ \ref{sec:array}) oder Datensätze (Abschn.\ \ref{sec:dataframe}) anwendbar ist. Sie gibt einen Vektor aus, der die Anzahl der Zeilen und Spalten in dieser Reihenfolge als Elemente besitzt. Über\index[func]{nrow()@\lstinline{nrow()}} \lstinline!nrow(<<Matrix>>)! und\index[func]{ncol()@\lstinline{ncol()}} \lstinline!ncol(<<Matrix>>)! kann die Anzahl der Zeilen bzw.\ Spalten auch einzeln ausgegeben werden.
\begin{lstlisting}
> age    <- c(17, 30, 30, 25, 23, 21)
> ageMat <- matrix(age, nrow=2, ncol=3, byrow=FALSE)
> dim(ageMat)                       # Dimensionierung
[1] 2 3

> nrow(ageMat)                      # Anzahl der Zeilen
[1] 2

> ncol(ageMat)                      # Anzahl der Spalten
[1] 3

> prod(dim(ageMat))                 # Anzahl der Elemente
[1] 6
\end{lstlisting}

Eine Matrix wird mit \lstinline!t(<<Matrix>>)! transponiert, wodurch ihre Zeilen zu den Spalten der Transponierten und entsprechend ihre Spalten zu Zeilen der Transponierten werden.
\begin{lstlisting}
> t(ageMat)
     [,1]  [,2]
[1,]   17    30
[2,]   30    25
[3,]   23    21
\end{lstlisting}

\index{Matrix!Umwandlung in Matrix}
Wird ein Vektor über \lstinline!as.matrix(<<Vektor>>)! in eine Matrix umgewandelt, entsteht als Ergebnis eine Matrix mit einer Spalte und so vielen Zeilen, wie der Vektor Elemente enthält.
\begin{lstlisting}
> as.matrix(1:3)
     [,1]
[1,]    1
[2,]    2
[3,]    3
\end{lstlisting}

\index{Matrix!umwandeln}
Um eine Matrix in einen Vektor umzuwandeln, sollte entweder \lstinline!as.vector(<<Matrix>>)! oder einfach \lstinline!c(<<Matrix>>)! verwendet werden.\footnote{\lstinline!c()! entfernt die Attribute der übergebenen Argumente bis auf ihre Elementnamen. Matrizen verlieren damit ihre Dimensionierung \lstinline!dim! und ihre Klasse \lstinline!matrix!.} Die Anordnung der Elemente entspricht dabei dem Aneinanderhängen der Spalten der Matrix.
\begin{lstlisting}
> c(ageMat)
[1] 17 30 30 25 23 21
\end{lstlisting}

\index{Matrix!Zeilen- und Spaltenindex}
Mitunter ist es nützlich, zu einer gegebenen Matrix zwei zugehörige Matrizen zu erstellen, in denen jedes ursprüngliche Element durch seinen Zeilen- bzw.\ Spaltenindex ersetzt wurde. Dieses Ziel lässt sich mit den\index[func]{row()@\lstinline{row()}} \lstinline!row(<<Matrix>>)! und\index[func]{col()@\lstinline{col()}} \lstinline!col(<<Matrix>>)! erreichen.
\begin{lstlisting}
> P <- 2                            # Anzahl der Zeilen
> Q <- 3                            # Anzahl der Spalten
> (pqMat <- matrix(1:(P*Q), nrow=P, ncol=Q))
     [,1]  [,2]  [,3]
[1,]    1     3     5
[2,]    2     4     6

> (rowMat <- row(pqMat))            # Zeilenindizes
     [,1]  [,2]  [,3]
[1,]    1     1     1
[2,]    2     2     2

> (colMat <- col(pqMat))            # Spaltenindizes
     [,1]  [,2]  [,3]
[1,]    1     2     3
[2,]    1     2     3
\end{lstlisting}

Die so gewonnenen Matrizen können etwa dazu verwendet werden, eine dreispaltige Matrix zu erstellen, die in einer Spalte alle Elemente der ursprünglichen Matrix besitzt und in den anderen beiden Spalten die zugehörigen Zeilen- und Spaltenindizes enthält (Abschn.\ \ref{sec:matCbind}).
\begin{lstlisting}
> cbind(rowIdx=c(rowMat), colIdx=c(colMat), val=c(pqMat))
     rowIdx  colIdx  val
[1,]      1       1    1
[2,]      2       1    2
[3,]      1       2    3
[4,]      2       2    4
[5,]      1       3    5
[6,]      2       3    6
\end{lstlisting}

Eine andere Anwendungsmöglichkeit besteht darin, logische untere\index{Matrix!Dreiecksmatrix} bzw.\ obere Dreiecksmatrizen zu erstellen, die auch von\index[func]{lower.tri()@\lstinline{lower.tri()}} \lstinline!lower.tri()! und\index[func]{upper.tri()@\lstinline{upper.tri()}} \lstinline!upper.tri()! erzeugt werden können.
\begin{lstlisting}
> mat <- matrix(sample(1:10, 16, replace=TRUE), nrow=4, ncol=4)
> col(mat) >= row(mat)                          # obere Dreiecksmatrix
      [,1]   [,2]   [,3]  [,4]
[1,]  TRUE   TRUE   TRUE  TRUE
[2,] FALSE   TRUE   TRUE  TRUE
[3,] FALSE  FALSE   TRUE  TRUE
[4,] FALSE  FALSE  FALSE  TRUE
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elemente auswählen und verändern}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Elemente auswählen und verändern}
\index{Matrix!indizieren}
\index[func]{[]@\lstinline{[]}}
In einer Matrix ist es ähnlich wie bei einem Vektor möglich, sich einzelne Elemente mit dem \lstinline![<<Zeile>>, <<Spalte>>]! Operator anzeigen zu lassen. Der erste Index in der eckigen Klammer gibt dabei die Zeile des gewünschten Elements an, der zweite dessen Spalte.\footnote{Für Hilfe zu diesem Thema vgl.\ \lstinline!?Extract!.}
\begin{lstlisting}
> ageMat[2, 2]
[1] 25
\end{lstlisting}

Analog zum Vorgehen bei Vektoren können auch bei Matrizen einzelne Elemente unter Angabe ihres Zeilen- und Spaltenindex durch die Zuweisung eines Wertes verändert werden. Fehlt bei Zuweisungen der Index \lstinline!<<Matrix>>[]!, werden alle Elemente der Matrix ersetzt. Wenn der zugewiesene Vektor dabei weniger Elemente als die Matrix besitzt, wird er automatisch passend verlängert (Abschn.\ \ref{sec:recycling}).
\begin{lstlisting}
> ageMat[2, 2] <- 24
> ageMat[2, 2]
[1] 24

> ageMatCopy   <- ageMat          # zu verändernde Kopie der Matrix
> ageMatCopy[] <- c(1, 2, 3)      # Veränderung mit zykl. Verlängerung
> ageMatCopy
     [,1] [,2] [,3]
[1,]    1    3    2
[2,]    2    1    3
\end{lstlisting}

Man kann sich Zeilen oder Spalten auch vollständig ausgeben lassen. Dafür wird für die vollständig aufzulistende Dimension kein Index eingetragen, jedoch das Komma trotzdem gesetzt. Dabei können auch beide Dimensionen weggelassen werden, was für die Ausgabe denselben Effekt wie das gänzliche Weglassen des \lstinline![<<Index>>]! Operators hat. Um einzelne Zeilen oder Spalten zu entfernen, ist ihr Index mit vorangestelltem Minus-Zeichen zu verwenden.
\begin{lstlisting}
> ageMat[2, ]                     # Werte 2. Zeile
[1] 30 24 21

> ageMat[ , 1]                    # Werte 1. Spalte
[1] 17 30

> ageMat[ , ]                     # gesamte Matrix, äquivalent: ageMat[]
     [,1]  [,2]  [,3]
[1,]   17    30    23
[2,]   30    24    21

> ageMat[ , -1]                   # Werte bis auf 1. Spalte
     [,1] [,2]
[1,]   30   23
[2,]   25   21
\end{lstlisting}

Bei der Ausgabe einer einzelnen Zeile oder Spalte wird diese automatisch in einen Vektor umgewandelt, verliert also eine Dimension. Möchte man dies -- wie es häufig der Fall ist -- verhindern, kann beim \lstinline![<<Index>>]! Operator als weiteres Argument \lstinline!drop=FALSE!\index[func]{drop@\lstinline{drop}} angegeben werden. Das Ergebnis ist dann eine Matrix mit nur einer Zeile oder Spalte.\footnote{Dagegen bleibt \lstinline!ageMat[FALSE, FALSE]! eine leere Matrix mit $0$ Zeilen und $0$ Spalten.}
\begin{lstlisting}
> ageMat[ , 1, drop=FALSE]
     [,1]
[1,]   17
[2,]   30
\end{lstlisting}

Analog zum Vorgehen bei Vektoren können auch gleichzeitig mehrere Matrixelemente ausgewählt und verändert werden, indem man etwa eine Sequenz oder einen anderen Vektor als Indexvektor für eine Dimension festlegt.
\begin{lstlisting}
> ageMat[ , 2:3]                            # 2. und 3. Spalte
     [,1]  [,2]
[1,]   30    23
[2,]   24    21

> ageMat[ , c(1, 3)]                        # 1. und 3. Spalte
     [,1]  [,2]
[1,]   17    23
[2,]   30    21

> ageMatNew   <- ageMat
> (replaceMat <- matrix(c(11, 21, 12, 22), nrow=2, ncol=2))
     [,1]  [,2]
[1,]   11    12
[2,]   21    22

> ageMatNew[ , c(1, 3)] <- replaceMat       # ersetze Spalten 1 und 3
> ageMatNew
     [,1]  [,2]  [,3]
[1,]   11    30    12
[2,]   21    24    22
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Weitere Wege, Elemente auszuwählen und zu verändern}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Elemente auswählen und verändern}
\index{Matrix!indizieren}
Auf Matrixelemente kann auch zugegriffen werden, wenn nur ein einzelner Index genannt wird. Die Matrix wird dabei implizit in den Vektor der untereinander gehängten Spalten umgewandelt.
\begin{lstlisting}
> idxVec <- c(1, 3, 4)
> ageMat[idxVec]
[1] 17 30 24
\end{lstlisting}

Weiter können Matrizen auch durch eine logische Matrix derselben Dimensionierung -- etwa das Ergebnis eines logischen Vergleichs -- indiziert werden, die für jedes Element bestimmt, ob es ausgegeben werden soll. Das Ergebnis ist ein Vektor der ausgewählten Elemente.
\begin{lstlisting}
> (idxMatLog <- ageMat >= 25)
      [,1]   [,2]   [,3]
[1,] FALSE   TRUE  FALSE
[2,]  TRUE  FALSE  FALSE

> ageMat[idxMatLog]
[1] 30 30
\end{lstlisting}

Schließlich ist es möglich, eine zweispaltige numerische Indexmatrix zu verwenden, wobei jede Zeile dieser Matrix ein Element der indizierten Matrix auswählt -- der erste Eintrag einer Zeile gibt den Zeilenindex, der zweite den Spaltenindex des auszuwählenden Elements an. Eine solche Matrix entsteht etwa bei der Umwandlung einer logischen in eine numerische Indexmatrix mittels\index[func]{which()@\lstinline{which()}} \lstinline!which()! (Abschn.\ \ref{sec:which}), wenn das Argument \lstinline!arr.ind=TRUE! gesetzt ist. Auch hier ist das Ergebnis ein Vektor der ausgewählten Elemente.
\begin{lstlisting}
> (idxMatNum <- which(idxMatLog, arr.ind=TRUE))
     row  col
[1,]   2    1
[2,]   1    2

> ageMat[idxMatNum]
[1] 30 30
\end{lstlisting}

\lstinline!arrayInd(<<Indexvektor>>, dim(<<Matrix>>))!\index[func]{arrayInd()@\lstinline{arrayInd()}} konvertiert einen numerischen Indexvektor, der eine Matrix im obigen Sinn als Vektor indiziert, in eine zweispaltige numerische Indexmatrix.
\begin{lstlisting}
> (idxMat <- arrayInd(idxVec, dim(ageMat)))
     [,1]  [,2]
[1,]    1     1
[2,]    1     2
[3,]    2     2
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Matrizen verbinden}
\label{sec:matCbind}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!erstellen}
\index{Matrix!verbinden}
Die Funktionen\index[func]{cbind()@\lstinline{cbind()}|textbf} \lstinline!cbind(<<Vektor1>>, <<Vektor2>>, ...)! und\index[func]{rbind()@\lstinline{rbind()}} \lstinline!rbind(<<Vektor1>>, <<Vektor2>>, ...)! fügen Vektoren zu Matrizen zusammen. Das \lstinline!c! bei \lstinline!cbind()! steht für columns (Spalten), das \lstinline!r! entsprechend für rows (Zeilen). In diesem Sinn werden die Vektoren mit \lstinline!cbind()! spaltenweise nebeneinander, und mit \lstinline!rbind()! zeilenweise untereinander angeordnet.
\begin{lstlisting}
> age    <- c(19, 19, 19, 31, 24)
> weight <- c(95, 76, 76, 94, 76)
> height <- c(197, 179, 186, 189, 173)
> rbind(age, weight, height)
       [,1]  [,2]  [,3]  [,4]  [,5]
age      19    19    31    19    24
weight   95    76    94    76    76
height  197   178   189   184   173

> (mat <- cbind(age, weight, height))
     age  weight  height
[1,]  19      95     197
[2,]  19      76     178
[3,]  31      94     189
[4,]  19      76     184
[5,]  24      76     173
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Matrizen sortieren}
\label{sec:sortMat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!sortieren}
\index[func]{order()@\lstinline{order()}}
Die Zeilen von Matrizen können mit Hilfe von \lstinline!order()! entsprechend der Reihenfolge der Werte in einer ihrer Spalten sortiert werden. Die Funktion \lstinline!sort()! ist hier nicht anwendbar, ihr Einsatz ist auf Vektoren beschränkt.
\begin{lstlisting}
> order(<<Vektor>>, partial, decreasing=FALSE)
\end{lstlisting}

Für \lstinline!<<Vektor>>! ist die Spalte einer Datenmatrix einzutragen, deren Werte in eine Reihenfolge gebracht werden sollen. Unter \lstinline!decreasing! wird die Sortierreihenfolge eingestellt: In der Voreinstellung \lstinline!FALSE! wird aufsteigend sortiert, auf \lstinline!TRUE! gesetzt absteigend. Die Ausgabe ist ein Indexvektor, der die Zeilenindizes der zu ordnenden Matrix in der Reihenfolge der Werte des Sortierkriteriums enthält (Abschn.\ \ref{sec:revSortOrder}).\footnote{Die Funktion sortiert \emph{stabil}: Zeilen mit gleich großen Werten des Sortierkriteriums behalten ihre Reihenfolge relativ zueinander bei, werden also beim Sortiervorgang nicht zufällig vertauscht.}
\begin{lstlisting}
> (rowOrder1 <- order(mat[ , "age"]))       # Kriterium: Alter
[1] 1 2 4 5 3
\end{lstlisting}

Soll die gesamte Matrix entsprechend der Reihenfolge dieser Variable angezeigt werden, ist der von \lstinline!order()! ausgegebene Indexvektor zum Indizieren der Zeilen der Matrix zu benutzen. Dabei ist der Spaltenindex unter Beibehaltung des Kommas wegzulassen.
\begin{lstlisting}
> mat[rowOrder1, ]
     age  weight  height
[1,]  19      95     197
[2,]  19      76     178
[3,]  19      76     184
[4,]  24      76     173
[5,]  31      94     189
\end{lstlisting}

Mit dem Argument \lstinline!partial! kann noch eine weitere Matrixspalte eingetragen werden, die dann als sekundäres Sortierkriterium verwendet wird. So kann eine Matrix etwa zunächst hinsichtlich einer die Gruppenzugehörigkeit darstellenden Variable sortiert werden und dann innerhalb jeder Gruppe nach der Reihenfolge der Werte einer anderen Variable. Es können noch weitere Sortierkriterien durch Komma getrennt als Argumente vorhanden sein, es gibt also keine Beschränkung auf nur zwei solcher Kriterien.
\begin{lstlisting}
# sortiere primär nach Alter und sekundär nach Gewicht
> rowOrder2 <- order(mat[ , "age"], partial=mat[ , "weight"])
> mat[rowOrder2, ]
     age  weight  height
[1,]  19      76     178
[2,]  19      76     184
[3,]  19      95     197
[4,]  24      76     173
[5,]  31      94     189
\end{lstlisting}

Das Argument \lstinline!decreasing! legt global für alle Sortierkriterien fest, ob auf- oder absteigend sortiert wird. Soll die Sortierreihenfolge dagegen zwischen den Kriterien variieren, kann einzelnen numerischen Kriterien ein \lstinline!-! vorangestellt werden, was als Umkehrung der mit \lstinline!decreasing! eingestellten Reihenfolge zu verstehen ist.
\begin{lstlisting}
# sortiere aufsteigend nach Gewicht und absteigend nach Größe
> rowOrder3 <- order(mat[ , "weight"], -mat[ , "height"])
> mat[rowOrder3, ]
     age  weight  height
[1,]  19      76     184
[2,]  19      76     178
[3,]  24      76     173
[4,]  31      94     189
[5,]  19      95     197
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Randkennwerte berechnen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Randkennwerte}
Die Summe aller Elemente einer numerischen Matrix lässt sich mit \lstinline!sum(<<Matrix>>)!, die separat über jede Zeile oder jede Spalte gebildeten Summen durch\index[func]{rowSums()@\lstinline{rowSums()}} \lstinline!rowSums(<<Matrix>>)!\index[func]{colSums()@\lstinline{colSums()}} bzw.\ \lstinline!colSums(<<Matrix>>)! berechnen. Gleiches gilt für den Mittelwert aller Elemente, der mit \lstinline!mean(<<Matrix>>)! ermittelt wird und die mit\index[func]{rowMeans()@\lstinline{rowMeans()}} \lstinline!rowMeans()!\index[func]{colMeans()@\lstinline{colMeans()}} bzw.\ \lstinline!colMeans()! separat über jede Zeile oder jede Spalte berechneten Mittelwerte.
\begin{lstlisting}
> sum(mat)                                # Summe aller Elemente
[1] 1450

> rowSums(mat)                            # Summen jeder Zeile
[1] 311 273 314 279 273

> mean(mat)                               # Mittelwert aller Elemente
[1] 96.66667

> colMeans(mat)                           # Mittelwerte jeder Spalte
 age  weight  height
22.4    83.4   184.2
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Beliebige Funktionen auf Matrizen anwenden}
\label{sec:apply}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!Funktionen anwenden}
\index[func]{apply()@\lstinline{apply()}}
Wenn eine andere Funktion als die Summe oder der Mittelwert separat auf jeweils jede Zeile oder jede Spalte angewendet werden soll, ist dies mit \lstinline!apply()! zu erreichen.
\begin{lstlisting}
> apply(X=<<Matrix>>, MARGIN=<<Nummer>>, FUN=<<Funktion>>, ...)
\end{lstlisting}

\lstinline!X! erwartet die Matrix der zu verarbeitenden Daten. Unter \lstinline!MARGIN! wird angegeben, ob die Funktion Kennwerte der Zeilen (\lstinline!1!) oder Spalten (\lstinline!2!) berechnet. Für \lstinline!FUN! ist die anzuwendende Funktion einzusetzen, die als Argument einen Vektor akzeptieren muss. Gibt sie mehr als einen Wert zurück, ist das Ergebnis eine Matrix mit den Rückgabewerten von \lstinline!FUN! in den Spalten. Die drei Punkte \lstinline!...! stehen für optionale, ggf.\ durch Komma getrennte Argumente von \lstinline!FUN!, die an diese Funktion weitergereicht werden.
\begin{lstlisting}
> apply(mat, 2, sum)                      # Summen jeder Spalte
age  weight  height
112     417     921

> apply(mat, 1, max)                      # Maxima jeder Zeile
[1] 197 178 189 184 173

> apply(mat, 1, range)                    # Range jeder Zeile
     [,1]  [,2]  [,3]  [,4]  [,5]
[1,]   19    19    31    19    24
[2,]  197   178   189   184   173

> apply(mat, 2, mean, trim=0.1)   # gestutzte Mittelwerte jeder Spalte
 age  weight  height
22.4    83.4   184.2
\end{lstlisting}

Im letzten Beispiel wird das für \lstinline!...! eingesetzte Argument \lstinline!trim=0.1! an \lstinline!mean()! weitergereicht.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Matrix zeilen- oder spaltenweise mit Kennwerten verrechnen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Matrix!mit Kennwert verrechnen}
Zeilen- und Spaltenkennwerte sind häufig Zwischenergebnisse, die für weitere Berechnungen mit einer Matrix nützlich sind. So ist es etwa zum spaltenweisen\index{Matrix!zentrieren} Zentrieren einer Matrix notwendig, von jedem Wert den zugehörigen Spaltenmittelwert abzuziehen. Anders gesagt soll die Matrix dergestalt mit einem Vektor verrechnet werden, dass auf jede Spalte dieselbe Operation (hier: Subtraktion), aber mit einem anderen Wert angewendet wird -- nämlich mit dem Element des Vektors der Spaltenmittelwerte, das dieselbe Position im Vektor besitzt wie die Spalte in der Matrix. Die genannte Operation lässt sich mit\index[func]{sweep()@\lstinline{sweep()}} \lstinline!sweep()! durchführen.
\begin{lstlisting}
> sweep(x=<<Matrix>>, MARGIN=<<Nummer>>, STATS=<<Kennwerte>>, FUN=<<Funktion>>, ...)
\end{lstlisting}

Das Argument \lstinline!x! erwartet die Matrix der zu verarbeitenden Daten. Unter \lstinline!MARGIN! wird angegeben, ob die Funktion jeweils Zeilen (\lstinline!1!) oder Spalten (\lstinline!2!) mit den Kennwerten verrechnet. An \lstinline!STATS! sind diese Kennwerte in Form eines Vektors mit so vielen Einträgen zu übergeben, wie \lstinline!x! Zeilen (\lstinline!MARGIN=1!) bzw.\ Spalten (\lstinline!MARGIN=2!) besitzt. Für \lstinline!FUN! ist die anzuwendende Funktion einzusetzen, Voreinstellung ist die Subtraktion \lstinline!"-"!. Die drei Punkte \lstinline!...! stehen für optionale, ggf.\ durch Komma getrennte Argumente von \lstinline!FUN!, die an diese Funktion weitergereicht werden.

Im Beispiel sollen die Daten einer Matrix erst zeilenweise, dann spaltenweise zentriert werden.
\begin{lstlisting}
> Mj <- rowMeans(mat)                       # Mittelwerte der Zeilen
> Mk <- colMeans(mat)                       # Mittelwerte der Spalten
> sweep(mat, 2, Mk, "-")                    # spaltenweise zentrieren
      age  weight  height
[1,] -3.4    11.6    12.8
[2,] -3.4    -7.4    -6.2
[3,]  8.6    10.6     4.8
[4,] -3.4    -7.4    -0.2
[5,]  1.6    -7.4   -11.2

> scale(mat, center=TRUE, scale=FALSE)      # Kontrolle mit scale() ...
> sweep(mat, 1, Mj, "-")                    # zeilenweise zentrieren
           age     weight    height
[1,] -84.66667  -8.666667  93.33333
[2,] -72.00000 -15.000000  87.00000
[3,] -73.66667 -10.666667  84.33333
[4,] -74.00000 -17.000000  91.00000
[5,] -67.00000 -15.000000  82.00000

> t(scale(t(mat), center=TRUE, scale=FALSE))  # Kontrolle mit scale()
# ...
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kovarianz- und Korrelationsmatrizen}
\label{sec:covMat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Kovarianz!Kovarianzmatrix}
\index{Korrelation!Korrelationsmatrix}
Zum Erstellen von Kovarianz- und Korrelationsmatrizen können die aus Abschn.\ \ref{sec:covCor} bekannten Funktionen \lstinline!cov(<<Matrix>>)!\index[func]{cov()@\lstinline{cov()}} und\index[func]{cor()@\lstinline{cor()}} \lstinline!cor(<<Matrix>>)! verwendet werden, wobei die Werte in Form einer Matrix mit Variablen in den Spalten übergeben werden müssen. \lstinline!cov()! liefert die korrigierte Kovarianzmatrix.
\begin{lstlisting}
> cov(mat)                                      # Kovarianzmatrix
         age  weight  height
age    27.80   22.55     0.4
weight 22.55  102.80    82.4
height  0.40   82.40    87.7

> cor(mat)                                      # Korrelationsmatrix
               age     weight       height
age    1.000000000  0.4218204  0.008100984
weight 0.421820411  1.0000000  0.867822404
height 0.008100984  0.8678224  1.000000000
\end{lstlisting}

\index{Kovarianz!unkorrigierte}
\index{Varianz!unkorrigierte}
\index[func]{cov.wt()@\lstinline{cov.wt()}}
\lstinline!cov2cor(<<K>>)!\index[func]{cov2cor()@\lstinline{cov2cor()}} wandelt eine korrigierte Kovarianzmatrix $\bm{K}$ in eine Korrelationsmatrix um. Analog erzeugt \lstinline!cor2cov(<<R>>, <<s>>)!\index[func]{cor2cov()@\lstinline{cor2cov()}} aus dem Paket\index[pack]{MBESS@\lstinline{MBESS}|textbf} \lstinline!MBESS! \cite{Kelley2010} aus einer Korrelationsmatrix $\bm{R}$ und einem Vektor der Streuungen $\bm{s}$ der Variablen die zugehörige Kovarianzmatrix. Weiterhin existiert mit \lstinline!cov.wt()! eine Funktion, die direkt die unkorrigierte Kovarianzmatrix ermitteln kann.
\begin{lstlisting}
> cov.wt(x=<<Matrix>>, method=c("unbiased", "ML"))
\end{lstlisting}

Unter \lstinline!x! ist die Matrix einzutragen, von deren Spalten paarweise die Kovarianz bestimmt werden soll. Um diese Funktion auf einen einzelnen Vektor anwenden zu können, muss dieser zunächst mit \lstinline!as.matrix(<<Vektor>>)! in eine einspaltige Matrix konvertiert werden. Mit \lstinline!method! lässt sich wählen, ob die korrigierten oder unkorrigierten Varianzen und Kovarianzen ausgerechnet werden -- Voreinstellung ist \lstinline!"unbiased"! für die korrigierten Kennwerte. Sind die unkorrigierten Kennwerte gewünscht, ist \lstinline!"ML"! zu wählen, da sie bei normalverteilten Variablen die Maximum-Likelihood-Schätzung der theoretischen Parameter auf Basis einer Stichprobe darstellen.

Das Ergebnis der Funktion ist eine Liste (Abschn.\ \ref{sec:list}), die die Kovarianzmatrix als Komponente \lstinline!cov!, die Mittelwerte als Komponente \lstinline!center! und die Anzahl der eingegangenen Fälle als Komponente \lstinline!n.obs! (number of observations) besitzt.
\begin{lstlisting}
> cov.wt(mat, method="ML")
$cov
         age  weight  height
age    22.24   18.04    0.32
weight 18.04   82.24   65.92
height  0.32   65.92   70.16

$center
 age  weight  height
22.4    83.4   184.2

$n.obs
[1] 5
\end{lstlisting}

Mit \lstinline!diag(<<Matrix>>)! lassen sich aus einer Kovarianzmatrix die in der Diagonale stehenden Varianzen extrahieren (Abschn.\ \ref{sec:matAlg}).
\begin{lstlisting}
> diag(cov(mat))
 age  weight  height
27.8   102.8    87.7
\end{lstlisting}

Um gleichzeitig die Kovarianz oder Korrelation einer durch \lstinline!<<Vektor>>! gegebenen Variable mit mehreren anderen, spaltenweise zu einer Matrix zusammengefassten Variablen zu berechnen, dient der Aufruf \lstinline!cov(<<Matrix>>, <<Vektor>>)! bzw.\ \lstinline!cor(<<Matrix>>, <<Vektor>>)!. Das Ergebnis ist eine Matrix mit so vielen Zeilen, wie das erste Argument Spalten besitzt.
\begin{lstlisting}
> vec <- rnorm(nrow(mat))
> cor(mat, vec)
             [,1]
age    -0.1843847
weight -0.6645798
height -0.6503452
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Arrays}
\label{sec:array}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{array}
\index[func]{array()@\lstinline{array()}}
Das Konzept der Speicherung von Daten in eindimensionalen Vektoren und zweidimensionalen Matrizen lässt sich mit der Klasse \lstinline!array! auf höhere Dimensionen verallgemeinern. In diesem Sinne sind Vektoren und Matrizen ein- bzw.\ zweidimensionale Spezialfälle von arrays, weshalb sich arrays in allen wesentlichen Funktionen auch wie Matrizen verhalten. So müssen die in einem array gespeicherten Werte alle denselben Datentyp aufweisen, wie es auch bei Vektoren und Matrizen der Fall ist (Abschn.\ \ref{sec:matDataTypes}).\footnote{So, wie sich Matrizen mit \lstinline!cbind()! und \lstinline!rbind()! aus Vektoren zusammenstellen lassen, ermöglicht\index[func]{abind()@\lstinline{abind()}} \lstinline!abind()! aus dem gleichnamigen Paket\index[pack]{abind@\lstinline{abind}} \cite{Plate2004} das Verbinden von Matrizen zu einem array.}
\begin{lstlisting}
> array(data=<<Vektor>>, dim=length(data), dimnames=NULL)
\end{lstlisting}

Für \lstinline!data! ist ein Datenvektor mit den Werten anzugeben, die das array speichern soll. Mit \lstinline!dim! wird die Dimensionierung festgelegt, also die Anzahl der Dimensionen und der Werte pro Dimension. Dies geschieht mit Hilfe eines Vektors, der pro Dimension ein Element beinhaltet, das die Anzahl der zugehörigen Werte spezifiziert. Das Argument \lstinline!dim=c(2, 3, 4)! würde etwa festlegen, dass das array zwei Zeilen, drei Spalten und vier Schichten umfassen soll. Ein dreidimensionales array lässt sich nämlich als Quader vorstellen, der aus mehreren zweidimensionalen Matrizen besteht, die in Schichten hintereinander gereiht sind. Das Argument \lstinline!dimnames! dient dazu, die Dimensionen und die einzelnen Stufen in jeder Dimension gleichzeitig mit Namen zu versehen. Dies geschieht unter Verwendung einer Liste (Abschn.\ \ref{sec:list}), die für jede Dimension eine Komponente in Form eines Vektors mit den gewünschten Bezeichnungen der einzelnen Stufen besitzt. Die Namen der Dimensionen selbst können über die Benennung der Komponenten der Liste festgelegt werden.

Als Beispiel soll die Kontingenztafel dreier kategorialer Variablen dienen: Geschlecht mit zwei und zwei weitere Variablen mit drei bzw.\ zwei Stufen. Ein dreidimensionales array wird durch separate zweidimensionale Matrizen für jede Stufe der dritten Dimension ausgegeben.
\begin{lstlisting}
> (myArr1 <- array(1:12, c(2, 3, 2), dimnames=list(row=c("f", "m"),
+                  column=c("CG", "WL", "T"), layer=c("high", "low"))))
, , layer = high
      column
row  CG  WL  T
  f   1   3  5
  m   2   4  6

, , layer = low
      column
row  CG  WL   T
  f   7   9  11
  m   8  10  12
\end{lstlisting}

Das array wird durch die mit dem Vektor \lstinline!1:12! bereitgestellten Daten in Reihenfolge der Dimensionen aufgefüllt: zunächst alle Zeilen der ersten Spalte der ersten Schicht, dann in diesem Muster alle Spalten der ersten Schicht und zuletzt in diesem Muster alle Schichten. Auf arrays lassen sich mit \lstinline!apply()! wie bei Matrizen beliebige Funktionen in Richtung der einzelnen Dimensionen anwenden.

Arrays lassen sich analog zu Matrizen mit dem \lstinline![<<Index>>]!\index[func]{[]@\lstinline{[]}} Operator indizieren, wobei die Indizes für die zusätzlichen Dimensionen durch Komma getrennt hinzugefügt werden.
\begin{lstlisting}
> myArr1[1, 3, 2]         # Element in 1. Zeile, 3. Spalte, 2. Schicht
[1] 11

> myArr2 <- myArr1*2
> myArr2[ , , "high"]     # zeige nur 1. Schicht
     column
row  CG  WL   T
  f   2   6  10
  m   4   8  12
\end{lstlisting}

\index[func]{aperm()@\lstinline{aperm()}}
Ähnlich wie sich bei Matrizen durch Transponieren mit \lstinline!t()! Zeilen und Spalten vertauschen lassen, können mit \lstinline!aperm()! auch bei arrays Dimensionen ausgetauscht werden.
\begin{lstlisting}
> aperm(a=<<array>>, perm=<<Vektor>>)
\end{lstlisting}

Unter \lstinline!a! ist das zu transformierende $n$-dimensionale array anzugeben. \lstinline!perm! legt in Form eines Vektors mit den Elementen $1$ bis $n$ fest, welche Dimensionen vertauscht werden sollen. Im Fall benannter Dimensionen kann \lstinline!perm! alternativ auch deren Namen enthalten. Die Position eines Elements von \lstinline!perm! bezieht sich auf die alte Dimension, das Element selbst bestimmt, zu welcher neuen Dimension die alte gemacht wird. Sollen in einem dreidimensionalen array die Schichten zu Zeilen (und umgekehrt) werden, wäre \lstinline!perm=c(3, 2, 1)! zu setzen. Das Vertauschen von Zeilen und Spalten wäre mit \lstinline!perm=c(2, 1, 3)! zu erreichen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Häufigkeitsauszählungen}
\label{sec:table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Bei der Analyse kategorialer Variablen besteht ein typischer Auswertungsschritt darin, die Auftretenshäufigkeiten der Kategorien auszuzählen und relative sowie bedingte relative Häufigkeiten zu berechnen. Wird nur eine Variable betrachtet, ergeben sich einfache Häufigkeitstabellen, bei mehreren Variablen mehrdimensionale Kontingenztafeln der gemeinsamen Häufigkeiten.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Einfache Tabellen absoluter und relativer Häufigkeiten}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!absolute}
\index[func]{table()@\lstinline{table()}}
Eine Tabelle der absoluten Häufigkeiten von Variablenwerten erstellt \lstinline!table(<<Faktor>>)! und erwartet dafür als Argument ein eindimensionales Objekt, das sich als Faktor interpretieren lässt, z.\,B.\ einen Vektor. Das Ergebnis ist eine Übersicht über die Auftretenshäufigkeit jeder vorkommenden Ausprägung, wobei fehlende Werte ignoriert werden.\footnote{Enthält der zu tabellierende Vektor fehlende Werte, können diese mit in die Auszählung einbezogen werden, indem der Vektor in\index[func]{addNA()@\lstinline{addNA()}} \lstinline!addNA()! eingeschlossen wird.}
\begin{lstlisting}
> (myLetters <- sample(LETTERS[1:5], 12, replace=TRUE))
[1] "C" "D" "A" "D" "E" "D" "C" "E" "E" "B" "E" "E"

> (tab <- table(myLetters))
myLetters
A  B  C  D  E
1  1  2  3  5
\end{lstlisting}

In der oberen Zeile der Ausgabe sind die Ausprägungen der Variable, in der unteren Zeile die jeweils zugehörigen Auftretenshäufigkeiten aufgeführt. Eindimensionale Häufigkeitstabellen verhalten sich wie Vektoren mit benannten Elementen, wobei die Benennungen den vorhandenen Ausprägungen der Variable entsprechen. Die Ausprägungen lassen sich mit dem Befehl \lstinline!names(<<Tabelle>>)! separat ausgeben.
\begin{lstlisting}
> names(tab)
[1] "A" "B" "C" "D" "E"

> tab["B"]
B
1
\end{lstlisting}

\index{Haufigkeiten@Häufigkeiten!relative}
\index{Haufigkeiten@Häufigkeiten!kumulierte relative}
\index[func]{prop.table()@\lstinline{prop.table()}}
Relative Häufigkeiten ergeben sich durch Division der absoluten Häufigkeiten mit der Gesamtzahl der Beobachtungen. Für diese Rechnung existiert die Funktion \lstinline!prop.table(<<Tabelle>>)!, welche als Argument eine Tabelle der absoluten Häufigkeiten erwartet und die relativen Häufigkeiten ausgibt. Durch Anwendung von \lstinline!cumsum()! auf das Ergebnis erhält man die kumulierten relativen Häufigkeiten (für eine andere Methode und die Berechnung von Prozenträngen s.\ Abschn.\ \ref{sec:stepfun}).
\begin{lstlisting}
> (relFreq <- prop.table(table(myLetters)))
myLetters
         A           B           C           D           E
0.08333333  0.08333333  0.16666667  0.25000000  0.41666667

> cumsum(relFreq)               # kumulierte relative Häufigkeiten
         A           B           C           D           E
0.08333333  0.16666667  0.33333333  0.58333333  1.00000000
\end{lstlisting}

Kommen mögliche Variablenwerte in einem Vektor nicht vor, so tauchen sie auch in einer mit \lstinline!table()! erstellten Häufigkeitstabelle nicht als ausgezählte Kategorie auf. Um deutlich zu machen, dass Variablen außer den tatsächlich vorhandenen Ausprägungen potentiell auch weitere Werte annehmen, kann auf zweierlei Weise vorgegangen werden: So können die möglichen, tatsächlich aber nicht auftretenden Werte der Häufigkeitstabelle nachträglich mit der Häufigkeit $0$ hinzugefügt werden.
\begin{lstlisting}
> tab["Q"] <- 0
> tab
A  B  C  D  E  Q
1  1  2  3  5  0
\end{lstlisting}

Beim Hinzufügen von Werten zur Tabelle werden diese ans Ende angefügt. Geht dadurch die natürliche Reihenfolge der Ausprägungen verloren, kann die Tabelle z.\,B.\ mittels eines durch \lstinline!order(names(<<Tabelle>>))! erstellten Vektors der geordneten Indizes sortiert werden.
\begin{lstlisting}
> tabOrder <- order(names(tab))
> tab[tabOrder]                         # ...
\end{lstlisting}

Alternativ zur Veränderung der Tabelle selbst können die Daten vorab in einen Faktor umgewandelt werden. Dem Faktor lässt sich dann der nicht auftretende, aber prinzipiell mögliche Wert als weitere Stufe hinzufügen.
\begin{lstlisting}
> letFac <- factor(myLetters, levels=c(LETTERS[1:5], "Q"))
> letFac
[1] C D A D E D C E E B E E
Levels: A B C D E Q

> table(letFac)
letFac
A  B  C  D  E  Q
1  1  2  3  5  0
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Iterationen zählen}
\label{sec:runs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!Iterationen}
\index{Iterationen|see{Häufigkeiten}}
\index[func]{rle()@\lstinline{rle()}}
Unter einer \emph{Iteration} innerhalb einer linearen Sequenz von Symbolen ist ein Abschnitt zu verstehen, der aus der ein- oder mehrfachen Wiederholung desselben Symbols besteht (\emph{run}). Iterationen werden durch Iterationen eines anderen Symbols begrenzt, oder besitzen kein vorangehendes bzw.\ auf sie folgendes Symbol. Die Iterationen eines Vektors zählt die \lstinline!rle(<<Vektor>>)! Funktion, deren Ergebnis eine Liste mit zwei Komponenten ist: Die erste Komponente \lstinline!lengths! ist ein Vektor, der die jeweilige Länge jeder Iteration als Elemente besitzt. Die zweite Komponente \lstinline!values! ist ein Vektor mit den Symbolen, um die es sich bei den Iterationen handelt (Abschn.\ \ref{sec:list}).
\begin{lstlisting}
> (vec <- rep(rep(c("f", "m"), 3), c(1, 3, 2, 4, 1, 2)))
[1] "f" "m" "m" "m" "f" "f" "m" "m" "m" "m" "f" "m" "m"

> (res <- rle(vec))
Run Length Encoding
lengths: int [1:6] 1 3 2 4 1 2
values : chr [1:6] "f" "m" "f" "m" "f" "m"

> length(res$lengths)                 # zähle Anzahl der Iterationen
[1] 6
\end{lstlisting}

\index[func]{inverse.rle()@\lstinline{inverse.rle()}}
Aus der jeweiligen Länge und dem wiederholten Symbol jeder Iteration lässt sich die ursprüngliche Sequenz eindeutig rekonstruieren. Dies kann durch die \lstinline!inverse.rle(<<rle-Ergebnis>>)! Funktion geschehen, die eine Liste erwartet, wie sie \lstinline!rle()! als Ergebnis besitzt.
\begin{lstlisting}
> inverse.rle(res)
[1] "f" "m" "m" "m" "f" "f" "m" "m" "m" "m" "f" "m" "m"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Absolute, relative und bedingte relative Häufigkeiten in Kreuztabellen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!Kreuztabelle}
\index{Kreuztabelle|see{Häufigkeiten}}
\index{Kontingenztafel|see{Häufigkeiten}}
Statt die Häufigkeiten der Werte nur einer einzelnen Variable zu ermitteln, können mit \lstinline!table(<<Faktor1>>, <<Faktor2>>, ...)! auch mehrdimensionale Kontingenztafeln erstellt werden. Die Elemente der Faktoren an gleicher Position werden als denselben Beobachtungsobjekten zugehörig interpretiert. Das erste Element von \lstinline!<<Faktor1>>! bezieht sich also auf dieselbe Beobachtung wie das erste Element von \lstinline!<<Faktor2>>!, usw. Das Ergebnis ist eine Kreuztabelle mit den gemeinsamen absoluten Häufigkeiten der Merkmale, wobei die Ausprägungen des ersten Faktors in den Zeilen stehen.

Als Beispiel sollen Personen betrachtet werden, die nach ihrem Geschlecht und dem Ort ihres Arbeitsplatzes unterschieden werden. An diesen Personen sei weiterhin eine Variable erhoben worden, die die absolute Häufigkeit eines bestimmten Ereignisses codiert.
\begin{lstlisting}
> N     <- 10
> (work <- factor(sample(c("home", "office"), N, replace=TRUE)))
[1] home office office home home office office office office office
Levels: home office

> (sex <- factor(sample(c("f", "m"), N, replace=TRUE)))
[1] f m f m m f m f m m
Levels: f m

> (counts <- sample(0:5, N, replace=TRUE))
[1] 0 3 3 1 1 1 3 5 2 4

# gemeinsame absolute Häufigkeiten von Geschlecht und Arbeitsplatz
> (absFreq <- table(sex, work))
        work
sex  home  office
  f     1       3
  m     2       4
\end{lstlisting}

\index{Haufigkeiten@Häufigkeiten!bedingte relative}
Um relative Häufigkeiten auf Basis von Kreuztabellen absoluter Häufigkeiten zu ermitteln, eignet sich die \lstinline!prop.table()! Funktion. Für bedingte relative Häufigkeiten besitzt sie ein zweites Argument \lstinline!margin=<<Nummer>>!, an das etwa \lstinline!1! zur Bestimmung der auf die Zeilen bezogenen bedingten relativen Häufigkeiten übergeben werden kann. Jede Zeile der Tabelle relativer Häufigkeiten wird dann durch die zugehörige Zeilensumme dividiert, was sich manuell auch durch \lstinline!sweep()! erreichen ließe. Mit \lstinline!margin=2! erhält man analog die auf die Spalten bezogenen bedingten relativen Häufigkeiten.
\begin{lstlisting}
> (relFreq <- prop.table(absFreq))          # relative Häufigkeiten
        work
sex  home  office
  f   0.1     0.3
  m   0.2     0.4

> prop.table(absFreq, 1)        # auf Zeilen bedingte rel. Häufigk.
              work
sex       home     office
  f  0.2500000  0.7500000
  m  0.3333333  0.6666667

> prop.table(absFreq, 2)        # auf Spalten bedingte rel. Häufigk.
              work
sex       home     office
  f  0.3333333  0.4285714
  m  0.6666667  0.5714286

# manuelle Kontrolle
> rSums <- rowSums(relFreq)     # Zeilensummen
> cSums <- colSums(relFreq)     # Spaltensummen
> sweep(relFreq, 1, rSums, "/") # auf Zeilen bedingte rel. Häufigk. ...
> sweep(relFreq, 2, cSums, "/") # auf Spalten bedingte rel. Häufigk. ...
\end{lstlisting}

Um Häufigkeitsauszählungen für mehr als zwei Variablen zu berechnen, können beim Aufruf von \lstinline!table()! einfach weitere Faktoren durch Komma getrennt hinzugefügt werden. Die Ausgabe verhält sich dann wie ein array. Hierbei werden etwa im Fall von drei Variablen so viele zweidimensionale Kreuztabellen ausgegeben, wie Stufen der dritten Variable vorhanden sind. Soll dagegen auch in diesem Fall eine einzelne Kreuztabelle mit verschachteltem Aufbau erzeugt werden, ist\index[func]{ftable()@\lstinline{ftable()}} \lstinline!ftable()! (\emph{flat table}) zu nutzen.
\begin{lstlisting}
> ftable(x, row.vars=NULL, col.vars=NULL)
\end{lstlisting}

Unter \lstinline!x! kann entweder eine bereits mit \lstinline!table()! erzeugte Kreuztabelle eingetragen werden, oder aber eine durch Komma getrennte Reihe von Faktoren bzw.\ von Objekten, die sich als Faktor interpretieren lassen. Die Argumente \lstinline!row.vars! und \lstinline!col.vars! kontrollieren, welche Variablen in den Zeilen und welche in den Spalten angeordnet werden. Beide Argumente akzeptieren numerische Vektoren mit den Nummern der entsprechenden Variablen, oder aber Vektoren aus Zeichenketten, die den Namen der Faktoren entsprechen.
\begin{lstlisting}
> (group <- factor(sample(c("A", "B"), 10, replace=TRUE)))
[1] B B A B A B A B A A
Levels: A B

> ftable(work, sex, group, row.vars="work", col.vars=c("sex", "group"))
         sex    f      m
       group  A  B   A  B
work
home          0  1   1  1
office        1  2   3  1
\end{lstlisting}

Beim Erstellen von Kreuztabellen kann auch auf\index[func]{xtabs()@\lstinline{xtabs()}} \lstinline!xtabs()! zurückgegriffen werden, insbesondere wenn sich die Variablen in Datensätzen befinden (Abschn.\ \ref{sec:dataframe}).
\begin{lstlisting}
> xtabs(formula=~ ., data=<<Datensatz>>)
\end{lstlisting}

Im ersten Argument \lstinline!formula! erwartet \lstinline!xtabs()! eine \emph{Modellformel} (Abschn.\ \ref{sec:formula}). Hier ist dies eine besondere Art, die in der Kontingenztafel zu berücksichtigenden Faktoren aufzuzählen, die durch ein \lstinline!+! verknüpft rechts von der Tilde \lstinline!~! stehen. In der Voreinstellung \lstinline!~ .! werden alle Variablen des unter \lstinline!data! angegebenen Datensatzes einbezogen, d.\,h.\ alle möglichen Kombinationen von Faktorstufen gebildet. Eine links der \lstinline!~! genannte Variable wird als Vektor von Häufigkeiten interpretiert, die pro Stufenkombination der rechts von der \lstinline!~! genannten Faktoren zu addieren sind. Links der \lstinline!~! kann auch eine -- ggf.\ mit \lstinline!cbind()! aus Variablen zusammengefügte -- Matrix stehen, deren Spalten dann jeweils pro Stufenkombination addiert werden. Stammen die in der Modellformel genannten Variablen aus einem Datensatz, ist dieser unter \lstinline!data! zu nennen. Die Ausprägungen des rechts der \lstinline!~! zuerst genannten Faktors bilden die Zeilen der ausgegebenen Kontingenztafel.
\begin{lstlisting}
> (persons <- data.frame(sex, work, counts))  # Variablen als Datensatz
   sex    work  counts
1    f    home       0
2    m  office       3
3    f  office       3
4    m    home       1
5    m    home       1
6    f  office       1
7    m  office       3
8    f  office       5
9    m  office       2
10   m  office       4

# gemeinsame Häufigkeiten der Stufen von sex und work
> xtabs(~ sex + work, data=persons)
         work
sex  home  office
  f     1       3
  m     2       4

# Summe von counts pro Zelle
> xtabs(counts ~ sex + work, data=persons)
        work
sex  home  office
  f     0       9
  m     2      12
\end{lstlisting}

Einen Überblick über die Zahl der in einer Häufigkeitstabelle ausgewerteten Faktoren sowie die Anzahl der zugrundeliegenden Beobachtungsobjekte erhält man mit\index[func]{summary()@\lstinline{summary()}} \lstinline!summary(<<Tabelle>>)!. Im Fall von Kreuztabellen wird hierbei zusätzlich ein $\chi^{2}$-Test auf Unabhängigkeit bzw.\ auf Gleichheit von Verteilungen berechnet (Abschn.\ \ref{sec:chisqInd}, \ref{sec:chisqEq}).
\begin{lstlisting}
> summary(table(sex, work))
Number of cases in table: 10
Number of factors: 2
Test for independence of all factors:
Chisq = 4.444, df = 1, p-value = 0.03501
Chi-squared approximation may be incorrect
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Randkennwerte von Kreuztabellen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!Randkennwerte}
Um Randsummen, Randmittelwerte oder ähnliche Kennwerte für eine Kreuztabelle zu berechnen, können alle für Matrizen vorgestellten Funktionen verwendet werden, insbesondere \lstinline!apply()!, aber etwa auch \lstinline!rowSums()! und \lstinline!colSums()! sowie \lstinline!rowMeans()! und \lstinline!colMeans()!. Hier nimmt die Tabelle die Rolle der Matrix ein.
\begin{lstlisting}
# Zeilensummen
> apply(xtabs(~ sex + work, data=persons), MARGIN=1, FUN=sum)
f  m
4  6

# Spaltenmittel
> colMeans(xtabs(~ sex + work, data=persons))
home  office
 1.5     3.5
\end{lstlisting}

\lstinline!addmargins()!\index[func]{addmargins()@\lstinline{addmargins()}} berechnet beliebige Randkennwerte für eine Kreuztabelle \lstinline!A! entsprechend der mit dem Argument \lstinline!FUN! bezeichneten Funktion (Voreinstellung ist \lstinline!sum! für Randsummen). Die Funktion operiert separat über jeder der mit dem Vektor \lstinline!margin! bezeichneten Dimensionen. Die Ergebnisse der Anwendung von \lstinline!FUN! werden \lstinline!A! in der Ausgabe als weitere Zeile und Spalte hinzugefügt.
\begin{lstlisting}
> addmargins(A=<<Tabelle>>, margin=<<Vektor>>, FUN=<<Funktion>>)

# Randmittel
> addmargins(xtabs(~ sex + work, data=persons), c(1, 2), FUN=mean)
            work
 sex  home  office  mean
   f   1.0     3.0   2.0
   m   2.0     4.0   3.0
mean   1.5     3.5   2.5
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datensätze aus Häufigkeitstabellen erstellen}
\label{sec:tab2df}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In manchen Situationen liegen Daten nur in Form von Häufigkeitstabellen vor -- etwa wenn sie aus der Literatur übernommen werden. Um die Daten selbst auszuwerten, ist es dann notwendig, sie zunächst in ein Format umzuwandeln, das die Variablen als separate Spalten verwendet und pro Beobachtungsobjekt eine Zeile besitzt. Diese Aufgabe erledigt die Funktion \lstinline!Untable()!\index[func]{Untable()@\lstinline{Untable()}} aus dem Paket \index[pack]{DescTools@\lstinline{DescTools}} \lstinline!DescTools!. Als Ausgabe liefert sie einen Datensatz (Abschn.\ \ref{sec:dataframe}).
\begin{lstlisting}
> cTab <- xtabs(~ sex + work, data=persons)     # Kreuztabelle
> library(DescTools)                            # für Untable()
> Untable(cTab)
   sex   work
1    f   home
2    f office
3    f office
4    f office
5    m   home
6    m   home
7    m office
8    m office
9    m office
10   m office
\end{lstlisting}

Eine andere Darstellung liefert die explizite Umwandlung der Kreuztabelle in einen Datensatz mit \lstinline!as.data.frame()!. Der erzeugte Datensatz besitzt für jede Zelle der Kreuztabelle eine Zeile und neben den Spalten für die ausgezählten Variablen eine weitere Spalte \lstinline!Freq! mit der Häufigkeit der Merkmalskombination.
\begin{lstlisting}
> as.data.frame(cTab)
  sex   work Freq
1   f   home    1
2   m   home    2
3   f office    3
4   m office    4
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kumulierte relative Häufigkeiten und Prozentrang}
\label{sec:stepfun}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Haufigkeiten@Häufigkeiten!kumulierte relative}
\index{kumulierte relative Häufigkeiten|see{Häufigkeiten}}
\index[func]{ecdf()@\lstinline{ecdf()}}
\lstinline!ecdf(x=<<Vektor>>)! (\emph{empirical cumulative distribution function}) ermittelt die kumulierten relativen Häufigkeiten kategorialer Daten. Diese geben für einen Wert $x_{i}$ an, welcher Anteil der Daten nicht größer als $x_{i}$ ist. Das Ergebnis ist analog zur Verteilungsfunktion quantitativer Zufallsvariablen.

Das Ergebnis von \lstinline!ecdf()! ist eine\index{Stufenfunktion} Stufenfunktion mit so vielen Sprungstellen, wie es unterschiedliche Werte in \lstinline!x! gibt. Die Höhe jedes Sprungs entspricht der relativen Häufigkeit des Wertes an der Sprungstelle. Enthält \lstinline!x! also keine mehrfach vorkommenden Werte, erzeugt \lstinline!ecdf()! eine Stufenfunktion mit so vielen Sprungstellen, wie \lstinline!x! Elemente besitzt. Dabei weist jeder Sprung dieselbe Höhe auf -- die relative Häufigkeit \lstinline!1/length(x)! jedes Elements von \lstinline!x!. Tauchen in \lstinline!x! Werte mehrfach auf, unterscheiden sich die Sprunghöhen dagegen entsprechend den relativen Häufigkeiten.

Die Ausgabe von \lstinline!ecdf()! ist ihrerseits eine Funktion, die zunächst einem eigenen Objekt zugewiesen werden muss, ehe sie zur Ermittlung kumulierter relativer Häufigkeiten Verwendung finden kann. Ist \lstinline!Fn()! diese Stufenfunktion, und möchte man die kumulierten relativen Häufigkeiten der in \lstinline!x! gespeicherten Werte erhalten, ist \lstinline!x! selbst als Argument für \lstinline!Fn()! einzusetzen. Andere Werte als Argument von \lstinline!Fn()! sind aber ebenfalls möglich. Indem \lstinline!Fn()! für beliebige Werte ausgewertet wird, lassen sich empirische und interpolierte\index{Prozentrang} Prozentränge ermitteln. Mit \lstinline!ecdf()! erstellte Funktionen können über \lstinline!plot()!\index[func]{plot()@\lstinline{plot()}} in einem Diagramm gezeigt werden (Abb.\ \ref{fig:ks}, Abb.\ \ref{fig:ecdf}, Abschn.\ \ref{sec:ecdfPlot}).
\begin{lstlisting}
> (vec <- round(rnorm(10), 2))
[1] -1.57 2.21 -1.01 0.21 -0.29 -0.61 -0.17 1.90 0.17 0.55

# kumulierte relative Häufigkeiten der vorhandenen Werte
> Fn <- ecdf(vec)
> Fn(vec)
[1] 0.1 1.0 0.2 0.7 0.4 0.3 0.5 0.9 0.6 0.8

> 100 * Fn(0.1)                              # Prozentrang von 0.1
[1] 50

> 100 * (sum(vec <= 0.1) / length(vec))      # Kontrolle
[1] 50
\end{lstlisting}

Soll die Ausgabe der kumulierten relativen Häufigkeiten in der richtigen Reihenfolge erfolgen, müssen die Werte mit \lstinline!sort()! geordnet werden.
\begin{lstlisting}
> Fn(sort(vec))
[1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
\end{lstlisting}

Die Sprungstellen einer von \lstinline!ecdf()! erstellten Funktion lassen sich mit\index[func]{knots()@\lstinline{knots()}} \lstinline!knots()! extrahieren. Das Ergebnis sind gerade die in \lstinline!x! enthaltenen unterschiedlichen sortierten Werte.
\begin{lstlisting}
> knots(Fn)
[1] -1.57 -1.01 -0.61 -0.29 -0.17 0.17 0.21 0.55 1.90 2.21
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fehlende Werte behandeln}
\label{sec:na}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!Qualität}
\index{Daten!fehlende Werte|textbf}
\index{fehlende Werte|see{Daten}}
Empirische Datensätze besitzen häufig zunächst keine zufriedenstellende Qualität, etwa durch Fehler in der Eingabe von Werten, Ausreißer (Abschn.\ \ref{sec:regrInfluence}, \ref{sec:distDiag}) oder durch unvollständige Daten -- wenn also nicht für alle Beobachtungsobjekte Werte von allen erhobenen Variablen vorliegen. So können etwa Personen die Auskunft bzgl.\ bestimmter Fragen verweigern, Aufgaben übersehen oder in adaptiven Tests aufgrund von Verzweigungen nicht vorgelegt bekommen.

Fehlende Werte bergen aus versuchsplanerischer Perspektive die Gefahr, dass sie womöglich nicht zufällig, sondern systematisch entstanden sind und so zu verzerrten Ergebnissen führen. Aber auch bei der statistischen Auswertung werfen sie Fragen auf: Zum einen sind verschiedene Strategien des Umgangs mit ihnen denkbar, die nicht unbedingt zu gleichen Ergebnissen führen. Zum anderen können fehlende Werte bewirken, dass nicht wie beabsichtigt in allen Experimentalbedingungen dieselbe Anzahl von Beobachtungen vorliegt. Dies ist jedoch für die Anwendung und Interpretation vieler üblicher Verfahren relevant, deren Einsatz durch das Vorliegen fehlender Werte problematisch werden könnte.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Fehlende Werte codieren und identifizieren}
\label{sec:isna}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!codieren}
\index[func]{NA@\lstinline{NA}}
Wenn ein Datensatz eingegeben wird und fehlende Werte vorliegen, so dürfen diese nicht einfach weggelassen, sondern müssen mit der Konstante \lstinline!NA! (\emph{not available}) codiert werden -- auch bei \lstinline!character! Vektoren ist sie nicht in Anführungszeichen zu setzen.\footnote{Für jeden Datentyp existiert jeweils eine passende Konstante, all diese Konstanten tragen aber den Namen \lstinline!NA!. Der mit \lstinline!typeof(NA)! ausgegebene Basis-Datentyp ist \lstinline!logical!. Damit ist die Ausgabe etwa von \lstinline!c(1, 2, 3)[NA]! gleich \lstinline!NA NA NA!, da logische Indexvektoren zyklisch verlängert werden (Abschn.\ \ref{sec:vecSel}, \ref{sec:which}).}
\begin{lstlisting}
> (vec1 <- c(10, 20, NA, 40, 50, NA))
[1] 10 20 NA 40 50 NA

> length(vec1)
[1] 6
\end{lstlisting}

In manchen Situationen werden Zeichenketten prinzipiell ohne Anführungszeichen ausgegeben, etwa bei Faktoren oder Datensätzen (Abschn.\ \ref{sec:dataframe}). Zur leichteren Unterscheidung von gültigen Zeichenketten erscheinen fehlende Werte deshalb dann als \lstinline!<NA>!.\footnote{In solchen Situationen ist also \lstinline!NA! die Ausgabe eines gültigen Elements und von einem fehlenden Wert \lstinline!<NA>! zu unterscheiden. So erzeugt \lstinline!factor(c("A", "NA", "C"))[c(NA, 2, 3)]! die Ausgabe \lstinline!<NA> NA C!. Einzig die gültige Zeichenkette \lstinline!\"<NA>\"! lässt sich in der Ausgabe nicht von einem fehlenden Wert unterscheiden. In diesem Fall kann nur mit Hilfe von \lstinline!is.na()! festgestellt werden, ob es sich tatsächlich um einen fehlenden Wert handelt.}
\begin{lstlisting}
# Ausgabe von Zeichenketten mit Anführungszeichen -> nur NA
> LETTERS[c(1, NA, 3)]
[1] "A" NA "C"

# Ausgabe von Zeichenketten ohne Anführungszeichen -> <NA>
> factor(LETTERS[c(1, NA, 3)])
[1] A <NA> C
Levels: A C
\end{lstlisting}

\index{Daten!fehlende Werte!identifizieren}
\index[func]{is.na()@\lstinline{is.na()}}
Ob in einem Vektor fehlende Werte vorhanden sind, wird mit der Funktion \lstinline!is.na(<<Vektor>>)! ermittelt.\footnote{Der \lstinline!==! Operator eignet sich nicht zur Prüfung auf fehlende Werte, da das Ergebnis von \lstinline!<<Wert>> == NA! selbst \lstinline!NA! ist (Abschn.\ \ref{sec:treatNA}).} Sie gibt einen logischen Vektor aus, der für jede Position angibt, ob das Element ein fehlender Wert ist. Im Fall einer Datenmatrix liefert \lstinline!is.na()! eine Matrix aus Wahrheitswerten, die für jedes Matrixelement angibt, ob es sich um einen fehlenden Wert handelt.
\begin{lstlisting}
> is.na(vec1)
[1] FALSE FALSE TRUE FALSE FALSE TRUE

> vec2   <- c(NA, 7, 9, 10, 1, 8)
> (matNA <- rbind(vec1, vec2))
     [,1]  [,2]  [,3]  [,4]  [,5]  [,6]
vec1   10    20    NA    40    50   NA
vec2   NA     7     9    10     1    8

> is.na(matNA)
      [,1]   [,2]   [,3]   [,4]   [,5]   [,6]
vec1 FALSE  FALSE   TRUE  FALSE  FALSE   TRUE
vec2  TRUE  FALSE  FALSE  FALSE  FALSE  FALSE
\end{lstlisting}

\index{Daten!fehlende Werte!zählen}
Bei einem großen Datensatz ist es mühselig, die Ausgabe von \lstinline!is.na()! manuell nach \lstinline!TRUE! Werten zu durchsuchen. Daher bietet sich \lstinline!anyNA()!\index[func]{anyNA()@\lstinline{anyNA()}} an, um zu erfahren, ob überhaupt fehlende Werte vorliegen, \lstinline!sum(is.na())!, um deren Anzahl und \lstinline!which(is.na())!, um deren Position zu ermitteln.
\begin{lstlisting}
> anyNA(vec1)                           # gibt es fehlende Werte?
[1] TRUE

> sum(is.na(vec1))                      # wie viele?
[1] 2

> which(is.na(vec1))                    # wo im Vektor?
[1] 3 6

> which(is.na(matNA), arr.ind=TRUE)     # wo in der Matrix?
     row col
vec2   2   1
vec1   1   3
vec1   1   6
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Fehlende Werte ersetzen und umcodieren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!recodieren}
Fehlende Werte werden bei der Dateneingabe in anderen Programmen oft mit Zahlen codiert, die keine mögliche Ausprägung einer Variable sind, z.\,B.\ mit $999$. Bisweilen ist diese Codierung auch nicht einheitlich, sondern verwendet verschiedene Zahlen, etwa wenn Daten aus unterschiedlichen Quellen zusammengeführt werden. Bei der Verarbeitung von aus anderen Programmen übernommenen Datensätzen in R muss die Codierung fehlender Werte also ggf.\ angepasst werden (Abschn.\ \ref{sec:dataImport}, insbesondere das Argument \lstinline!na.strings! in Abschn.\ \ref{sec:scan} und \ref{sec:readTable}).

Die Identifikation der zu ersetzenden Werte kann über \lstinline!<<Vektor>> %in% <<Menge>>! erfolgen, wobei \lstinline!<<Menge>>! ein Vektor mit allen Werten ist, die als fehlend gelten sollen (Abschn.\ \ref{sec:setOps}). Der damit erzeugte Indexvektor lässt sich direkt an das Ergebnis von \lstinline!is.na()! zuweisen, wodurch die zugehörigen Elemente auf \lstinline!NA! gesetzt werden. Das Vorgehen bei Matrizen ist analog.
\begin{lstlisting}
# fehlende Werte sind zunächst mit -999 und 999 codiert
> vec <- c(30, 25, 23, 21, -999, 999)   # Vektor mit fehlenden Werten
> is.na(vec) <- vec %in% c(-999, 999)   # ersetze missings durch NA
> vec
[1] 30 25 23 21 NA NA

# Matrix mit fehlenden Werten
> (mat <- matrix(c(30, 25, 23, 21, -999, 999), nrow=2, ncol=3))
     [,1]  [,2]  [,3]
[1,]   30    23  -999
[2,]   25    21   999

> is.na(mat) <- mat %in% c(-999, 999)   # ersetze missings durch NA
> mat
     [,1]  [,2]  [,3]
[1,]   30    23    NA
[2,]   25    21    NA
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behandlung fehlender Werte bei der Berechnung einfacher Kennwerte}
\label{sec:treatNA}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!ausschließen}
Wenn in einem Vektor oder einer Matrix fehlende Werte vorhanden sind, muss Funktionen zur Berechnung statistischer Kennwerte über ein Argument angegeben werden, wie mit ihnen zu verfahren ist. Andernfalls kann der Kennwert nicht berechnet werden, und das Ergebnis der Funktion ist seinerseits \lstinline!NA!\@.\footnote{\label{ftn:whenNA}Allgemein ist das Ergebnis aller Rechnungen \lstinline!NA!, sofern der fehlende Wert für das Ergebnis relevant ist. Ist das Ergebnis auch ohne den fehlenden Wert eindeutig bestimmt, wird es ausgegeben -- so erzeugt \lstinline!TRUE | NA! die Ausgabe \lstinline!TRUE!, da sich bei einem logischen ODER das zweite Argument nicht auf das Ergebnis auswirkt, wenn das erste WAHR ist.} Allerdings lassen sich \lstinline!NA! Einträge zunächst manuell entfernen, ehe die Daten an eine Funktion übergeben werden. Zu diesem Zweck existiert die Funktion\index[func]{na.omit()@\lstinline{na.omit()}|textbf} \lstinline!na.omit(<<Vektor>>)!, die das übergebene Objekt um fehlende Werte bereinigt ausgibt.
\begin{lstlisting}
> sd(na.omit(vec))              # um NA bereinigten Vektor übergeben
[1] 5.125102

# fehlende Werte manuell entfernen
> goodIdx <- !is.na(vec)        # Indizes der nicht fehlenden Werte
> mean(vec[goodIdx])            # um NA bereinigten Vektor übergeben
[1] 24.33333
\end{lstlisting}

Die Behandlung fehlender Werte lässt sich in vielen Funktionen auch direkt über das Argument \lstinline!na.rm! steuern. In der Voreinstellung \lstinline!FALSE! sorgt es dafür, dass fehlende Werte nicht stillschweigend bei der Berechnung des Kennwertes ausgelassen werden, sondern das Ergebnis \lstinline!NA! ist. Soll der Kennwert dagegen auf Basis der vorhandenen Werte berechnet werden, muss das Argument \lstinline!na.rm=TRUE! gesetzt werden.
\begin{lstlisting}
> sum(vec)
[1] NA

> sum(vec, na.rm=TRUE)
[1] 146

> apply(matNA, 1, FUN=mean)
[1] NA NA

> apply(matNA, 1, mean, FUN=na.rm=TRUE)
[1] 23.33333 25.33333
\end{lstlisting}

Auf die dargestellte Weise lassen sich fehlende Werte u.\,a.\ in \lstinline!sum()!, \lstinline!prod()!, \lstinline!range()!, \lstinline!mean()!, \lstinline!median()!, \lstinline!quantile()!, \lstinline!var()!, \lstinline!sd()!, \lstinline!cov()! und \lstinline!cor()! behandeln.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behandlung fehlender Werte in Matrizen}
\label{sec:naMat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Bei den Funktionen \lstinline!cov()! und \lstinline!cor()! stehen zur Behandlung fehlender Werte der \emph{zeilenweise} und \emph{paarweise} Fallausschluss zur Verfügung, die über das Argument \lstinline!use="complete.obs"! bzw. \lstinline!use="pairwise.complete.obs"! ausgewählt werden. Bei der Kovarianz bzw. Korrelation zweier Variablen führen sie zum selben Ergebnis,
unterscheiden sich aber bei Kovarianz- bzw. Korrelationsmatrizen von mehr als zwei Variablen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Zeilenweiser (fallweiser) Fallausschluss}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!fallweiser Ausschluss}
Beim zeilenweisen Fallausschluss werden die Matrixzeilen komplett entfernt, in denen \lstinline!NA! Werte auftauchen, ehe die Matrix für Berechnungen herangezogen wird. Weil eine Zeile oft allen an einem Beobachtungsobjekt erhobenen Daten entspricht, wird dies auch als fallweiser Fallausschluss bezeichnet. \index[func]{na.omit()@\lstinline{na.omit()}} \lstinline!na.omit(<<Matrix>>)! bereinigt eine Matrix mit fehlenden Werten um Zeilen, in denen \lstinline!NA! Einträge auftauchen. Die Indizes der dabei ausgeschlossenen Zeilen werden der ausgegebenen Matrix als Attribut hinzugefügt. Mit der so gebildeten Matrix fließen im Beispiel die Zeilen $1$ und $2$ nicht mit in Berechnungen ein.
\begin{lstlisting}
> ageNA  <- c(18, NA, 27, 22)
> DV1    <- c(NA, 1, 5, -3)
> DV2    <- c(9, 4, 2, 7)
> (matNA <- cbind(ageNA, DV1, DV2))
     ageNA  DV1  DV2
[1,]    18   NA    9
[2,]    NA    1    4
[3,]    27    5    2
[4,]    22   -3    7

> na.omit(matNA)                            # Zeilen mit NA entfernen
     ageNA  DV1  DV2
[1,]    27    5    2
[2,]    22   -3    7

attr(,"na.action")
[1] 2 1

attr(,"class")
[1] "omit"

> colMeans(na.omit(matNA))                  # Berechnung ohne NAs
ageNA  DV1  DV2
 24.5  1.0  4.5
\end{lstlisting}

Alternativ besteht die Möglichkeit, alle Zeilen mit fehlenden Werten anhand von \lstinline!apply(is.na(<<Matrix>>), 1, any)! selbst festzustellen. Mit dem resultierenden logischen Indexvektor lassen sich die betroffenen Zeilen von weiteren Berechnungen ausschließen.
\begin{lstlisting}
> (rowNAidx <- apply(is.na(matNA), 1, any)) # Zeilen mit NA feststellen
[1] TRUE TRUE FALSE FALSE

> matNA[!rowNAidx, ]                        # Zeilen mit NA entfernen
     ageNA  DV1  DV2
[1,]    27    5    2
[2,]    22   -3    7
\end{lstlisting}

Bei \lstinline!cov()! und \lstinline!cor()! bewirkt bei der Berechnung von Kovarianz- und Korrelationsmatrizen mit mehr als zwei Variablen das Argument \lstinline!use="complete.obs"! den fallweisen Ausschluss fehlender Werte. Dessen Verwendung hat denselben Effekt wie die vorherige Reduktion der Matrix um Zeilen, in denen fehlende Werte auftauchen.
\begin{lstlisting}
> cov(matNA, use="complete.obs")
      age  DV1    DV2
age  12.5   20  -12.5
DV1  20.0   32  -20.0
DV2 -12.5  -20   12.5

# beide Arten des fallweisen Ausschlusses erzielen dasselbe Ergebnis
> all.equal(cov(matNA, use="complete.obs"), cov(na.omit(matNA)))
[1] TRUE
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Paarweiser Fallausschluss}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!paarweiser Ausschluss}
Der paarweise Fallausschluss unterscheidet sich erst bei der Berechnung von Kovarianz- bzw.\ Korrelationsmatrizen für mehr als zwei Variablen vom fallweisen Ausschluss. Beim paarweisen Fallausschluss werden die Werte einer auch \lstinline!NA! beinhaltenden Zeile soweit als möglich in Berechnungen berücksichtigt, die Zeile wird also nicht vollständig ausgeschlossen. Welche Werte einer Zeile Verwendung finden, hängt von der konkreten Auswertung ab. Der paarweise Fallausschluss wird im Fall der Berechnung der Summe oder des Mittelwertes über Zeilen oder Spalten mit dem Argument \lstinline!na.rm=TRUE! realisiert, das alle Werte außer \lstinline!NA! einfließen lässt.
\begin{lstlisting}
> rowMeans(matNA)
[1] NA NA 11.333333 8.666667

> rowMeans(mat, na.rm=TRUE)
[1] 13.500000 2.500000 11.333333 8.666667
\end{lstlisting}

Bei der Berechnung von Kovarianz- und Korrelationsmatrizen für mehr als zwei Variablen mit \lstinline!cov()! und \lstinline!cor()! bewirkt das Argument \lstinline!use="pairwise.complete.obs"! den paarweisen Ausschluss fehlender Werte. Es wird dann bei der Berechnung jeder Kovarianz pro Zeile geprüft, ob in den zugehörigen beiden Spalten ein gültiges Wertepaar existiert und dieses ggf.\ verwendet. Anders als beim fallweisen Ausschluss geschieht dies also auch dann, wenn in derselben Zeile Werte anderer Variablen fehlen, dies für die zu berechnende Kovarianz aber irrelevant ist.\footnote{Eine mit diesem Verfahren ermittelte Matrix kann auch nicht positiv semidefinit sein, und stellt dann keine Kovarianzmatrix bzw.\ Korrelationsmatrix im engeren Sinne dar.}

Angewendet auf die Daten in \lstinline!matNA! bedeutet das beispielsweise, dass beim fallweisen Ausschluss das von Beobachtungsobjekt $1$ gelieferte Wertepaar nicht in die Berechnung der Kovarianz von \lstinline!ageNA! und \lstinline!DV2! einfließt, weil der Wert für \lstinline!DV1! bei diesem Beobachtungsobjekt fehlt. Beim paarweisen Ausschluss werden diese Werte dagegen berücksichtigt. Lediglich bei der Berechnung der Kovarianz von \lstinline!DV1! und \lstinline!DV2! werden keine Daten des ersten Beobachtungsobjekts verwendet, weil ein Wert für \lstinline!DV1! von ihr fehlt.
\begin{lstlisting}
> cov(matNA, use="pairwise.complete.obs")
          ageNA  DV1         DV2
ageNA  20.33333   20  -16.000000
  DV1  20.00000   16  -10.000000
  DV2 -16.00000  -10    9.666667
\end{lstlisting}

Ob fehlende Werte fall- oder paarweise ausgeschlossen werden sollten, hängt u.\,a.\ von den Ursachen ab, warum manche Untersuchungseinheiten unvollständige Daten geliefert haben und andere nicht. Insbesondere stellt sich die Frage, ob Untersuchungseinheiten mit fehlenden Werten systematisch andere Eigenschaften haben, so dass von ihren Daten generell kein Gebrauch gemacht werden sollte.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behandlung fehlender Werte beim Sortieren von Daten}
\label{sec:sortNA}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!sortieren}
Beim Sortieren von Daten mit \lstinline!sort()! und \lstinline!order()! wird die Behandlung fehlender Werte mit dem Argument \lstinline!na.last! kontrolliert, das auf \lstinline!NA!, \lstinline!TRUE! oder \lstinline!FALSE! gesetzt werden kann. Bei \lstinline!sort()! ist \lstinline!na.last! per Voreinstellung auf \lstinline!NA! gesetzt und sorgt so dafür, dass fehlende Werte entfernt werden. Bei \lstinline!order()! ist die Voreinstellung \lstinline!TRUE!, wodurch fehlende Werte ans Ende plaziert werden. Auf \lstinline!FALSE! gesetzt bewirkt \lstinline!na.last! die Plazierung fehlender Werte am Anfang.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behandlung fehlender Werte in inferenzstatistischen Tests}
\label{sec:naTests}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte}
Viele Funktionen zur Berechnung statistischer Tests besitzen das Argument \lstinline!na.action!, das festlegt, wie mit fehlenden Werten zu verfahren ist. Mögliche Werte sind u.\,a.\ die Namen der Funktionen \lstinline!na.omit()!\index[func]{na.omit()@\lstinline{na.omit()}} und \lstinline!na.fail()!\index[func]{na.fail()@\lstinline{na.fail()}}, die sich auch direkt auf Daten anwenden lassen (Abschn.\ \ref{sec:treatNA}, \ref{sec:naDf}). Die Voreinstellung \lstinline!na.omit! bewirkt den fallweisen Ausschluss (Abschn.\ \ref{sec:naMat}), mit \lstinline!na.fail! wird die Auswertung bei fehlenden Werten abgebrochen und eine Fehlermeldung ausgegeben. Global kann dieses Verhalten mit \lstinline!options(na.action="<<Wert>>")!\index[func]{options()@\lstinline{options()}} geändert werden (vgl.\ \lstinline!?na.action!). Generell empfiehlt es sich, Daten außerhalb von Auswertungsfunktionen um fehlende Werte zu bereinigen, bzw.\ sie mit Techniken der multiplen Imputation zu vervollständigen. So lässt sich die Konsistenz bzgl.\ der in einzelne Auswertungen eingeflossenen Fälle besser sichern.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Multiple Imputation}
\label{sec:multipleImputation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Daten!fehlende Werte!multiple Imputation}
\index{Daten!fehlende Werte!ersetzen}
\index{multiple Imputation|see{Daten}}
\index{Imputation|see{Daten}}
Neben den beschriebenen Methoden zur Behandlung fehlender Werte versucht auch die \emph{multiple Imputation} mit diesem Problem umzugehen. Sie ersetzt fehlende Werte eines aus mehreren Variablen bestehenden Datensatzes in mehreren Durchgängen jeweils durch solche Zahlen, die mit bestimmten Annahmen und unter Berücksichtigung der tatsächlich vorhandenen Daten generiert wurden. Die simulierten Daten sollen so die Verteilungseigenschaften der empirischen Daten teilen. Für jede einzelne Imputation aller fehlenden Werte lassen sich dann z.\,B.\ Parameterschätzungen einer linearen Regression berechnen. Die sich ergebene Menge unterschiedlicher Schätzungen -- eine pro Imputation -- kann dann geeignet zu einer Gesamtschätzung kombiniert werden.

Multiple Imputation wird in R u.\,a.\ von den Pakten\index[pack]{Amelia II@\lstinline{Amelia II}} \lstinline!Amelia II! \cite{Honaker2011}, \index[pack]{mice@\lstinline{mice}} \lstinline!mice! \cite{vanBuuren2011,vanBuuren2012} und \index[pack]{mice@\lstinline{mi}} \lstinline!mi! \cite{Su2011} unterstützt. Für weitere vgl.\ den Abschnitt \emph{Official Statistics \& Survey Methodology} der CRAN Task Views \cite{CRANtvOffStat}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zeichenketten verarbeiten}
\label{sec:stringMan}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Zeichenketten tauchen bei der eigentlichen Auswertung von Daten als Bezeichnungen für Variablen oder Gruppen auf. Vor allem bei der Aufbereitung eines Rohdatensatzes ist es aber hilfreich, sie flexibel erstellen und manipulieren zu können.\footnote{Das Paket \index[pack]{stringr@\lstinline{stringr}} \lstinline!stringr! \cite{Wickham2011a} stellt für viele der im folgenden aufgeführten Funktionen Alternativen bereit, die den Umgang mit Zeichenketten erleichtern und konsistenter gestalten sollen.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Objekte in Zeichenketten umwandeln}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Umwandlung in Zeichenketten}
\index[func]{toString()@\lstinline{toString()}}
Mit \lstinline!toString(<<Objekt>>)! lassen sich Objekte in Zeichenketten umwandeln. Das Ergebnis ist eine einzelne Zeichenkette mit den Inhalten des Objekts, wobei einzelne Elemente durch Komma mit folgendem Leerzeichen getrennt werden. Komplexe Objekte (z.\,B.\ Matrizen) werden dabei wie Vektoren verarbeitet.
\begin{lstlisting}
> randVals <- round(rnorm(5), 2)
> toString(randVals)
[1] "-0.03, 1.01, -0.52, -1.03, 0.18"
\end{lstlisting}

\index[func]{capture.output()@\lstinline{capture.output()}}
Analog wandelt \lstinline!capture.output(<<Ausdruck>>)! die normalerweise auf der Konsole erscheinende Ausgabe eines Befehlsausdrucks in eine Zeichenkette um. Die Ausgabe mehrerer Bearbeitungsschritte lässt sich mit\index[func]{sink()@\lstinline{sink()}} \lstinline!sink()! in eine Zeichenkette oder Datei leiten. Soll ein Protokoll aller Vorgänge als Kopie in eine Datei geschrieben werden, ist dabei das Argument \lstinline!split=TRUE! zu setzen.

\index[func]{formatC()@\lstinline{formatC()}}
\lstinline!formatC()! ist auf die Umwandlung von Zahlen in Zeichenketten spezialisiert und bietet sich vor allem für die formatierte Ausgabe von Dezimalzahlen an.
\begin{lstlisting}
> formatC(x=<<Zahl>>, digits=<<Dezimalstellen>>, width=<<Breite>>,
+         flag="<<Modifikation>>", format="<<Zahlentyp>>")
\end{lstlisting}

Ist \lstinline!x! eine Dezimalzahl, wird sie mit \lstinline!digits! vielen Dezimalstellen ausgegeben. Die Angabe von \lstinline!digits! fügt ganzen Zahlen keine Dezimalstellen hinzu, allerdings verbreitert sich die ausgegebene Zeichenkette auf \lstinline!digits! viele Zeichen, indem \lstinline!x! entsprechend viele Leerzeichen vorangestellt werden. Sollen der Zahl stattdessen Nullen vorangestellt werden, ist \lstinline!flag="0"! zu setzen. Linksbündig ausgerichtete Zeichenketten sind mit \lstinline!flag="-"! zu erreichen. Die Länge der Zeichenkette lässt sich auch unabhängig von der Zahl der Dezimalstellen mit dem Argument \lstinline!width! kontrollieren. Schließlich ermöglicht \lstinline!format! die Angabe, was für ein Zahlentyp bei \lstinline!x! vorliegt, insbesondere ob es eine ganze Zahl (\lstinline!"d"!) oder eine Dezimalzahl ist. Im letztgenannten Fall kann die Ausgabeform etwa mit \lstinline!"f"! wie gewohnt erfolgen (z.\,B.\ \lstinline!"1.234"!) oder mit \lstinline!"e"! in wissenschaftlicher Notation (z.\,B.\ \lstinline!"1.23e+03"!) -- für weitere Möglichkeiten vgl.\ \lstinline!?formatC!\@.
\begin{lstlisting}
> formatC(3, digits=5, format="d")
[1] "    3"

> formatC(c(1, 2.345), width=5, format="f")
[1] "1.0000" "2.3450"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenketten erstellen und ausgeben}
\label{sec:strings}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Die einfachste Möglichkeit zum Erstellen eigener Zeichenketten ist ihre manuelle Eingabe auf der Konsole oder im Editor. Für Vektoren von Zeichenketten ist dabei zu beachten, dass der \lstinline!length()! Befehl jede Zeichenkette als ein Element betrachtet. Dagegen gibt \lstinline!nchar("<<Zeichenkette>>")!\index{Zeichenketten!Länge}\index{Lange@Länge!Zeichenkette}\index[func]{nchar()@\lstinline{nchar()}} die Wortlänge jedes Elements an, aus wie vielen einzelnen Zeichen jede Zeichenkette des Vektors also besteht.
\begin{lstlisting}
> length("ABCDEF")
[1] 1

> nchar("ABCDEF")
[1] 6

> nchar(c("A", "BC", "DEF"))
[1] 1 2 3
\end{lstlisting}

Fehlende Werte \lstinline!NA! wandelt \lstinline!nchar()! intern in die Zeichenkette \lstinline!"NA"! um. Daher liefert \lstinline!nchar(NA)! das Ergebnis $2$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Zeichenketten nach Muster erstellen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Die Methode, Zeichenketten manuell in Vektoren zu erstellen, stößt dort schnell an ihre Grenzen, wo sie von Berechnungen abhängen sollen oder viele Zeichenketten nach demselben Muster erzeugt werden müssen. \lstinline!paste()! und \lstinline!sprintf()! sind hier geeignete Alternativen.

\index{Zeichenketten!nach Muster erstellen}
\index[func]{paste()@\lstinline{paste()}}
Mit \lstinline!paste()! lassen sich Zeichenketten mit einem bestimmten Aufbau erzeugen, indem verschiedene Komponenten aneinandergehängt werden, die etwa aus einem gemeinsamen Präfix und unterschiedlicher laufender Nummer bestehen können.
\begin{lstlisting}
> paste(<<Objekt1>>, <<Objekt2>>, ..., sep=" ", collapse=NULL)
\end{lstlisting}

Die ersten Argumente von \lstinline!paste()! sind Objekte, deren Elemente jeweils die Bestandteile der zu erstellenden Zeichenketten ausmachen und zu diesem Zweck aneinandergefügt werden. Das erste Element des ersten Objekts wird dazu mit den ersten Elementen der weiteren Objekte verbunden, ebenso die jeweils zweiten und folgenden Elemente. Das Argument \lstinline!sep! kontrolliert, welche Zeichen jeweils zwischen Elementen aufeinander folgender Objekte einzufügen sind -- in der Voreinstellung ist dies das Leerzeichen. In der Voreinstellung \lstinline!collapse=NULL! ist das Ergebnis ein Vektor aus Zeichenketten, wobei jedes seiner Elemente aus der Kombination jeweils eines Elements aus jedem übergebenen Objekt besteht. Hierbei werden unterschiedlich lange Vektoren ggf.\ zyklisch verlängert (Abschn.\ \ref{sec:recycling}). Wird stattdessen für \lstinline!collapse! eine Zeichenfolge übergeben, ist das Ergebnis eine einzelne Zeichenkette, deren Bestandteile durch diese Zeichenfolge getrennt sind.
\begin{lstlisting}
> paste("group", LETTERS[1:5], sep="_")
[1] "group_A" "group_B" "group_C" "group_D" "group_E"

# Farben der Default-Farbpalette
> paste(1:5, palette()[1:5], sep=": ")
[1] "1: black" "2: red" "3: green3" "4: blue" "5: cyan"

> paste(1:5, letters[1:5], sep=".", collapse=" ")
[1] "1.a 2.b 3.c 4.d 5.e"
\end{lstlisting}

Fehlende Werte \lstinline!NA! wandelt \lstinline!paste()! in die Zeichenkette \lstinline!"NA"! um. Treten innerhalb von \lstinline!paste()! die leere Menge \lstinline!NULL! oder leere Vektoren \lstinline!character(0)! gemeinsam mit anderen Zeichen auf, werden sie wie die leere Zeichenkette der Länge $1$ \lstinline!""! behandelt, was an den eingefügten Trennzeichen \lstinline!sep! deutlich wird.
\begin{lstlisting}
> paste(1, NA, 2, NULL, 3, character(0), sep="_")
[1] "1_NA_2__3_"
\end{lstlisting}

\index[func]{sprintf()@\lstinline{sprintf()}}
Die an die gleichnamige Funktion der Programmiersprache C angelehnte Funktion \lstinline!sprintf()! erzeugt Zeichenketten, deren Aufbau durch zwei Komponenten bestimmt wird: Einerseits durch einen die Formatierung und feste Elemente definierenden Teil (den\index{format string} \emph{format string}), andererseits durch eine Reihe von Objekten, deren Werte an festgelegten Stellen des format strings einzufügen sind.
\begin{lstlisting}
> sprintf(fmt="<<format string>>", <<Objekt1>>, <<Objekt2>>, ...)
\end{lstlisting}

Das Argument \lstinline!fmt! erwartet eine Zeichenkette aus festen und variablen Elementen. Gewöhnliche Zeichen werden als feste Elemente interpretiert und tauchen unverändert in der erzeugten Zeichenkette auf. Variable Elemente werden durch das\index[func]{"\%@\texttt{\%}} Prozentzeichen \lstinline!%! eingeleitet, auf das ein Buchstabe folgen muss, der die Art des hier einzufügenden Wertes definiert. So gibt etwa \lstinline!%d! an, dass hier ein ganzzahliger Wert einzufügen ist, \lstinline!%f! dagegen weist auf eine Dezimalzahl hin und \lstinline!%s! auf eine Zeichenfolge. Das Prozentzeichen selbst wird durch \lstinline!%%! ausgegeben, doppelte\index[func]{""@\lstinline{"", '}} Anführungszeichen durch \lstinline!\"!,\footnote{Alternativ\index{Anfuhrungszeichen@Anführungszeichen} kann \lstinline!fmt! in einfache Anführungszeichen \lstinline!'<<format string>>'! gesetzt werden, innerhalb derer sich dann auch doppelte Anführungszeichen ohne voranstehenden backslash \lstinline!\\! befinden können (Abschn.\ \ref{sec:dataTypes}, Fußnote \ref{ftn:quote}).} Tabulatoren durch \lstinline!\t! und Zeilenumbrüche durch \lstinline!\n! (vgl.\ \lstinline!?Quotes!).

Für jedes durch ein Prozentzeichen definierte Feld muss nach \lstinline!fmt! ein passendes Objekt genannt werden, dessen Wert an der durch \lstinline!%! bezeichneten Stelle eingefügt wird. Die Entsprechung zwischen variablen Feldern und Objekten wird über deren Reihenfolge hergestellt, der Wert des ersten Objekts wird also an der Stelle des ersten variablen Elements eingefügt, etc.
\begin{lstlisting}
> N   <- 20
> grp <- "A"
> M   <- 14.2
> sprintf("For %d particpants in group %s, mean was %f", N, grp, M)
[1] "For 20 particpants in group A, mean was 14.200000"
\end{lstlisting}

Format strings erlauben eine weitergehende Formatierung der Ausgabe, indem zwischen dem \lstinline!%! und dem folgenden Buchstaben Angaben gemacht werden, die sich z.\,B.\ auf die Anzahl der auszugebenden Dezimalstellen beziehen können. Für detailliertere Informationen vgl.\ \lstinline!?sprintf!.
\begin{lstlisting}
> sprintf("%.3f", 1.23456)    # begrenze Ausgabe auf 3 Dezimalstellen
[1] "1.234"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Zeichenketten verbinden}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!verbinden}
\index[func]{cat()@\lstinline{cat()}}
Um mehrere Zeichenketten kombiniert als eine einzige Zeichenkette lediglich auf der R Konsole auszugeben (und nicht in einem Vektor zu speichern), kann die Funktion \lstinline!cat()! (\emph{concatenate}) verwendet werden. Sie erlaubt auch eine gewisse Formatierung -- etwa in Form von\index{Zeichenketten!Zeilenumbruch} Zeilenumbrüchen durch die\index{Escape-Sequenz}\index[func]{\textbackslash@\texttt{\textbackslash}} Escape-Sequenz \lstinline!\n! oder \lstinline!\t! für Tabulatoren.
\begin{lstlisting}
> cat("<<Zeichenkette 1>>", "<<Zeichenkette 2>>", ..., sep=" ")
\end{lstlisting}

\lstinline!cat()! kombiniert die übergebenen Zeichenketten durch Verkettung zunächst zu einer einzelnen, wobei zwischen den Zeichenketten das unter \lstinline!sep! genannte Trennzeichen eingefügt wird. Numerische Variablen werden hierbei automatisch in Zeichenketten konvertiert. Die Ausgabe von \lstinline!cat()! unterscheidet sich in zwei Punkten von der üblichen Ausgabe einer Zeichenkette: Zum einen wird sie nicht in Anführungszeichen gesetzt. Zum anderen wird am Anfang jeder Zeile auf die Ausgabe der Position des zu Zeilenbeginn stehenden Wertes, etwa \lstinline![1]!, verzichtet.
\begin{lstlisting}
> cVar <- "A string"
> cat(cVar, "with\n", 4, "\nwords\n", sep="+")
A string+with
+4+
words
\end{lstlisting}

In der Voreinstellung setzen die meisten Ausgabefunktionen von R Zeichenketten in Anführungszeichen. In \lstinline!print()! lässt sich dies mit dem Argument \lstinline!quote=FALSE! verhindern, allgemein hat \index[func]{noquote()@\lstinline{noquote()}} \lstinline!noquote("<<Zeichenkette>>")! denselben Effekt.
\begin{lstlisting}
> print(cVar, quote=FALSE)
[1] A string

> noquote(cVar)
[1] A string
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenketten manipulieren}
\label{sec:stringMod}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Groß- / Kleinbuchstaben}
\index[func]{tolower()@\lstinline{tolower()}}
\index[func]{toupper()@\lstinline{toupper()}}
\index[func]{abbreviate()@\lstinline{abbreviate()}}
\index[func]{strrep()@\lstinline{strrep()}}
\index[func]{strtrim()@\lstinline{strtrim()}}
\index[func]{trimws()@\lstinline{trimws()}}
\index[func]{StrRev()@\lstinline{StrRev()}}
\index{Zeichenketten!umkehren}

Die folgenden Funktionen akzeptieren als Argument neben einer einzelnen Zeichenkette \lstinline!Z! auch Vektoren von Zeichenketten.
\begin{itemize}
\item \lstinline!tolower("<<Z>>")! und \lstinline!toupper("<<Z>>")! konvertieren die Buchstaben in \lstinline!Z! in Klein- bzw.\ Großbuchstaben.
\item \lstinline!strtrim("<<Z>>", width=<<Anzahl>>)! schneidet \lstinline!Z! hinter \lstinline!width! vielen Buchstaben ab.
\item Demgegenüber erstellt \lstinline!abbreviate("<<Z>>", minlength=<<Anzahl>>)! eine Kurzform von \lstinline!Z! mit \lstinline!minlength! vielen Buchstaben, wobei ursprünglich unterschiedliche Zeichenketten desselben Vektors unterscheidbar bleiben. Dies kann etwa beim Erstellen von übersichtlichen Variablen-Bezeichnungen für Diagrammachsen oder Tabellen sinnvoll sein.
\item Leerzeichen und anderen Leerraum zu Beginn oder Ende von \lstinline!Z! entfernt \lstinline!trimws("<<Z>>", which)! (\emph{trim whitespace}). Mit dem Argument \lstinline!which="left"! betrifft dies nur den Anfang, analog mit \lstinline!"right"! nur das Ende und mit \lstinline!"both"! sowohl Anfang als auch Ende von \lstinline!Z!.
\item Buchstaben innerhalb von \lstinline!Z! wiederholt \lstinline!strrep("<<Z>>", times)! (\emph{string repeat}). Das Argument \lstinline!times! gibt an, wie oft \lstinline!Z! jeweils aneinandergehängt werden soll. 
\item Mit \lstinline!StrRev("<<Z>>")! (\emph{string reverse}) aus dem Paket \lstinline!DescTools!\index[pack]{DescTools@\lstinline{DescTools}} wird die Reihenfolge der Zeichen in \lstinline!Z! umgekehrt.
\end{itemize}
\begin{lstlisting}
> tolower(c("A", "BC", "DEF"))
[1] "a" "bc" "def"

> strtrim("AfairlyLongString", width=6)
[1] "Afairl"

> abbreviate("AfairlyLongString", minlength=6)
AfairlyLongString
         "AfrlLS"

> trimws(c("  Quattuor ", "   quinque   "), which="both")
[1] "Quattuor" "quinque"

> strrep(c("A", "B", "C"), 1:3)
[1] "A"   "BB"  "CCC"

> library(DescTools)                      # für StrRev()
> StrRev(c("Lorem", "ipsum", "dolor", "sit"))
[1] "meroL" "muspi" "rolod" "tis"
\end{lstlisting}

\index{Zeichenketten!zerlegen}
\index[func]{strsplit()@\lstinline{strsplit()}}
Mit \lstinline!strsplit()! (\emph{string split}) ist es möglich, eine einzelne Zeichenkette in mehrere Teile zu zerlegen.
\begin{lstlisting}
> strsplit(x="<<Zeichenkette>>", split="<<Zeichenkette>>", fixed=FALSE)
\end{lstlisting}

Die Elemente des für \lstinline!x! übergebenen Vektors werden dafür nach Vorkommen der unter \lstinline!split! genannten Zeichenkette durchsucht, die als Trennzeichen interpretiert wird. Die Zeichenfolgen links und rechts von \lstinline!split! machen die Komponenten der Ausgabe aus, die aus einer Liste von Vektoren von Zeichenketten besteht -- eine Komponente für jedes Element des Vektors von Zeichenketten \lstinline!x!. In der Voreinstellung \lstinline!split=NULL! werden die Elemente von \lstinline!x! in einzelne Zeichen zerlegt.\footnote{Die Ausgabe ist ggf.\ mit \lstinline!unlist()! (Abschn.\ \ref{sec:unlist}) in einen Vektor, oder mit \lstinline!do.call("cbind", <<Liste>>)! bzw.\ \lstinline!do.call("rbind", <<Liste>>)! in eine Matrix umzuwandeln, wenn die Listenkomponenten dieselbe Länge besitzen (Abschn.\ \ref{sec:sapply}).} \lstinline!strsplit()! ist damit die Umkehrung von \lstinline!paste()!. Das Argument \lstinline!fixed! bestimmt, ob \lstinline!split! i.\,S.\ eines \emph{regulären Ausdrucks} interpretiert werden soll (Voreinstellung \lstinline!FALSE!, Abschn.\ \ref{sec:grep}) oder als exakt die übergebene Zeichenfolge selbst (\lstinline!TRUE!).
\begin{lstlisting}
> strsplit(c("abc_def_ghi", "jkl_mno"), split="_")
[[1]]
[1] "abc" "def" "ghi"

[[2]]
[1] "jkl" "mno"

> strsplit("Xylophon", split=NULL)
[[1]]
[1] "X" "y" "l" "o" "p" "h" "o" "n"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenfolgen finden}
\label{sec:grep}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Zeichenfolgen finden}
Die Suche nach bestimmten Zeichenfolgen innerhalb von Zeichenketten ist mit \lstinline!match()!, \lstinline!pmatch()! und \lstinline!grep()! möglich. Soll geprüft werden, ob die in einem Vektor \lstinline!x! enthaltenen Elemente jeweils eine exakte Übereinstimmung in den Elementen eines Vektors \lstinline!table! besitzen, ist \lstinline!match()! anzuwenden. Beide Objekte müssen nicht unbedingt Zeichenketten sein, werden aber intern zu solchen\index[func]{match()@\lstinline{match()}} konvertiert.\footnote{\label{ftn:adist}\lstinline!adist()!\index[func]{adist()@\lstinline{adist()}} berechnet die Levenshtein-Distanz zwischen zwei Zeichenketten als Maß für die Anzahl notwendiger elementarer Editiervorgänge, um eine Zeichenkette in die andere zu ändern. Über die Levenshtein-Distanz können auch ungefähr passende Zeichenketten gefunden werden. Weitere Ansätze hierfür sind im Paket \lstinline!stringdist!\index[pack]{stringdist@\lstinline{stringdist}} \cite{vanderLoo2014} vorhanden.}
\begin{lstlisting}
> match(x=<<gesuchte Werte>>, table=<<Objekt>>)
\end{lstlisting}

Die Ausgabe gibt für jedes Element von \lstinline!x! die erste Position im Objekt \lstinline!table! an, an der es dort ebenfalls vorhanden ist. Enthält \lstinline!table! kein mit \lstinline!x! übereinstimmendes Element, ist die Ausgabe an dieser Stelle \lstinline!NA!\@.

\index[func]{pmatch()@\lstinline{pmatch()}}
Die fast identische Funktion \lstinline!pmatch()! unterscheidet sich darin, dass die Elemente von \lstinline!table! nicht nur auf exakte Übereinstimmung getestet werden: Findet sich für ein Element von \lstinline!x! ein identisches Element in \lstinline!table!, ist der Index das Ergebnis, an dem dieses Element zum ersten Mal vorkommt. Andernfalls wird in \lstinline!table! nach teilweisen Übereinstimmungen in dem Sinne gesucht, dass auch eine Zeichenkette zu einem Treffer führt, wenn sie mit jener aus \lstinline!x! beginnt, sofern es nur eine einzige solche Zeichenkette in \lstinline!table! gibt.
\begin{lstlisting}
> match(c("abc", "de", "f", "h"), c("abcde", "abc", "de", "fg", "ih"))
[1] 2 3 NA NA

> pmatch(c("abc", "de", "f", "h"), c("abcde", "abc", "de", "fg", "ih"))
[1] 2 3 4 NA
\end{lstlisting}

Speziell um zu prüfen, ob Zeichenketten in einem Vektor \lstinline!Z! mit einem bestimmten Muster beginnen bzw.\ enden, existieren die Funktionen \lstinline!startsWith(<<Z>>, prefix="<<Muster>>")!\index[func]{startsWith()@\lstinline{startsWith()}} und \lstinline!endsWith(<<Z>>, suffix="<<Muster>>")!\index[func]{endsWith()@\lstinline{endsWith()}}. \lstinline!prefix! bzw.\ \lstinline!suffix! müssen Zeichenketten sein, reguläre Ausdrücke sind hier nicht möglich.
\begin{lstlisting}
> startsWith(c("Train", "Station"), "T")
[1] TRUE FALSE

> endsWith(c("Train", "Station"), "n")
[1] TRUE TRUE
\end{lstlisting}

\lstinline!grep()!\index[func]{grep()@\lstinline{grep()}} ähnelt dem gleichlautenden POSIX-Befehl Unix-artiger Betriebssysteme und bietet stark erweiterte Suchmöglichkeiten.
\begin{lstlisting}
> grep(pattern="<<Suchmuster>>", x="<<Zeichenkette>>")
\end{lstlisting}

Unter \lstinline!pattern! ist ein Muster anzugeben, das die zu suchende Zeichenfolge definiert. Obwohl hier auch einfach eine bestimmte Zeichenfolge übergeben werden kann, liegt die Besonderheit darin, dass \lstinline!pattern!\index{Zeichenketten!regulärer Ausdruck}\index{regularer Ausdruck@regulärer Ausdruck|see{Zeichenketten}} reguläre Ausdrücke akzeptiert. Ein regulärer Ausdruck definiert eine Menge möglicher Zeichenfolgen, die dasselbe Muster besitzen, etwa {\quotedblbase}ein A gefolgt von einem B oder C und einem Leerzeichen{\textquotedblleft}: \lstinline!"A[BC][[:blank:]]"! (vgl.\ \lstinline!?regex!, \citeNP{Goyvaerts2012} und speziell für die Anwendung in R \citeNP{Spector2008}). Der zu durchsuchende Vektor von Zeichenketten wird unter \lstinline!x! genannt.

Die Ausgabe ist ein Vektor von Indizes derjenigen Elemente von \lstinline!x!, die das gesuchte Muster enthalten. Alternativ gibt die ansonsten genauso zu verwendende Funktion\index[func]{grepl()@\lstinline{grepl()}} \lstinline!grepl()! einen logischen Indexvektor aus, der für jedes Element von \lstinline!x! angibt, ob es \lstinline!pattern! enthält.
\begin{lstlisting}
> grep("A[BC][[:blank:]]", c("AB ", "AB", "AC ", "A "))
[1] 1 3

> grepl("A[BC][[:blank:]]", c("AB ", "AB", "AC ", "A "))
[1] TRUE FALSE TRUE FALSE
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenfolgen extrahieren}
\label{sec:substring}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Zeichenfolgen extrahieren}
\index[func]{substring()@\lstinline{substring()}}
Aus Zeichenketten lassen sich mit \lstinline!substring()! konsekutive Teilfolgen von Zeichen extrahieren.
\begin{lstlisting}
> substring(text="<<Zeichenkette>>", first=<<Beginn>>, last=<<Ende>>)
\end{lstlisting}

Aus den Elementen des für \lstinline!text! angegebenen Vektors von Zeichenketten wird jeweils jene Zeichenfolge extrahiert, die beim Buchstaben an der Stelle \lstinline!first! beginnt und mit dem Buchstaben an der Stelle \lstinline!last! endet. Umfasst eine Zeichenkette weniger als \lstinline!first! oder \lstinline!last! Buchstaben, werden nur so viele ausgeben, wie tatsächlich vorhanden sind -- ggf.\ eine leere Zeichenkette.
\begin{lstlisting}
> substring(c("ABCDEF", "GHIJK", "LMNO", "PQR"), first=4, last=5)
[1] "DE" "JK" "O" ""
\end{lstlisting}

Um mit Hilfe von regulären Ausdrücken definierte Zeichenfolgen aus Zeichenketten extrahieren zu können, ist neben der Information, \emph{ob} eine Zeichenkette die gesuchte Zeichenfolge enthält, auch die Information notwendig, an welcher Stelle sie ggf.\ auftaucht. Dies lässt sich mit \index[func]{regexpr()@\lstinline{regexpr()}} \lstinline!regexpr()! ermitteln.
\begin{lstlisting}
> regexpr(pattern="<<Suchmuster>>", text="<<Zeichenkette>>")
\end{lstlisting}

Die Argumente \lstinline!pattern! und \lstinline!text! haben jeweils dieselbe Bedeutung wie \lstinline!pattern! und \lstinline!x! von \lstinline!grep()!. Das Ergebnis ist ein numerischer Vektor mit so vielen Elementen wie jene von \lstinline!text!. Enthält ein Element von \lstinline!text! das Suchmuster nicht, ist das Ergebnis an dieser Stelle \lstinline!-1!. Andernfalls ist das Ergebnis die erste Stelle des zugehörigen Elements von \lstinline!text!, an der das gefundene Suchmuster dort beginnt. Der ausgegebene numerische Vektor besitzt weiterhin das Attribut \lstinline!match.length!, das seinerseits ein numerischer Vektor ist und codiert, wie viele Zeichen die Zeichenfolge umfasst, auf die das Suchmuster zutrifft. Auch hier steht die \lstinline!-1! für den Fall, dass sich das Suchmuster nicht in der Zeichenkette findet. Das Ergebnis eignet sich besonders, um mit der Funktion \lstinline!substring()! weiterverarbeitet zu werden, da sich aus ihm die Informationen für deren Argumente \lstinline!first! und \lstinline!last! leicht bestimmen lassen.
\begin{lstlisting}
> pat    <- "[[:upper:]]+"            # suche nach Großbuchstaben
> txt    <- c("abcDEFG", "ABCdefg", "abcdefg")
> (start <- regexpr(pat, txt))        # Start + Länge der Fundstellen
[1] 4 1 -1

attr(,"match.length")
[1] 4 3 -1

> len <- attr(start, "match.length")  # nur Länge der Fundstellen
> end <- start + len - 1              # letzte Zeichen der Fundstellen
> substring(txt, start, end)          # extrahiere Fundstellen
[1] "DEFG" "ABC" ""
\end{lstlisting}

Im Unterschied zu \lstinline!regexpr()! berücksichtigt die ansonsten gleich zu verwendende Funktion\index[func]{gregexpr()@\lstinline{gregexpr()}} \lstinline!gregexpr()! nicht nur das erste Auftreten von \lstinline!pattern! in \lstinline!text!, sondern auch ggf.\ spätere. Die Ausgabe ist eine Liste mit so vielen Komponenten, wie \lstinline!text! Elemente besitzt.

Eine Alternative zu \lstinline!substring()! bieten die in Abschn.\ \ref{sec:strSub} vorgestellten Funktionen \lstinline!sub()! bzw.\ \lstinline!gsub()!.

Da die Syntax regulärer Ausdrücke recht komplex ist, sorgt u.\,U.\ schon die Suche nach einfachen Mustern Schwierigkeiten. Eine Vereinfachung bietet die Funktion\index[func]{glob2rx()@\lstinline{glob2rx()}} \lstinline!glob2rx()!, mit der Muster von Zeichenfolgen mit Hilfe gebräuchlicherer\index{Zeichenketten!Platzhalter}\index{Zeichenketten!wildcards}\index{Zeichenketten!Globbing-Muster} Platzhalter (\emph{wildcards}\index{Globbing-Muster|see{Zeichenketten}} bzw.\ \emph{Globbing}-Muster) beschrieben und in einen regulären Ausdruck umgewandelt werden können. So steht z.\,B.\ der Platzhalter \lstinline!?! für ein beliebiges einzelnes Zeichen, \lstinline!*! für eine beliebige Zeichenkette.
\begin{lstlisting}
> glob2rx(pattern="<<Muster mit Platzhaltern>>")
\end{lstlisting}

Das Argument \lstinline!pattern! akzeptiert einen Vektor, dessen Elemente Zeichenfolgen aus Buchstaben und Platzhaltern sind. Die Ausgabe besteht aus einem Vektor mit regulären Ausdrücken, wie sie z.\,B.\ in \lstinline!grep()! angewendet werden können.
\begin{lstlisting}
> glob2rx("asdf*.txt")  # Namen, die mit asdf beginnen und .txt enden
[1] "^asdf.*\\.txt$"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenfolgen ersetzen}
\label{sec:strSub}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!Zeichenfolgen ersetzen}
Wenn in Zeichenketten nach bestimmten Zeichenfolgen gesucht wird, dann häufig, um sie durch andere zu ersetzen. Dies ist etwa möglich, indem dem Ergebnis von \lstinline!substring()! ein passender Vektor von Zeichenketten zugewiesen wird -- dessen Elemente ersetzen dann die durch \lstinline!first! und \lstinline!last! begrenzten Zeichenfolgen in den Elementen von \lstinline!text!. Dabei ist es notwendig, dass für \lstinline!text! ein bereits bestehendes Objekt übergeben wird, das dann der Änderung unterliegt.
\begin{lstlisting}
> charVec <- c("ABCDEF", "GHIJK", "LMNO", "PQR")
> substring(charVec, 4, 5) <- c("..", "xx", "++", "**")
> charVec
[1] "ABC..F" "GHIxx" "LMN+" "PQR"
\end{lstlisting}

\index[func]{sub()@\lstinline{sub()}}
Auch \lstinline!sub()! (\emph{substitute}) und \lstinline!gsub()! dienen dem Zweck, durch ein Muster definierte Zeichenfolgen innerhalb von Zeichenketten auszutauschen.
\begin{lstlisting}
> sub(pattern="<<Suchmuster>>", replacement="<<Ersatz>>",
+     x="<<Zeichenkette>>")
\end{lstlisting}

Für \lstinline!pattern! kann ein regulärer Ausdruck übergeben werden, dessen Vorkommen in den Elementen von \lstinline!x! durch die unter \lstinline!replacement! genannte Zeichenfolge ersetzt werden. Wenn \lstinline!pattern! in einem Element von \lstinline!x! mehrfach vorkommt, wird es nur beim ersten Auftreten ersetzt.
\begin{lstlisting}
> sub("em", "XX", "Lorem ipsum dolor sit Lorem ipsum")
[1] "LorXX ipsum dolor sit Lorem ipsum"
\end{lstlisting}

\index[func]{gsub()@\lstinline{gsub()}}
Im Unterschied zu \lstinline!sub()! ersetzt die ansonsten gleich zu verwendende \lstinline!gsub()! Funktion \lstinline!pattern! nicht nur beim ersten Auftreten in \lstinline!x! durch \lstinline!replacement!, sondern überall.
\begin{lstlisting}
> gsub("em", "XX", "Lorem ipsum dolor sit Lorem ipsum")
[1] "LorXX ipsum dolor sit LorXX ipsum"
\end{lstlisting}

In \lstinline!pattern! können runde Klammern \lstinline!(<<Muster>>)! zur Definition von Gruppen innerhalb des regulären Ausdrucks verwendet werden. Die Gruppen sind intern numeriert. Zeichenketten, die das Muster einer Gruppe aufweisen, sind dann innerhalb von \lstinline!replacement! über die Angabe der Gruppen-Nummer in der Form \lstinline!"\\<<Nummer>>"! abrufbar (\emph{back referencing}). Auf diese Weise lassen sich Zeichenfolgen etwas einfacher als mit \lstinline!substring()! (Abschn.\ \ref{sec:substring}) extrahieren.

Im Beispiel definiert der reguläre Ausdruck eine Zeichenkette, die mit einem oder mehr Buchstaben beginnt, dann in \lstinline!-! eingeschlossen eine Gruppe von einer oder mehr Ziffern aufweist und mit einem oder mehr Buchstaben endet. Die Zifferngruppe wird durch back referencing extrahiert.
\begin{lstlisting}
> gsub("^[[:alpha:]]+-([[:digit:]]+)-[[:alpha:]]+$",
+      "\\1", "abc-412-def")
[1] "412"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zeichenketten als Befehl ausführen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Zeichenketten!ausführen}
\index[func]{parse()@\lstinline{parse()}}
Durch die Kombination von \lstinline!parse()! und \lstinline!eval()! lassen sich Zeichenketten als Befehle interpretieren und wie direkt eingegebene Befehle ausführen. Dieses Zusammenspiel ermöglicht es, in Abhängigkeit von vorherigen Auswertungen einen nachfolgend benötigten Befehl zunächst als Zeichenkette zu erstellen und dann auszuführen.
\begin{lstlisting}
> parse(file="<<Pfad und Dateiname>>", text="<<Zeichenkette>>")
\end{lstlisting}

Hierfür ist zunächst mit \lstinline!parse()! eine für das Argument \lstinline!text! zu übergebende Zeichenkette in ein weiter interpretierbares Objekt umzuwandeln.\footnote{Solcherart erstellte Objekte können mit\index[func]{deparse()@\lstinline{deparse()}} \lstinline!deparse()! wieder in Zeichenketten umgewandelt werden.} Ist \lstinline!text! ein Vektor von Zeichenketten, wird jedes Element als ein Befehl verstanden. Alternativ kann mit \lstinline!file! eine Datei oder sonstige Quelle genannt werden, die eine solche Zeichenkette enthält (Abschn.\ \ref{sec:readTable}).
\begin{lstlisting}
> obj1 <- parse(text="3 + 4")
> obj2 <- parse(text=c("vec <- c(1, 2, 3)", "vec^2"))
\end{lstlisting}

\index[func]{eval()@\lstinline{eval()}}
Das Ausführen eines mit \lstinline!parse()! erstellten Objekts geschieht mit \lstinline!eval(<<expression>>)!.
\begin{lstlisting}
> eval(obj1)
[1] 7

> eval(obj2)
[1] 1 4 9
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Datum und Uhrzeit}
\label{sec:date}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Insbesondere bei der Analyse von Zeitreihen\footnote{Für die Auswertung von Zeitreihen vgl.\ \citeA{Shumway2006} sowie den Abschnitt \emph{Time Series Analysis} der CRAN Task Views \cite{CRANtvTimeSeries}.} ist es sinnvoll, Zeit- und Datumsangaben in einer Form zu speichern, die es erlaubt, solche Werte in natürlicher Art für Berechnungen zu nutzen -- etwa um über die Differenz zweier Uhrzeiten die zwischen ihnen verstrichene Zeit ebenso zu ermitteln wie die zwischen zwei Datumsangaben liegende Anzahl von Tagen. R bietet solche Möglichkeiten mit Hilfe besonderer Klassen.\footnote{Für eine einführende Behandlung der vielen für Zeitangaben existierenden Subtilitäten vgl.\ \citeA{Grothendieck2004} sowie \lstinline!?DateTimeClasses!. Der Umgang mit Zeit- und Datumsangaben wird durch Funktionen des Pakets \lstinline!lubridate!\index[pack]{lubridate@\lstinline{lubridate}} \cite{Grolemund2011} erleichtert. Das Paket \lstinline!timeDate!\index[pack]{timeDate@\lstinline{timeDate}} \cite{Wurtz2008} enthält viele weiterführende Funktionen zur Verarbeitung solcher Daten.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Datumsangaben erstellen und formatieren}
\label{sec:dateFormat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Objekte der Klasse\index[func]{Date@\lstinline{Date}} \lstinline!Date! codieren ein Datum mittels der seit einem Stichtag (meist der 1.\ Januar 1970) verstrichenen Anzahl von Tagen und können Tag, Monat und Jahr eines Zeitpunkts ausgeben. Das aktuelle Datum unter Beachtung der Zeitzone nennt\index[func]{Sys.Date()@\lstinline{Sys.Date()}} \lstinline!Sys.Date()! in Form eines \lstinline!Date! Objekts. Um selbst ein Datum zu erstellen, ist\index[func]{as.Date()@\lstinline{as.Date()}} \lstinline!as.Date()! zu verwenden.
\begin{lstlisting}
> as.Date(x="<<Datumsangabe>>", format="<<format string>>")
\end{lstlisting}

Die Datumsangabe für \lstinline!x! ist eine Zeichenkette, die ein Datum in einem Format nennt, das unter \lstinline!format! als\index{format string} format string zu spezifizieren ist. In einer solchen Zeichenkette stehen \lstinline!%<<Buchstabe>>! Kombinationen als Platzhalter für den einzusetzenden Teil einer Datumsangabe, sonstige Zeichen i.\,d.\,R.\ für sich selbst. Voreinstellung ist \lstinline!"%Y-%m-%d"!, wobei \lstinline!%Y! für die vierstellige Jahreszahl, \lstinline!%m! für die zweistellige Zahl des Monats und \lstinline!%d! für die zweistellige Zahl der Tage steht.\footnote{\label{ftn:dateFormat}Siehe Abschn.\ \ref{sec:strings} sowie \lstinline!?strptime! für weitere mögliche Elemente des format strings. Diese Hilfe-Seite erläutert auch, wie mit Namen für Wochentage und Monate in unterschiedlichen Sprachen umzugehen ist.} In diesem Format erfolgt auch die Ausgabe, die sich jedoch mit\index[func]{format()@\lstinline{format()}} \lstinline!format(<<Date-Objekt>>, format="<<format string>>")! kontrollieren lässt.
\begin{lstlisting}
> Sys.Date()
[1] "2009-02-09"

> (myDate <- as.Date("01.11.1974", format="%d.%m.%Y"))
[1] "1974-11-01"

> format(myDate, format="%d.%m.%Y")
[1] "01.11.1974"
\end{lstlisting}

Ihre numerische Repräsentation lässt sich direkt zum Erstellen von \lstinline!Date! Objekten nutzen.
\begin{lstlisting}
> as.Date(x=<<Vektor>>, origin=<<Stichtag>>)
\end{lstlisting}

Für \lstinline!x! ist ein numerischer Vektor mit der seit dem Stichtag \lstinline!origin! verstrichenen Anzahl von Tagen zu nennen. Negative Zahlen stehen dabei für die Anzahl der Tage vor dem Stichtag. Der Stichtag selbst muss in Form eines \lstinline!Date! Objekts angegeben werden.
\begin{lstlisting}
# Datum, das 374 Tage vor dem 16.12.1910 liegt
> (negDate <- as.Date(-374, "1910-12-16"))
[1] "1909-12-07"

> as.numeric(negDate)             # Anzahl Tage vor Standard-Stichtag
[1] -21940
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Uhrzeit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{Uhrzeit}
\index{Zeit|see{Uhrzeit}}
Objekte der Klasse\index[func]{POSIXct@\lstinline{POSIXct}} \lstinline!POSIXct! (\emph{calendar time}) repräsentieren neben dem Datum gleichzeitig die Uhrzeit eines Zeitpunkts als Anzahl der Sekunden, die seit einem Stichtag (meist der 1.\ Januar 1970) verstrichen ist, besitzen also eine Genauigkeit von einer Sekunde. Negative Zahlen stehen dabei für die Anzahl der Sekunden vor dem Stichtag. \lstinline!POSIXct! Objekte berücksichtigen die Zeitzone sowie die Unterscheidung von Sommer- und Winterzeit.

\lstinline!Sys.time()!\index[func]{Sys.time()@\lstinline{Sys.time()}} gibt das aktuelle Datum nebst Uhrzeit in Form eines \lstinline!POSIXct! Objekts aus, allerdings für eine Standard-Zeitzone. Das Ergebnis muss deshalb mit den u.\,g.\ Funktionen in die aktuelle Zeitzone konvertiert werden. Alternativ gibt \index[func]{date()@\lstinline{date()}} \lstinline!date()! Datum und Uhrzeit mit englischen Abkürzungen für Wochentag und Monat als Zeichenkette aus, wobei die aktuelle Zeitzone berücksichtigt wird.
\begin{lstlisting}
> Sys.time()
[1] "2009-02-07 09:23:02 CEST"

> date()
[1] "Sat Feb 7 09:23:02 2009"
\end{lstlisting}

Objekte der Klasse\index[func]{POSIXlt@\lstinline{POSIXlt}} \lstinline!POSIXlt! (\emph{local time}) speichern dieselbe Information, allerdings nicht in Form der seit einem Stichtag verstrichenen Sekunden, sondern als Liste mit benannten Komponenten: Dies sind numerische Vektoren u.\,a.\ für die Sekunden (\lstinline!sec!), Minuten (\lstinline!min!) und Stunden (\lstinline!hour!) der Uhrzeit sowie für Tag (\lstinline!mday!), Monat (\lstinline!mon!) und Jahr (\lstinline!year!) des Datums. Zeichenketten lassen sich analog zu \lstinline!as.Date()! mit\index[func]{as.POSIXct()@\lstinline{as.POSIXct()}} \lstinline!as.POSIXct()! bzw.\ mit\index[func]{as.POSIXlt()@\lstinline{as.POSIXlt()}} \lstinline!as.POSIXlt()! in entsprechende Objekte konvertieren, \lstinline!strptime()!\index[func]{strptime()@\lstinline{strptime()}} erzeugt ebenfalls ein \lstinline!POSIXlt! Objekt.
\begin{lstlisting}
> as.POSIXct(x="<<Datum und Uhrzeit>>", format="<<format string>>")
> as.POSIXlt(x="<<Datum und Uhrzeit>>", format="<<format string>>")
>   strptime(x="<<Datum und Uhrzeit>>", format="<<format string>>")
\end{lstlisting}

Voreinstellung für den format string bei \lstinline!as.POSIXlt()! und bei \lstinline!as.POSIXct()! ist \lstinline!"%Y-%m-%d %H:%M:%S"!, wobei \lstinline!%H! für die zweistellige Zahl der Stunden im 24~h-Format, \lstinline!%M! für die zweistellige Zahl der Minuten und \lstinline!%S! für die zweistellige Zahl der Sekunden des Datums stehen (Fußnote \ref{ftn:dateFormat}).
\begin{lstlisting}
> (myTime <- as.POSIXct("2009-02-07 09:23:02"))
[1] "2009-02-07 09:23:02 CET"

> charDates <- c("05.08.1972, 03:37", "31.03.1981, 12:44")
> (lDates   <- strptime(charDates, format="%d.%m.%Y, %H:%M"))
[1] "1972-08-05 03:37:00" "1981-03-31 12:44:00"

> lDates$mday                           # Tag isoliert
[1] 5 31

> lDates$hour                           # Stunde isoliert
[1] 3 12
\end{lstlisting}

\index[func]{ISOdate()@\lstinline{ISOdate()}}
\lstinline!POSIXct! Objekte können besonders einfach mit der Funktion \lstinline!ISOdate()! erstellt werden, die intern auf \lstinline!strptime()! basiert, aber keinen format string benötigt.
\begin{lstlisting}
> ISOdate(year=<<Jahr>>, month=<<Monat>>, day=<<Tag>>,
+         hour=<<Stunde>>, min=<<Minute>>, sec=<<Sekunde>>,
+         tz="<<Zeitzone>>")
\end{lstlisting}

Für die sich auf Datum und Uhrzeit beziehenden Argumente können Zahlen im $24$~h-Format angegeben werden, wobei 12:00:00~h Voreinstellung für die Uhrzeit ist. Mit \lstinline!tz! lässt sich die Zeitzone im Form der standardisierten Akronyme festlegen, Voreinstellung ist hier \lstinline!"GMT"!.
\begin{lstlisting}
# Zeitzone: Central European Time
> ISOdate(2010, 6, 30, 17, 32, 10, tz="CET")
[1] "2010-06-30 17:32:10 CEST"
\end{lstlisting}

Auch Objekte der Klassen \lstinline!POSIXct! und \lstinline!POSIXlt! können mit\index[func]{format()@\lstinline{format()}} \lstinline!format()! in der gewünschten Formatierung ausgegeben werden.
\begin{lstlisting}
> format(myTime, "%H:%M:%S")        # nur Stunden, Minuten, Sekunden
[1] "09:23:02"

> format(lDates, "%d.%m.%Y")        # nur Tag, Monat, Jahr
[1] "05.08.1972" "31.03.1981"
\end{lstlisting}

\index[func]{weekdays()@\lstinline{weekdays()}}
\index[func]{months()@\lstinline{months()}}
\index[func]{quarters()@\lstinline{quarters()}}
Aus Datumsangaben der Klasse \lstinline!Date!, \lstinline!POSIXct! und \lstinline!POSIXlt! lassen sich bestimmte weitere Informationen in Form von Zeichenketten extrahieren, etwa der Wochentag mit \lstinline!weekdays(<<Datum>>)!, der Monat mit \lstinline!months(<<Datum>>)! oder das Quartal mit \lstinline!quarters(<<Datum>>)!.
\begin{lstlisting}
> weekdays(lDates)
[1] "Samstag" "Dienstag"

> months(lDates)
[1] "August" "März"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mit Datum und Uhrzeit rechnen}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Objekte der Klasse \lstinline!Date!, \lstinline!POSIXct! und \lstinline!POSIXlt! verhalten sich in vielen arithmetischen Kontexten in natürlicher Weise, da die sinnvoll für Daten interpretierbaren Rechenfunktionen besondere Methoden für sie besitzen (Abschn.\ \ref{sec:funcGeneric}): So werden zu \lstinline!Date! Objekten addierte Zahlen als Anzahl von Tagen interpretiert; das Ergebnis ist ein Datum, das entsprechend viele Tage vom \lstinline!Date! Objekt abweicht. Die Differenz zweier \lstinline!Date! Objekte besitzt die Klasse \lstinline!difftime! und wird als Anzahl der Tage im Zeitintervall vom zweiten zum ersten Datum ausgegeben. Hierbei ergeben sich negative Zahlen, wenn das erste Datum zeitlich vor dem zweiten liegt.\footnote{Die Zeiteinheit der im \lstinline!difftime! Objekt gespeicherten Werte (etwa Tage oder Minuten), hängt davon ab, aus welchen Datumsangaben das Objekt entstanden ist. Alternativ bestimmt das Argument \lstinline!units! von\index[func]{difftime()@\lstinline{difftime()}} \lstinline!difftime()!, um welche Einheit es sich handeln soll.} Ebenso wie Zahlen lassen sich auch \lstinline!difftime! Objekte zu \lstinline!Date! Objekten addieren.
\begin{lstlisting}
> myDate + 365
[1] "1975-11-01"

> (diffDate <- as.Date("1976-06-19") - myDate)  # Zeitintervall
Time difference of 596 days

> as.numeric(diffDate)                          # Intervall als Zahl
[1] 596

> myDate + diffDate
[1] "1976-06-19"
\end{lstlisting}

Zu Objekten der Klasse \lstinline!POSIXlt! oder \lstinline!POSIXct! addierte Zahlen werden als Sekunden interpretiert. Aus der Differenz zweier solcher Objekte entsteht ebenfalls ein Objekt der Klasse \lstinline!difftime!. Die Addition von \lstinline!difftime! und \lstinline!POSIXlt! oder \lstinline!POSIXct! Objekten ist ebenfalls definiert.
\begin{lstlisting}
> lDates + c(60, 120)                           # 1, 2 Minuten später
[1] "1972-08-05 03:38:00 CET" "1981-03-31 12:46:00 CEST"

> (diff21 <- lDates[2] - lDates[1])
Time difference of 3160.338 days

> lDates[1] + diff21
[1] "1981-03-31 12:44:00 CEST"
\end{lstlisting}

In \lstinline!seq()! (Abschn.\ \ref{sec:seq}) ändert sich die Bedeutung des Arguments \lstinline!by! hin zu Zeitangaben, wenn für \lstinline!from! und \lstinline!to! Datumsangaben übergeben werden. Für die Schrittweite werden dann etwa die Werte \lstinline!"<<Anzahl>> years"! oder \lstinline!"<<Anzahl>> days"! akzeptiert (vgl.\ \lstinline!?seq.POSIXt!). Dies gilt analog auch für das Argument \lstinline!breaks! der \lstinline!cut()! Funktion (Abschn.\ \ref{sec:cut}), die kontinuierliche Daten in Kategorien einteilt, die etwa durch Stunden (\lstinline!breaks="hour"!) oder Kalenderwochen (\lstinline!breaks="week"!) definiert sind (vgl.\ \lstinline!?cut.POSIXt!). Für weitere geeignete arithmetische Funktionen vgl.\ \lstinline!methods(class="POSIXt")! und \lstinline!methods(class="Date")!.
\begin{lstlisting}
# jährliche Schritte vom 01.05.2010 bis zum 01.05.2013
> seq(ISOdate(2010, 5, 1), ISOdate(2015, 5, 1), by="years")
[1] "2010-05-01 12:00:00 GMT" "2011-05-01 12:00:00 GMT"
[3] "2012-05-01 12:00:00 GMT" "2013-05-01 12:00:00 GMT"

# 4 zweiwöchentliche Schritte vom 22.10.1997
> seq(ISOdate(1997, 10, 22), by="2 weeks", length.out=4)
[1] "1997-10-22 12:00:00 GMT" "1997-11-05 12:00:00 GMT"
[3] "1997-11-19 12:00:00 GMT" "1997-12-03 12:00:00 GMT"

# 100 zufällige Daten zwischen 13.06.1995 und 4 Wochen später
> secsPerDay <- 60 * 60 * 24                # Sekunden pro Tag
> randDates  <- ISOdate(1995, 6, 13)
+               + sample(0:(28*secsPerDay), 100, replace=TRUE)

# rounde Zufallsdaten Tag-genau
> head(round(randDates, units="days"), n=4)
[1] "1995-07-03 GMT" "1995-06-24 GMT" "1995-07-11 GMT" "1995-06-29 GMT"

# teile Daten in Kalenderwochen ein
> randWeeks <- cut(randDates, breaks="week")
> summary(randWeeks)                        # Häufigkeiten
1995-06-12  1995-06-19  1995-06-26  1995-07-03  1995-07-10
        15          26          20          37           2
\end{lstlisting}
